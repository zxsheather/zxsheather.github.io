<h2 id="概述">概述</h2>

<p>内核已经加载到内存中，现在是引导加载程序的最后一步：将控制权交给内核。这涉及到从 ELF 头读取入口地址，并执行跳转。</p>

<hr />

<h2 id="原始代码">原始代码</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#### Transfer control to the kernel that we loaded.  We read the start
#### address out of the ELF header (see [ELF1]) and convert it from a
#### 32-bit linear address into a 16:16 segment:offset address for
#### real mode, then jump to the converted address.  The 80x86 doesn't
#### have an instruction to jump to an absolute segment:offset kept in
#### registers, so in fact we store the address in a temporary memory
#### location, then jump indirectly through that location.  To save 4
#### bytes in the loader, we reuse 4 bytes of the loader's code for
#### this temporary pointer.

	mov $0x2000, %ax
	mov %ax, %es
	mov %es:0x18, %dx
	mov %dx, start
	movw $0x2000, start + 2
	ljmp *start
</code></pre></div></div>

<hr />

<h2 id="前置知识">前置知识</h2>

<h3 id="elf-头部结构">ELF 头部结构</h3>

<p>ELF 文件的开头是一个固定格式的头部：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>偏移    大小    字段名           说明
────────────────────────────────────────────
0x00    4      e_ident[0-3]     魔数 "\x7FELF"
0x04    1      e_ident[4]       类别（32位/64位）
0x05    1      e_ident[5]       字节序（小端/大端）
0x06    1      e_ident[6]       ELF 版本
0x07    9      e_ident[7-15]    填充
0x10    2      e_type           文件类型
0x12    2      e_machine        目标架构
0x14    4      e_version        ELF 版本
0x18    4      e_entry          入口点地址 ← 我们要读这个！
0x1C    4      e_phoff          程序头表偏移
0x20    4      e_shoff          节头表偏移
...
</code></pre></div></div>

<p><strong>入口点地址</strong>（e_entry）位于偏移 0x18，是一个 32 位地址，告诉系统从哪里开始执行程序。</p>

<h3 id="远跳转far-jump">远跳转（Far Jump）</h3>

<p>在 x86 实模式中，有两种跳转：</p>

<ol>
  <li><strong>近跳转（Near Jump）</strong>：只改变 IP，在当前代码段内跳转</li>
  <li><strong>远跳转（Far Jump）</strong>：同时改变 CS 和 IP，可以跳转到任何地址</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>近跳转：            远跳转：
jmp label          ljmp segment:offset
只修改 IP          修改 CS 和 IP
</code></pre></div></div>

<h3 id="间接跳转">间接跳转</h3>

<p>x86 的 <code class="language-plaintext highlighter-rouge">ljmp</code>（远跳转）指令不能直接从寄存器获取地址，必须通过内存：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 错误：不能这样做
ljmp %ax:%dx        # 语法错误！

# 正确：通过内存间接跳转
ljmp *memory_address
</code></pre></div></div>

<p>内存中的格式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory_address:     [偏移低字节] [偏移高字节] [段低字节] [段高字节]
                    ←─── 偏移（2字节）────→ ←── 段（2字节）──→
</code></pre></div></div>

<hr />

<h2 id="逐行详解">逐行详解</h2>

<h3 id="第-1-2-行设置-es-指向内核">第 1-2 行：设置 ES 指向内核</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	mov $0x2000, %ax
	mov %ax, %es
</code></pre></div></div>

<p>将 ES 设置为 0x2000，这样 ES:0x18 就指向内核 ELF 头的入口地址字段。</p>

<p><strong>地址计算：</strong></p>
<ul>
  <li>ES = 0x2000</li>
  <li>物理地址 = 0x2000 × 16 + 0x18 = 0x20018</li>
</ul>

<hr />

<h3 id="第-3-行读取入口地址">第 3 行：读取入口地址</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	mov %es:0x18, %dx
</code></pre></div></div>

<p>从 ELF 头偏移 0x18 处读取入口地址的低 16 位到 DX。</p>

<p><strong>为什么只读低 16 位？</strong></p>

<p>Pintos 内核的入口地址在实模式下可以用 16:16 的段:偏移表示。入口地址的低 16 位就是偏移部分。</p>

<p><strong>Pintos 内核的入口地址：</strong></p>

<p>内核加载到 0x20000，入口地址通常在这附近。假设入口地址是 0x20000：</p>
<ul>
  <li>段 = 0x2000</li>
  <li>偏移 = 0x0000</li>
</ul>

<hr />

<h3 id="第-4-行存储偏移部分">第 4 行：存储偏移部分</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	mov %dx, start
</code></pre></div></div>

<p>将 DX（偏移）存储到 <code class="language-plaintext highlighter-rouge">start</code> 标签处。</p>

<p><strong><code class="language-plaintext highlighter-rouge">start</code> 在哪里？</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read_failed:
start:
	# Disk sector read failed.
	call puts
1:	.string "\rBad read\r"
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">start</code> 和 <code class="language-plaintext highlighter-rouge">read_failed</code> 是同一个位置！这是一个巧妙的代码复用：</p>
<ul>
  <li>如果读取失败，会执行这里的错误处理代码</li>
  <li>如果读取成功，这里的代码会被跳转地址覆盖</li>
</ul>

<hr />

<h3 id="第-5-行存储段部分">第 5 行：存储段部分</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	movw $0x2000, start + 2
</code></pre></div></div>

<p>将段地址 0x2000 存储到 <code class="language-plaintext highlighter-rouge">start + 2</code> 处（偏移之后的 2 个字节）。</p>

<p><strong>内存布局：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start:      [偏移低] [偏移高] [段低] [段高]
            └── DX ──┘     └─0x2000─┘
</code></pre></div></div>

<hr />

<h3 id="第-6-行远跳转到内核">第 6 行：远跳转到内核</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	ljmp *start
</code></pre></div></div>

<p>执行间接远跳转，从 <code class="language-plaintext highlighter-rouge">start</code> 处读取 4 字节的段:偏移地址，然后跳转。</p>

<p><strong>执行过程：</strong></p>

<ol>
  <li>从 <code class="language-plaintext highlighter-rouge">start</code> 读取 4 字节</li>
  <li>低 2 字节 → IP（指令指针）</li>
  <li>高 2 字节 → CS（代码段）</li>
  <li>跳转到 CS:IP</li>
</ol>

<hr />

<h2 id="地址转换详解">地址转换详解</h2>

<h3 id="32-位线性地址到-1616-段偏移">32 位线性地址到 16:16 段:偏移</h3>

<p>假设 ELF 入口地址是 0x00020000：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>32位线性地址: 0x00020000

转换为 16:16 格式:
段地址 = 0x2000
偏移   = 0x0000

验证: 0x2000 × 16 + 0x0000 = 0x20000 ✓
</code></pre></div></div>

<p><strong>但代码中只读了低 16 位？</strong></p>

<p>对于 Pintos，段地址总是 0x2000（内核加载地址除以 16），偏移是入口地址减去 0x20000 后的值。</p>

<p>由于内核入口通常在文件开头附近，偏移值很小，16 位足够。</p>

<h3 id="更复杂的例子">更复杂的例子</h3>

<p>如果入口地址是 0x00020100：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>线性地址: 0x00020100

转换:
- 基址: 0x20000（段 0x2000）
- 偏移: 0x00020100 - 0x00020000 = 0x0100

段:偏移 = 0x2000:0x0100
</code></pre></div></div>

<hr />

<h2 id="代码复用技巧详解">代码复用技巧详解</h2>

<p>这段代码的一个亮点是<strong>代码复用</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read_failed:
start:
	call puts
1:	.string "\rBad read\r"
</code></pre></div></div>

<p><strong>如果读取失败：</strong></p>
<ul>
  <li>跳转到 <code class="language-plaintext highlighter-rouge">read_failed</code></li>
  <li>执行 <code class="language-plaintext highlighter-rouge">call puts</code> 打印错误信息</li>
</ul>

<p><strong>如果读取成功：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mov %dx, start</code> 覆盖了 <code class="language-plaintext highlighter-rouge">call puts</code> 的操作码</li>
  <li><code class="language-plaintext highlighter-rouge">movw $0x2000, start + 2</code> 覆盖了更多字节</li>
  <li><code class="language-plaintext highlighter-rouge">ljmp *start</code> 从被覆盖的位置读取跳转地址</li>
</ul>

<p><strong>内存变化：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原始代码（read_failed）:
start:   E8 xx xx    (call puts 的机器码)
start+3: ...         (字符串地址)

覆盖后:
start:   [偏移低] [偏移高] [段低] [段高]
         被解释为跳转地址
</code></pre></div></div>

<p>这样节省了 4 字节的存储空间——在 512 字节限制下非常宝贵！</p>

<hr />

<h2 id="跳转后的状态">跳转后的状态</h2>

<p>执行 <code class="language-plaintext highlighter-rouge">ljmp *start</code> 后：</p>

<table>
  <thead>
    <tr>
      <th>寄存器/内存</th>
      <th>值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CS</td>
      <td>0x2000</td>
      <td>代码段指向内核</td>
    </tr>
    <tr>
      <td>IP</td>
      <td>入口偏移</td>
      <td>从 ELF 头读取</td>
    </tr>
    <tr>
      <td>DS</td>
      <td>0x0000</td>
      <td>数据段（未改变）</td>
    </tr>
    <tr>
      <td>SS</td>
      <td>0x0000</td>
      <td>栈段（未改变）</td>
    </tr>
    <tr>
      <td>ESP</td>
      <td>~0xF000</td>
      <td>栈指针（基本未变）</td>
    </tr>
    <tr>
      <td>DL</td>
      <td>启动硬盘号</td>
      <td>内核可以使用</td>
    </tr>
    <tr>
      <td>0x20000+</td>
      <td>内核代码</td>
      <td>已加载的内核</td>
    </tr>
  </tbody>
</table>

<p><strong>内核（start.S）从这里接管！</strong></p>

<hr />

<h2 id="跳转目标starts">跳转目标：start.S</h2>

<p>Loader 跳转后，控制权交给 <code class="language-plaintext highlighter-rouge">start.S</code>，它的任务是：</p>

<ol>
  <li>设置保护模式的 GDT</li>
  <li>切换到 32 位保护模式</li>
  <li>设置 32 位栈</li>
  <li>跳转到 C 语言的 <code class="language-plaintext highlighter-rouge">main()</code> 函数</li>
</ol>

<p>这是下一阶段的引导过程，超出了 loader.S 的范围。</p>

<hr />

<h2 id="为什么需要这么复杂">为什么需要这么复杂？</h2>

<h3 id="问题-1x86-没有直接的远跳转指令">问题 1：x86 没有直接的远跳转指令</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 我们想做的：
ljmp $0x2000, %dx       # 错误！语法不支持

# 我们必须做的：
mov %dx, memory         # 存储偏移
movw $0x2000, memory+2  # 存储段
ljmp *memory            # 间接跳转
</code></pre></div></div>

<h3 id="问题-2空间限制">问题 2：空间限制</h3>

<p>引导扇区只有 512 字节，必须节省空间：</p>
<ul>
  <li>不能单独分配 4 字节存储跳转地址</li>
  <li>复用 <code class="language-plaintext highlighter-rouge">read_failed</code> 代码的位置</li>
</ul>

<hr />

<h2 id="执行流程图">执行流程图</h2>

<pre><code class="language-mermaid">flowchart TD
    A["内核已加载到 0x20000"] --&gt; B["ES = 0x2000&lt;br/&gt;指向内核 ELF 头"]
    B --&gt; C["DX = ES:0x18&lt;br/&gt;读取入口地址偏移"]
    C --&gt; D["存储到 start:&lt;br/&gt;[偏移] [0x2000]"]
    D --&gt; E["ljmp *start&lt;br/&gt;跳转到 0x2000:偏移"]
    E --&gt; F["现在执行内核代码&lt;br/&gt;(start.S)"]
</code></pre>

<hr />

<h2 id="常见问题">常见问题</h2>

<h3 id="q1-为什么段地址是-0x2000-而不是从-elf-头读取">Q1: 为什么段地址是 0x2000 而不是从 ELF 头读取？</h3>

<p>简化！Pintos loader 假设：</p>
<ul>
  <li>内核总是加载到 0x20000</li>
  <li>入口地址在 0x20000 附近</li>
  <li>段地址固定为 0x2000，只需读取偏移</li>
</ul>

<h3 id="q2-如果入口地址不在-0x20000-0x2ffff-范围内会怎样">Q2: 如果入口地址不在 0x20000-0x2FFFF 范围内会怎样？</h3>

<p>会出错！但 Pintos 的构建系统保证内核入口在这个范围内。</p>

<h3 id="q3-为什么要用-1616-段偏移而不是直接用-32-位地址">Q3: 为什么要用 16:16 段:偏移而不是直接用 32 位地址？</h3>

<p>因为 CPU 还在实模式！实模式只能用段:偏移寻址。切换到保护模式后才能用 32 位线性地址。</p>

<h3 id="q4-跳转后-loader-的代码还在内存中吗">Q4: 跳转后 loader 的代码还在内存中吗？</h3>

<p>是的，但已经不再执行。内存 0x7C00-0x7DFF 的内容仍然存在，直到被覆盖。</p>

<hr />

<h2 id="机器码分析">机器码分析</h2>

<p>让我们看看 <code class="language-plaintext highlighter-rouge">ljmp *start</code> 的机器码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>操作码: FF 2E xx xx
        │  │  └──┴── start 的地址（2 字节）
        │  └─────── ModR/M 字节（/5 = 间接远跳转）
        └────────── 操作码前缀
</code></pre></div></div>

<p>这条指令告诉 CPU：</p>
<ol>
  <li>从指定内存地址读取 4 字节</li>
  <li>低 2 字节作为新 IP</li>
  <li>高 2 字节作为新 CS</li>
  <li>跳转到 CS:IP</li>
</ol>

<hr />

<h2 id="练习思考">练习思考</h2>

<ol>
  <li>
    <p>如果 ELF 入口地址是 0x00030000（超出 0x2000 段的范围），会发生什么？</p>
  </li>
  <li>
    <p>为什么不直接 <code class="language-plaintext highlighter-rouge">jmp $0x20000</code> 跳转到内核开头？（提示：ELF 文件的开头是什么？）</p>
  </li>
  <li>
    <p>如果要支持入口地址在任意位置，需要如何修改代码？</p>
  </li>
  <li>
    <p>代码复用技巧有什么潜在风险？</p>
  </li>
</ol>

<hr />

<h2 id="下一部分">下一部分</h2>

<p>接下来我们分析错误处理代码。请参阅下一篇文章。</p>
