<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="zh-CN" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Pintos Kernel 11 Paging Init" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Pintos 内核启动（十一）：永久页表建立 概述 本文档详细解析 Pintos 内核的 paging_init() 函数，该函数负责建立永久的页表结构，替换 start.S 中创建的临时页表。这是内核初始化过程中至关重要的一步，它建立了内核运行所需的完整地址映射。 在 start.S 中，我们创建了一个简单的临时页表，只映射了前 64MB 的物理内存。现在，paging_init() 将创建一个完整的页表，映射所有检测到的物理内存，并正确设置页面保护属性。 原始代码 init.c 中的 paging_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** Populates the base page directory and page table with the kernel virtual mapping, and then sets up the CPU to use the new page directory. Points init_page_dir to the page directory it creates. */ static void paging_init (void) { uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); pt = NULL; for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; char *vaddr = ptov (paddr); size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); } /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); } pte.h 中的辅助函数和宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** Virtual addresses are structured as follows: 31 22 21 12 11 0 +----------------------+----------------------+----------------------+ | Page Directory Index | Page Table Index | Page Offset | +----------------------+----------------------+----------------------+ */ /** Page table index (bits 12:21). */ #define PTSHIFT PGBITS /* First page table bit. */ #define PTBITS 10 /* Number of page table bits. */ /** Page directory index (bits 22:31). */ #define PDSHIFT (PTSHIFT + PTBITS) /* First page directory bit. */ #define PDBITS 10 /* Number of page dir bits. */ /** Obtains page table index from a virtual address. */ static inline unsigned pt_no (const void *va) { return ((uintptr_t) va &amp; PTMASK) &gt;&gt; PTSHIFT; } /** Obtains page directory index from a virtual address. */ static inline uintptr_t pd_no (const void *va) { return (uintptr_t) va &gt;&gt; PDSHIFT; } /** Page entry flags. */ #define PTE_P 0x1 /* 1=present, 0=not present. */ #define PTE_W 0x2 /* 1=read/write, 0=read-only. */ #define PTE_U 0x4 /* 1=user/kernel, 0=kernel only. */ /** Returns a PDE that points to page table PT. */ static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); return vtop (pt) | PTE_U | PTE_P | PTE_W; } /** Returns a PTE that points to PAGE. The PTE&#39;s page is readable. If WRITABLE is true then it will be writable as well. The page will be usable only by ring 0 code (the kernel). */ static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); return vtop (page) | PTE_P | (writable ? PTE_W : 0); } 前置知识 1. x86 两级页表结构 x86 保护模式使用两级页表进行地址转换： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 32位虚拟地址 ┌──────────────┬──────────────┬──────────────┐ │ PD Index │ PT Index │ Offset │ │ (10 bits) │ (10 bits) │ (12 bits) │ └──────┬───────┴──────┬───────┴──────┬───────┘ │ │ │ │ ┌──────────┘ │ │ │ │ ↓ │ ↓ ┌───────┴──────┐ ┌─────────┐ │ Page Dir │ ┌─────→ │ Physical│ │ (1024项) │ │ │ Page │ │ ┌─────────┐ │ │ │ (4KB) │ CR3→│ PDE 0 │ │ │ └────┬────┘ │ ├─────────┤ │ │ │ │ │ ... │ │ │ │ │ ├─────────┤ │ │ ↓ │ │PDE[idx] │──┼───┤ ┌─────────┐ │ ├─────────┤ │ │ │ 物理地址 │ │ │ ... │ │ │ └─────────┘ │ └─────────┘ │ │ └──────────────┘ │ │ ┌──────────────┐ │ │ Page Table │◄──┘ │ (1024项) │ │ ┌─────────┐ │ │ │ PTE 0 │ │ │ ├─────────┤ │ │ │ ... │ │ │ ├─────────┤ │ │ │PTE[idx] │──────────────────→ 物理页帧 │ ├─────────┤ │ │ │ ... │ │ │ └─────────┘ │ └──────────────┘ 2. 页目录项（PDE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Page Table Physical Address | AVL |G|S|0|A|D|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- (reserved) | +---------------- Page Size (0=4KB) +------------------ Global 3. 页表项（PTE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Physical Page Address | AVL |G|0|D|A|C|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- Dirty | +---------------- (reserved) +------------------ Global 4. 临时页表 vs 永久页表 特性 临时页表 (start.S) 永久页表 (paging_init) 创建时机 进入保护模式前 内存系统初始化后 覆盖范围 固定 64MB 所有检测到的物理内存 位置 BSS 段静态分配 动态从内存池分配 代码保护 无 内核代码段只读 用途 启动过渡 长期运行 5. 链接器符号 链接器脚本（linker script）定义了一些特殊符号： _start：内核代码段起始地址 _end_kernel_text：内核代码段结束地址 这些符号用于区分代码段和数据段，以便正确设置页面保护。 逐行代码解析 第1-3行：变量声明和外部符号 1 2 3 uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; 详细解析： pd（Page Directory）： 类型：uint32_t *（指向32位整数的指针） 用途：指向页目录 页目录包含 1024 个 PDE（页目录项） pt（Page Table）： 类型：uint32_t * 用途：指向当前正在填充的页表 每个页表包含 1024 个 PTE（页表项） page： 循环变量，遍历所有物理页 外部符号： _start：内核代码起始位置 _end_kernel_text：内核代码结束位置 这些符号由链接器自动生成 第4行：分配页目录 1 pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); 详细解析： palloc_get_page 调用： PAL_ASSERT：分配失败时触发 PANIC PAL_ZERO：将页清零（所有 PDE 初始化为 0，即”不存在”） 双重赋值： pd：局部变量，方便后续访问 init_page_dir：全局变量，供其他模块使用 为什么需要清零？ PDE 值为 0 表示页表项”不存在” CPU 访问不存在的页会触发 Page Fault 确保未映射的地址不会被意外访问 页目录初始状态： 1 2 3 4 5 6 7 8 9 10 页目录 (4KB) ┌───────────────┐ pd[0] │ 0 │ (不存在) ├───────────────┤ pd[1] │ 0 │ (不存在) ├───────────────┤ │ ... │ ├───────────────┤ pd[1023] │ 0 │ (不存在) └───────────────┘ 第5行：初始化页表指针 1 pt = NULL; 详细解析： 初始化为 NULL，表示还没有分配任何页表 后续循环中会按需分配页表 第6-7行：遍历所有物理页 1 2 3 for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; 详细解析： 循环范围： 从物理页 0 开始 到 init_ram_pages - 1 结束 覆盖所有检测到的物理内存 物理地址计算： paddr = page * 4096 每次循环处理一个 4KB 物理页 示例：假设有 4MB 物理内存（1024 页） page = 0: paddr = 0x00000000 page = 1: paddr = 0x00001000 page = 255: paddr = 0x000FF000 page = 256: paddr = 0x00100000 (1MB) … 第8行：计算虚拟地址 1 char *vaddr = ptov (paddr); 详细解析： ptov(paddr) = paddr + PHYS_BASE = paddr + 0xC0000000 建立物理地址到虚拟地址的映射 映射示例： 物理地址 虚拟地址 0x00000000 0xC0000000 0x00001000 0xC0001000 0x00100000 0xC0100000 0x003FF000 0xC03FF000 第9-10行：提取页表索引 1 2 size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); 详细解析： pd_no (vaddr)： 提取虚拟地址的高 10 位（bits 22-31） 范围：0 - 1023 用于索引页目录 pt_no (vaddr)： 提取虚拟地址的中间 10 位（bits 12-21） 范围：0 - 1023 用于索引页表 地址分解示例： 1 2 3 4 5 6 7 8 9 10 虚拟地址 0xC0001000 (对应物理地址 0x00001000) 二进制: 1100 0000 0000 0000 0001 0000 0000 0000 ├────────┬─┤├────────┬─┤├────────┬───┤ PD Index PT Index Offset 768 1 0 pde_idx = 768 (0x300) pte_idx = 1 offset = 0 第11行：判断是否为内核代码段 1 bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; 详细解析： 判断条件： 检查当前虚拟地址是否在内核代码段范围内 _start：内核代码起始 _end_kernel_text：内核代码结束 为什么需要区分？ 代码段应该是只读的（不应被修改） 数据段需要是可写的 这是基本的内存保护机制 内核内存布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌─────────────────────┐ _start (约 0xC0020000) │ │ │ .text 段 │ ← 代码段（只读） │ (内核代码) │ │ │ ├─────────────────────┤ _end_kernel_text │ │ │ .rodata 段 │ ← 只读数据 │ │ ├─────────────────────┤ │ │ │ .data 段 │ ← 已初始化数据（可写） │ │ ├─────────────────────┤ │ │ │ .bss 段 │ ← 未初始化数据（可写） │ │ └─────────────────────┘ 第12-16行：按需分配页表 1 2 3 4 5 if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } 详细解析： 检查条件： pd[pde_idx] == 0 表示该页目录项尚未指向任何页表 需要分配一个新的页表 分配页表： palloc_get_page(PAL_ASSERT | PAL_ZERO) 获取一个清零的页作为页表 一个页表可以容纳 1024 个 PTE 创建 PDE： pde_create(pt) 构造页目录项 设置标志位：PTE_U PTE_P PTE_W pde_create 函数分析： 1 2 3 4 static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); // 确保页表页对齐 return vtop (pt) | PTE_U | PTE_P | PTE_W; } vtop(pt)：将页表的虚拟地址转换为物理地址 PTE_P：Present 位，表示页表存在 PTE_W：Writable 位，允许写入 PTE_U：User 位，允许用户态访问（这里设置是为了支持用户程序） PDE 格式： 1 2 3 4 5 6 7 8 9 31 12 11 0 +---------------------------------------+----------+ | Page Table Physical Address | Flags | +---------------------------------------+----------+ PTE_U = 0x4 PTE_W = 0x2 PTE_P = 0x1 结果: PDE = (pt 物理地址) | 0x7 第17行：创建页表项 1 pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); 详细解析： pte_create_kernel 调用： 第一个参数：虚拟地址（用于计算物理页地址） 第二个参数：是否可写 !in_kernel_text：如果在代码段内，不可写 代码段：writable = false 数据段：writable = true pte_create_kernel 函数分析： 1 2 3 4 static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); // 确保地址页对齐 return vtop (page) | PTE_P | (writable ? PTE_W : 0); } vtop(page)：将虚拟地址转换为物理地址 PTE_P：Present 位 条件设置 PTE_W：根据 writable 参数决定 注意：没有设置 PTE_U，所以这些页只能在内核态（Ring 0）访问。 PTE 格式示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 代码段页（只读）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000001 | +------------------------------+----------+ PTE_P = 1 PTE_W = 0 (只读) PTE_U = 0 (仅内核) 数据段页（可写）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000011 | +------------------------------+----------+ PTE_P = 1 PTE_W = 1 (可写) PTE_U = 0 (仅内核) 第18-22行：激活新页表 1 2 3 4 5 6 /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); 详细解析： 内联汇编语法： asm volatile：告诉编译器这是汇编代码，不要优化 &quot;movl %0, %%cr3&quot;：将操作数 0 移动到 CR3 寄存器 : :：无输出操作数 &quot;r&quot; (vtop (init_page_dir))：输入操作数，使用任意通用寄存器 CR3 寄存器： 也称为 PDBR（Page Directory Base Register） 存储页目录的物理地址 修改 CR3 会导致 TLB（Translation Lookaside Buffer）刷新 地址转换： init_page_dir 是虚拟地址 vtop() 将其转换为物理地址 CPU 需要物理地址来定位页目录 为什么使用 volatile？ 防止编译器优化掉这条指令 确保页表切换立即发生 这是一个有副作用的操作（改变内存映射） 页表切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 切换前 (临时页表) ┌─────────────────────┐ │ 旧页目录 (BSS) │ CR3 ─────→ 位于 init.c │ └─────────────────────┘ ↓ movl %0, %%cr3 ↓ 切换后 (永久页表) ┌─────────────────────┐ │ 新页目录 (动态分配) │ CR3 ─────→ 位于内核池 │ └─────────────────────┘ 完整地址转换示例 假设访问虚拟地址 0xC0123456： 步骤1：分解虚拟地址 1 2 3 4 5 0xC0123456 = 1100 0000 0001 0010 0011 0100 0101 0110 PD Index = 1100 0000 01 = 769 (0x301) PT Index = 00 0010 0011 = 35 (0x23) Offset = 0100 0101 0110 = 0x456 步骤2：查找页目录 1 2 PDE = pd[769] = 页表的物理地址 | PTE_U | PTE_P | PTE_W 步骤3：查找页表 1 2 3 pt = PDE &amp; 0xFFFFF000 (提取页表物理地址) PTE = pt[35] = 物理页的地址 | PTE_P | (PTE_W) 步骤4：计算物理地址 1 2 3 4 物理页帧 = PTE &amp; 0xFFFFF000 物理地址 = 物理页帧 + 0x456 = 0x00123000 + 0x456 = 0x00123456 完整转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 虚拟地址: 0xC0123456 │ ↓ ┌─────────────────────────────────────────────────────┐ │ │ │ ┌──────────────┐ │ │ │ CR3 │──────────┐ │ │ └──────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────┐ │ │ │ Page Directory │ │ │ │ ┌───────────────────────────┐ │ │ │ │ │ pd[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pd[769] ─────────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pd[1023] │ │ │ │ │ │ └───────────────────────────┘ │ │ │ │ └─────────────────────────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────────────┐ │ │ │ Page Table │ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ pt[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pt[35] = 0x00123003 ─────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pt[1023] │ │ │ │ │ │ └───────────────────────────────────┘ │ │ │ │ └─────────────────────────────────────────┘ │ │ │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ │ Physical Page │◄──┘ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ offset 0x000 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0x456 ◄── 目标数据 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0xFFF │ │ │ │ │ └───────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ │ │ └─────────────────────────────────────────────────────┘ │ ↓ 物理地址: 0x00123456 页表覆盖范围分析 内核地址空间布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 虚拟地址空间 (4GB) ┌───────────────────────────────────┐ 0xFFFFFFFF │ │ │ 内核空间 (1GB) │ │ │ │ ┌───────────────────────────┐ │ │ │ 物理内存直接映射 │ │ │ │ 0xC0000000 → 物理 0x0 │ │ │ │ 0xC0001000 → 物理 0x1000 │ │ │ │ ... │ │ │ │ 0xC0000000+RAM → 物理 RAM │ │ │ └───────────────────────────┘ │ │ │ ├───────────────────────────────────┤ 0xC0000000 (PHYS_BASE) │ │ │ │ │ 用户空间 (3GB) │ │ (未映射) │ │ │ │ │ └───────────────────────────────────┘ 0x00000000 需要的页表数量 假设物理内存为 N MB： 每个页表覆盖：4MB（1024 × 4KB） 需要的页表数：⌈N MB / 4 MB⌉ 示例： 物理内存 页目录索引范围 需要的页表数 4 MB 768 1 8 MB 768-769 2 64 MB 768-783 16 256 MB 768-831 64 页表索引计算 对于内核映射（从 PHYS_BASE 开始）： 1 2 3 PHYS_BASE = 0xC0000000 PD Index = 0xC0000000 &gt;&gt; 22 = 768 (0x300) 所以内核映射从页目录的第 768 项开始。 与临时页表的对比 临时页表（start.S） # 临时页表：固定映射 64MB .align PGSIZE init_page_dir: .long 0x00000087 # PDE[0]: 映射 0-4MB .fill 767, 4, 0 # PDE[1-767]: 空 .long 0x00000087 # PDE[768]: 映射 0-4MB 到 0xC0000000-0xC03FFFFF # ... 更多固定 PDE 永久页表（paging_init） 1 2 3 4 5 // 动态映射所有检测到的内存 for (page = 0; page &lt; init_ram_pages; page++) { // 按需分配页表 // 正确设置代码段保护 } 主要区别： 特性 临时页表 永久页表 大小 固定 64MB 动态（检测到的内存） 分配方式 静态（BSS） 动态（palloc） 代码保护 无 代码段只读 页表数量 固定 16 个 按需分配 恒等映射 有（方便切换） 无（不再需要） TLB 刷新 修改 CR3 会自动刷新整个 TLB： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 写入 CR3 前: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ VA 0xC0001000 → PA 0x1000│ │ 旧的缓存项 │ │ VA 0xC0002000 → PA 0x2000│ │ │ │ ... │ │ │ └─────────────────────────┘ │ └─────────────────────────────────┘ 写入 CR3 后: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ (空) │ │ 所有条目被清除 │ └─────────────────────────┘ │ └─────────────────────────────────┘ 后续访问会重新填充 TLB 常见问题解答 Q1: 为什么页目录项设置了 PTE_U（用户位）？ A: 虽然内核映射只在内核态使用，但 PDE 的 PTE_U 位需要设置为 1，原因是： 用户程序的页表也会使用同一个页目录 如果 PDE 设置 PTE_U=0，即使 PTE 设置 PTE_U=1，用户程序也无法访问 实际的访问控制由 PTE 的 PTE_U 位决定 Q2: 为什么代码段设置为只读？ A: 安全性：防止恶意或错误代码修改内核指令 调试：写入代码段会触发 Page Fault，便于发现 bug 稳定性：防止缓冲区溢出覆盖代码 Q3: 切换页表时会不会导致问题？ A: 不会，因为： 新旧页表对内核地址的映射完全相同 CPU 当前执行的代码在切换前后都能正确访问 栈和数据也都被正确映射 Q4: 如果物理内存很大，页表会占用多少内存？ A: 页目录：1 页 = 4KB 每 4MB 物理内存需要 1 个页表 = 4KB 例如 256MB 内存：1 + 64 = 65 页 = 260KB 这是相当高效的：260KB 管理 256MB，开销约 0.1% 练习题 练习1：地址分解 给定虚拟地址 0xC0BADCAFE（假设有足够内存），计算： 页目录索引（PD Index） 页表索引（PT Index） 页内偏移（Offset） 对应的物理地址 练习2：页表数量估算 如果系统有 512MB 物理内存： 需要多少个页表？ 页目录和所有页表共占用多少内存？ 练习3：代码保护验证 修改 paging_init，使数据段也变为只读： 预测会发生什么？ 如何安全地测试这个修改？ 练习4：添加恒等映射 如果需要在永久页表中保留低地址的恒等映射（物理地址 = 虚拟地址），需要如何修改 paging_init？ 提示：考虑需要额外映射哪些地址，以及何时可以安全移除这些映射。 下一篇预告 在下一篇文档中，我们将详细解析线程系统的初始化 thread_init()，了解 Pintos 如何设置主线程和调度器基础设施。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide - Chapter 4: Paging Pintos Reference Guide - Virtual Memory OSDev Wiki - Paging" />
<meta property="og:description" content="Pintos 内核启动（十一）：永久页表建立 概述 本文档详细解析 Pintos 内核的 paging_init() 函数，该函数负责建立永久的页表结构，替换 start.S 中创建的临时页表。这是内核初始化过程中至关重要的一步，它建立了内核运行所需的完整地址映射。 在 start.S 中，我们创建了一个简单的临时页表，只映射了前 64MB 的物理内存。现在，paging_init() 将创建一个完整的页表，映射所有检测到的物理内存，并正确设置页面保护属性。 原始代码 init.c 中的 paging_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** Populates the base page directory and page table with the kernel virtual mapping, and then sets up the CPU to use the new page directory. Points init_page_dir to the page directory it creates. */ static void paging_init (void) { uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); pt = NULL; for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; char *vaddr = ptov (paddr); size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); } /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); } pte.h 中的辅助函数和宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** Virtual addresses are structured as follows: 31 22 21 12 11 0 +----------------------+----------------------+----------------------+ | Page Directory Index | Page Table Index | Page Offset | +----------------------+----------------------+----------------------+ */ /** Page table index (bits 12:21). */ #define PTSHIFT PGBITS /* First page table bit. */ #define PTBITS 10 /* Number of page table bits. */ /** Page directory index (bits 22:31). */ #define PDSHIFT (PTSHIFT + PTBITS) /* First page directory bit. */ #define PDBITS 10 /* Number of page dir bits. */ /** Obtains page table index from a virtual address. */ static inline unsigned pt_no (const void *va) { return ((uintptr_t) va &amp; PTMASK) &gt;&gt; PTSHIFT; } /** Obtains page directory index from a virtual address. */ static inline uintptr_t pd_no (const void *va) { return (uintptr_t) va &gt;&gt; PDSHIFT; } /** Page entry flags. */ #define PTE_P 0x1 /* 1=present, 0=not present. */ #define PTE_W 0x2 /* 1=read/write, 0=read-only. */ #define PTE_U 0x4 /* 1=user/kernel, 0=kernel only. */ /** Returns a PDE that points to page table PT. */ static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); return vtop (pt) | PTE_U | PTE_P | PTE_W; } /** Returns a PTE that points to PAGE. The PTE&#39;s page is readable. If WRITABLE is true then it will be writable as well. The page will be usable only by ring 0 code (the kernel). */ static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); return vtop (page) | PTE_P | (writable ? PTE_W : 0); } 前置知识 1. x86 两级页表结构 x86 保护模式使用两级页表进行地址转换： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 32位虚拟地址 ┌──────────────┬──────────────┬──────────────┐ │ PD Index │ PT Index │ Offset │ │ (10 bits) │ (10 bits) │ (12 bits) │ └──────┬───────┴──────┬───────┴──────┬───────┘ │ │ │ │ ┌──────────┘ │ │ │ │ ↓ │ ↓ ┌───────┴──────┐ ┌─────────┐ │ Page Dir │ ┌─────→ │ Physical│ │ (1024项) │ │ │ Page │ │ ┌─────────┐ │ │ │ (4KB) │ CR3→│ PDE 0 │ │ │ └────┬────┘ │ ├─────────┤ │ │ │ │ │ ... │ │ │ │ │ ├─────────┤ │ │ ↓ │ │PDE[idx] │──┼───┤ ┌─────────┐ │ ├─────────┤ │ │ │ 物理地址 │ │ │ ... │ │ │ └─────────┘ │ └─────────┘ │ │ └──────────────┘ │ │ ┌──────────────┐ │ │ Page Table │◄──┘ │ (1024项) │ │ ┌─────────┐ │ │ │ PTE 0 │ │ │ ├─────────┤ │ │ │ ... │ │ │ ├─────────┤ │ │ │PTE[idx] │──────────────────→ 物理页帧 │ ├─────────┤ │ │ │ ... │ │ │ └─────────┘ │ └──────────────┘ 2. 页目录项（PDE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Page Table Physical Address | AVL |G|S|0|A|D|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- (reserved) | +---------------- Page Size (0=4KB) +------------------ Global 3. 页表项（PTE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Physical Page Address | AVL |G|0|D|A|C|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- Dirty | +---------------- (reserved) +------------------ Global 4. 临时页表 vs 永久页表 特性 临时页表 (start.S) 永久页表 (paging_init) 创建时机 进入保护模式前 内存系统初始化后 覆盖范围 固定 64MB 所有检测到的物理内存 位置 BSS 段静态分配 动态从内存池分配 代码保护 无 内核代码段只读 用途 启动过渡 长期运行 5. 链接器符号 链接器脚本（linker script）定义了一些特殊符号： _start：内核代码段起始地址 _end_kernel_text：内核代码段结束地址 这些符号用于区分代码段和数据段，以便正确设置页面保护。 逐行代码解析 第1-3行：变量声明和外部符号 1 2 3 uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; 详细解析： pd（Page Directory）： 类型：uint32_t *（指向32位整数的指针） 用途：指向页目录 页目录包含 1024 个 PDE（页目录项） pt（Page Table）： 类型：uint32_t * 用途：指向当前正在填充的页表 每个页表包含 1024 个 PTE（页表项） page： 循环变量，遍历所有物理页 外部符号： _start：内核代码起始位置 _end_kernel_text：内核代码结束位置 这些符号由链接器自动生成 第4行：分配页目录 1 pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); 详细解析： palloc_get_page 调用： PAL_ASSERT：分配失败时触发 PANIC PAL_ZERO：将页清零（所有 PDE 初始化为 0，即”不存在”） 双重赋值： pd：局部变量，方便后续访问 init_page_dir：全局变量，供其他模块使用 为什么需要清零？ PDE 值为 0 表示页表项”不存在” CPU 访问不存在的页会触发 Page Fault 确保未映射的地址不会被意外访问 页目录初始状态： 1 2 3 4 5 6 7 8 9 10 页目录 (4KB) ┌───────────────┐ pd[0] │ 0 │ (不存在) ├───────────────┤ pd[1] │ 0 │ (不存在) ├───────────────┤ │ ... │ ├───────────────┤ pd[1023] │ 0 │ (不存在) └───────────────┘ 第5行：初始化页表指针 1 pt = NULL; 详细解析： 初始化为 NULL，表示还没有分配任何页表 后续循环中会按需分配页表 第6-7行：遍历所有物理页 1 2 3 for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; 详细解析： 循环范围： 从物理页 0 开始 到 init_ram_pages - 1 结束 覆盖所有检测到的物理内存 物理地址计算： paddr = page * 4096 每次循环处理一个 4KB 物理页 示例：假设有 4MB 物理内存（1024 页） page = 0: paddr = 0x00000000 page = 1: paddr = 0x00001000 page = 255: paddr = 0x000FF000 page = 256: paddr = 0x00100000 (1MB) … 第8行：计算虚拟地址 1 char *vaddr = ptov (paddr); 详细解析： ptov(paddr) = paddr + PHYS_BASE = paddr + 0xC0000000 建立物理地址到虚拟地址的映射 映射示例： 物理地址 虚拟地址 0x00000000 0xC0000000 0x00001000 0xC0001000 0x00100000 0xC0100000 0x003FF000 0xC03FF000 第9-10行：提取页表索引 1 2 size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); 详细解析： pd_no (vaddr)： 提取虚拟地址的高 10 位（bits 22-31） 范围：0 - 1023 用于索引页目录 pt_no (vaddr)： 提取虚拟地址的中间 10 位（bits 12-21） 范围：0 - 1023 用于索引页表 地址分解示例： 1 2 3 4 5 6 7 8 9 10 虚拟地址 0xC0001000 (对应物理地址 0x00001000) 二进制: 1100 0000 0000 0000 0001 0000 0000 0000 ├────────┬─┤├────────┬─┤├────────┬───┤ PD Index PT Index Offset 768 1 0 pde_idx = 768 (0x300) pte_idx = 1 offset = 0 第11行：判断是否为内核代码段 1 bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; 详细解析： 判断条件： 检查当前虚拟地址是否在内核代码段范围内 _start：内核代码起始 _end_kernel_text：内核代码结束 为什么需要区分？ 代码段应该是只读的（不应被修改） 数据段需要是可写的 这是基本的内存保护机制 内核内存布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌─────────────────────┐ _start (约 0xC0020000) │ │ │ .text 段 │ ← 代码段（只读） │ (内核代码) │ │ │ ├─────────────────────┤ _end_kernel_text │ │ │ .rodata 段 │ ← 只读数据 │ │ ├─────────────────────┤ │ │ │ .data 段 │ ← 已初始化数据（可写） │ │ ├─────────────────────┤ │ │ │ .bss 段 │ ← 未初始化数据（可写） │ │ └─────────────────────┘ 第12-16行：按需分配页表 1 2 3 4 5 if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } 详细解析： 检查条件： pd[pde_idx] == 0 表示该页目录项尚未指向任何页表 需要分配一个新的页表 分配页表： palloc_get_page(PAL_ASSERT | PAL_ZERO) 获取一个清零的页作为页表 一个页表可以容纳 1024 个 PTE 创建 PDE： pde_create(pt) 构造页目录项 设置标志位：PTE_U PTE_P PTE_W pde_create 函数分析： 1 2 3 4 static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); // 确保页表页对齐 return vtop (pt) | PTE_U | PTE_P | PTE_W; } vtop(pt)：将页表的虚拟地址转换为物理地址 PTE_P：Present 位，表示页表存在 PTE_W：Writable 位，允许写入 PTE_U：User 位，允许用户态访问（这里设置是为了支持用户程序） PDE 格式： 1 2 3 4 5 6 7 8 9 31 12 11 0 +---------------------------------------+----------+ | Page Table Physical Address | Flags | +---------------------------------------+----------+ PTE_U = 0x4 PTE_W = 0x2 PTE_P = 0x1 结果: PDE = (pt 物理地址) | 0x7 第17行：创建页表项 1 pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); 详细解析： pte_create_kernel 调用： 第一个参数：虚拟地址（用于计算物理页地址） 第二个参数：是否可写 !in_kernel_text：如果在代码段内，不可写 代码段：writable = false 数据段：writable = true pte_create_kernel 函数分析： 1 2 3 4 static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); // 确保地址页对齐 return vtop (page) | PTE_P | (writable ? PTE_W : 0); } vtop(page)：将虚拟地址转换为物理地址 PTE_P：Present 位 条件设置 PTE_W：根据 writable 参数决定 注意：没有设置 PTE_U，所以这些页只能在内核态（Ring 0）访问。 PTE 格式示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 代码段页（只读）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000001 | +------------------------------+----------+ PTE_P = 1 PTE_W = 0 (只读) PTE_U = 0 (仅内核) 数据段页（可写）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000011 | +------------------------------+----------+ PTE_P = 1 PTE_W = 1 (可写) PTE_U = 0 (仅内核) 第18-22行：激活新页表 1 2 3 4 5 6 /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); 详细解析： 内联汇编语法： asm volatile：告诉编译器这是汇编代码，不要优化 &quot;movl %0, %%cr3&quot;：将操作数 0 移动到 CR3 寄存器 : :：无输出操作数 &quot;r&quot; (vtop (init_page_dir))：输入操作数，使用任意通用寄存器 CR3 寄存器： 也称为 PDBR（Page Directory Base Register） 存储页目录的物理地址 修改 CR3 会导致 TLB（Translation Lookaside Buffer）刷新 地址转换： init_page_dir 是虚拟地址 vtop() 将其转换为物理地址 CPU 需要物理地址来定位页目录 为什么使用 volatile？ 防止编译器优化掉这条指令 确保页表切换立即发生 这是一个有副作用的操作（改变内存映射） 页表切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 切换前 (临时页表) ┌─────────────────────┐ │ 旧页目录 (BSS) │ CR3 ─────→ 位于 init.c │ └─────────────────────┘ ↓ movl %0, %%cr3 ↓ 切换后 (永久页表) ┌─────────────────────┐ │ 新页目录 (动态分配) │ CR3 ─────→ 位于内核池 │ └─────────────────────┘ 完整地址转换示例 假设访问虚拟地址 0xC0123456： 步骤1：分解虚拟地址 1 2 3 4 5 0xC0123456 = 1100 0000 0001 0010 0011 0100 0101 0110 PD Index = 1100 0000 01 = 769 (0x301) PT Index = 00 0010 0011 = 35 (0x23) Offset = 0100 0101 0110 = 0x456 步骤2：查找页目录 1 2 PDE = pd[769] = 页表的物理地址 | PTE_U | PTE_P | PTE_W 步骤3：查找页表 1 2 3 pt = PDE &amp; 0xFFFFF000 (提取页表物理地址) PTE = pt[35] = 物理页的地址 | PTE_P | (PTE_W) 步骤4：计算物理地址 1 2 3 4 物理页帧 = PTE &amp; 0xFFFFF000 物理地址 = 物理页帧 + 0x456 = 0x00123000 + 0x456 = 0x00123456 完整转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 虚拟地址: 0xC0123456 │ ↓ ┌─────────────────────────────────────────────────────┐ │ │ │ ┌──────────────┐ │ │ │ CR3 │──────────┐ │ │ └──────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────┐ │ │ │ Page Directory │ │ │ │ ┌───────────────────────────┐ │ │ │ │ │ pd[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pd[769] ─────────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pd[1023] │ │ │ │ │ │ └───────────────────────────┘ │ │ │ │ └─────────────────────────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────────────┐ │ │ │ Page Table │ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ pt[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pt[35] = 0x00123003 ─────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pt[1023] │ │ │ │ │ │ └───────────────────────────────────┘ │ │ │ │ └─────────────────────────────────────────┘ │ │ │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ │ Physical Page │◄──┘ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ offset 0x000 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0x456 ◄── 目标数据 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0xFFF │ │ │ │ │ └───────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ │ │ └─────────────────────────────────────────────────────┘ │ ↓ 物理地址: 0x00123456 页表覆盖范围分析 内核地址空间布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 虚拟地址空间 (4GB) ┌───────────────────────────────────┐ 0xFFFFFFFF │ │ │ 内核空间 (1GB) │ │ │ │ ┌───────────────────────────┐ │ │ │ 物理内存直接映射 │ │ │ │ 0xC0000000 → 物理 0x0 │ │ │ │ 0xC0001000 → 物理 0x1000 │ │ │ │ ... │ │ │ │ 0xC0000000+RAM → 物理 RAM │ │ │ └───────────────────────────┘ │ │ │ ├───────────────────────────────────┤ 0xC0000000 (PHYS_BASE) │ │ │ │ │ 用户空间 (3GB) │ │ (未映射) │ │ │ │ │ └───────────────────────────────────┘ 0x00000000 需要的页表数量 假设物理内存为 N MB： 每个页表覆盖：4MB（1024 × 4KB） 需要的页表数：⌈N MB / 4 MB⌉ 示例： 物理内存 页目录索引范围 需要的页表数 4 MB 768 1 8 MB 768-769 2 64 MB 768-783 16 256 MB 768-831 64 页表索引计算 对于内核映射（从 PHYS_BASE 开始）： 1 2 3 PHYS_BASE = 0xC0000000 PD Index = 0xC0000000 &gt;&gt; 22 = 768 (0x300) 所以内核映射从页目录的第 768 项开始。 与临时页表的对比 临时页表（start.S） # 临时页表：固定映射 64MB .align PGSIZE init_page_dir: .long 0x00000087 # PDE[0]: 映射 0-4MB .fill 767, 4, 0 # PDE[1-767]: 空 .long 0x00000087 # PDE[768]: 映射 0-4MB 到 0xC0000000-0xC03FFFFF # ... 更多固定 PDE 永久页表（paging_init） 1 2 3 4 5 // 动态映射所有检测到的内存 for (page = 0; page &lt; init_ram_pages; page++) { // 按需分配页表 // 正确设置代码段保护 } 主要区别： 特性 临时页表 永久页表 大小 固定 64MB 动态（检测到的内存） 分配方式 静态（BSS） 动态（palloc） 代码保护 无 代码段只读 页表数量 固定 16 个 按需分配 恒等映射 有（方便切换） 无（不再需要） TLB 刷新 修改 CR3 会自动刷新整个 TLB： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 写入 CR3 前: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ VA 0xC0001000 → PA 0x1000│ │ 旧的缓存项 │ │ VA 0xC0002000 → PA 0x2000│ │ │ │ ... │ │ │ └─────────────────────────┘ │ └─────────────────────────────────┘ 写入 CR3 后: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ (空) │ │ 所有条目被清除 │ └─────────────────────────┘ │ └─────────────────────────────────┘ 后续访问会重新填充 TLB 常见问题解答 Q1: 为什么页目录项设置了 PTE_U（用户位）？ A: 虽然内核映射只在内核态使用，但 PDE 的 PTE_U 位需要设置为 1，原因是： 用户程序的页表也会使用同一个页目录 如果 PDE 设置 PTE_U=0，即使 PTE 设置 PTE_U=1，用户程序也无法访问 实际的访问控制由 PTE 的 PTE_U 位决定 Q2: 为什么代码段设置为只读？ A: 安全性：防止恶意或错误代码修改内核指令 调试：写入代码段会触发 Page Fault，便于发现 bug 稳定性：防止缓冲区溢出覆盖代码 Q3: 切换页表时会不会导致问题？ A: 不会，因为： 新旧页表对内核地址的映射完全相同 CPU 当前执行的代码在切换前后都能正确访问 栈和数据也都被正确映射 Q4: 如果物理内存很大，页表会占用多少内存？ A: 页目录：1 页 = 4KB 每 4MB 物理内存需要 1 个页表 = 4KB 例如 256MB 内存：1 + 64 = 65 页 = 260KB 这是相当高效的：260KB 管理 256MB，开销约 0.1% 练习题 练习1：地址分解 给定虚拟地址 0xC0BADCAFE（假设有足够内存），计算： 页目录索引（PD Index） 页表索引（PT Index） 页内偏移（Offset） 对应的物理地址 练习2：页表数量估算 如果系统有 512MB 物理内存： 需要多少个页表？ 页目录和所有页表共占用多少内存？ 练习3：代码保护验证 修改 paging_init，使数据段也变为只读： 预测会发生什么？ 如何安全地测试这个修改？ 练习4：添加恒等映射 如果需要在永久页表中保留低地址的恒等映射（物理地址 = 虚拟地址），需要如何修改 paging_init？ 提示：考虑需要额外映射哪些地址，以及何时可以安全移除这些映射。 下一篇预告 在下一篇文档中，我们将详细解析线程系统的初始化 thread_init()，了解 Pintos 如何设置主线程和调度器基础设施。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide - Chapter 4: Paging Pintos Reference Guide - Virtual Memory OSDev Wiki - Paging" />
<link rel="canonical" href="http://localhost:4000/posts/pintos-kernel-11-paging-init/" />
<meta property="og:url" content="http://localhost:4000/posts/pintos-kernel-11-paging-init/" />
<meta property="og:site_name" content="Zxsheather" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-01-22T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pintos Kernel 11 Paging Init" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-22T00:00:00+08:00","datePublished":"2026-01-22T00:00:00+08:00","description":"Pintos 内核启动（十一）：永久页表建立 概述 本文档详细解析 Pintos 内核的 paging_init() 函数，该函数负责建立永久的页表结构，替换 start.S 中创建的临时页表。这是内核初始化过程中至关重要的一步，它建立了内核运行所需的完整地址映射。 在 start.S 中，我们创建了一个简单的临时页表，只映射了前 64MB 的物理内存。现在，paging_init() 将创建一个完整的页表，映射所有检测到的物理内存，并正确设置页面保护属性。 原始代码 init.c 中的 paging_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** Populates the base page directory and page table with the kernel virtual mapping, and then sets up the CPU to use the new page directory. Points init_page_dir to the page directory it creates. */ static void paging_init (void) { uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); pt = NULL; for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; char *vaddr = ptov (paddr); size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); } /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); } pte.h 中的辅助函数和宏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** Virtual addresses are structured as follows: 31 22 21 12 11 0 +----------------------+----------------------+----------------------+ | Page Directory Index | Page Table Index | Page Offset | +----------------------+----------------------+----------------------+ */ /** Page table index (bits 12:21). */ #define PTSHIFT PGBITS /* First page table bit. */ #define PTBITS 10 /* Number of page table bits. */ /** Page directory index (bits 22:31). */ #define PDSHIFT (PTSHIFT + PTBITS) /* First page directory bit. */ #define PDBITS 10 /* Number of page dir bits. */ /** Obtains page table index from a virtual address. */ static inline unsigned pt_no (const void *va) { return ((uintptr_t) va &amp; PTMASK) &gt;&gt; PTSHIFT; } /** Obtains page directory index from a virtual address. */ static inline uintptr_t pd_no (const void *va) { return (uintptr_t) va &gt;&gt; PDSHIFT; } /** Page entry flags. */ #define PTE_P 0x1 /* 1=present, 0=not present. */ #define PTE_W 0x2 /* 1=read/write, 0=read-only. */ #define PTE_U 0x4 /* 1=user/kernel, 0=kernel only. */ /** Returns a PDE that points to page table PT. */ static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); return vtop (pt) | PTE_U | PTE_P | PTE_W; } /** Returns a PTE that points to PAGE. The PTE&#39;s page is readable. If WRITABLE is true then it will be writable as well. The page will be usable only by ring 0 code (the kernel). */ static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); return vtop (page) | PTE_P | (writable ? PTE_W : 0); } 前置知识 1. x86 两级页表结构 x86 保护模式使用两级页表进行地址转换： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 32位虚拟地址 ┌──────────────┬──────────────┬──────────────┐ │ PD Index │ PT Index │ Offset │ │ (10 bits) │ (10 bits) │ (12 bits) │ └──────┬───────┴──────┬───────┴──────┬───────┘ │ │ │ │ ┌──────────┘ │ │ │ │ ↓ │ ↓ ┌───────┴──────┐ ┌─────────┐ │ Page Dir │ ┌─────→ │ Physical│ │ (1024项) │ │ │ Page │ │ ┌─────────┐ │ │ │ (4KB) │ CR3→│ PDE 0 │ │ │ └────┬────┘ │ ├─────────┤ │ │ │ │ │ ... │ │ │ │ │ ├─────────┤ │ │ ↓ │ │PDE[idx] │──┼───┤ ┌─────────┐ │ ├─────────┤ │ │ │ 物理地址 │ │ │ ... │ │ │ └─────────┘ │ └─────────┘ │ │ └──────────────┘ │ │ ┌──────────────┐ │ │ Page Table │◄──┘ │ (1024项) │ │ ┌─────────┐ │ │ │ PTE 0 │ │ │ ├─────────┤ │ │ │ ... │ │ │ ├─────────┤ │ │ │PTE[idx] │──────────────────→ 物理页帧 │ ├─────────┤ │ │ │ ... │ │ │ └─────────┘ │ └──────────────┘ 2. 页目录项（PDE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Page Table Physical Address | AVL |G|S|0|A|D|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- (reserved) | +---------------- Page Size (0=4KB) +------------------ Global 3. 页表项（PTE）格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 31 12 11 9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | Physical Page Address | AVL |G|0|D|A|C|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ | | | | | | | | | | | | | | | | | +-- Present | | | | | | | +---- Read/Write | | | | | | +------ User/Supervisor | | | | | +-------- Write-Through | | | | +---------- Cache Disable | | | +------------ Accessed | | +-------------- Dirty | +---------------- (reserved) +------------------ Global 4. 临时页表 vs 永久页表 特性 临时页表 (start.S) 永久页表 (paging_init) 创建时机 进入保护模式前 内存系统初始化后 覆盖范围 固定 64MB 所有检测到的物理内存 位置 BSS 段静态分配 动态从内存池分配 代码保护 无 内核代码段只读 用途 启动过渡 长期运行 5. 链接器符号 链接器脚本（linker script）定义了一些特殊符号： _start：内核代码段起始地址 _end_kernel_text：内核代码段结束地址 这些符号用于区分代码段和数据段，以便正确设置页面保护。 逐行代码解析 第1-3行：变量声明和外部符号 1 2 3 uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text; 详细解析： pd（Page Directory）： 类型：uint32_t *（指向32位整数的指针） 用途：指向页目录 页目录包含 1024 个 PDE（页目录项） pt（Page Table）： 类型：uint32_t * 用途：指向当前正在填充的页表 每个页表包含 1024 个 PTE（页表项） page： 循环变量，遍历所有物理页 外部符号： _start：内核代码起始位置 _end_kernel_text：内核代码结束位置 这些符号由链接器自动生成 第4行：分配页目录 1 pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO); 详细解析： palloc_get_page 调用： PAL_ASSERT：分配失败时触发 PANIC PAL_ZERO：将页清零（所有 PDE 初始化为 0，即”不存在”） 双重赋值： pd：局部变量，方便后续访问 init_page_dir：全局变量，供其他模块使用 为什么需要清零？ PDE 值为 0 表示页表项”不存在” CPU 访问不存在的页会触发 Page Fault 确保未映射的地址不会被意外访问 页目录初始状态： 1 2 3 4 5 6 7 8 9 10 页目录 (4KB) ┌───────────────┐ pd[0] │ 0 │ (不存在) ├───────────────┤ pd[1] │ 0 │ (不存在) ├───────────────┤ │ ... │ ├───────────────┤ pd[1023] │ 0 │ (不存在) └───────────────┘ 第5行：初始化页表指针 1 pt = NULL; 详细解析： 初始化为 NULL，表示还没有分配任何页表 后续循环中会按需分配页表 第6-7行：遍历所有物理页 1 2 3 for (page = 0; page &lt; init_ram_pages; page++) { uintptr_t paddr = page * PGSIZE; 详细解析： 循环范围： 从物理页 0 开始 到 init_ram_pages - 1 结束 覆盖所有检测到的物理内存 物理地址计算： paddr = page * 4096 每次循环处理一个 4KB 物理页 示例：假设有 4MB 物理内存（1024 页） page = 0: paddr = 0x00000000 page = 1: paddr = 0x00001000 page = 255: paddr = 0x000FF000 page = 256: paddr = 0x00100000 (1MB) … 第8行：计算虚拟地址 1 char *vaddr = ptov (paddr); 详细解析： ptov(paddr) = paddr + PHYS_BASE = paddr + 0xC0000000 建立物理地址到虚拟地址的映射 映射示例： 物理地址 虚拟地址 0x00000000 0xC0000000 0x00001000 0xC0001000 0x00100000 0xC0100000 0x003FF000 0xC03FF000 第9-10行：提取页表索引 1 2 size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr); 详细解析： pd_no (vaddr)： 提取虚拟地址的高 10 位（bits 22-31） 范围：0 - 1023 用于索引页目录 pt_no (vaddr)： 提取虚拟地址的中间 10 位（bits 12-21） 范围：0 - 1023 用于索引页表 地址分解示例： 1 2 3 4 5 6 7 8 9 10 虚拟地址 0xC0001000 (对应物理地址 0x00001000) 二进制: 1100 0000 0000 0000 0001 0000 0000 0000 ├────────┬─┤├────────┬─┤├────────┬───┤ PD Index PT Index Offset 768 1 0 pde_idx = 768 (0x300) pte_idx = 1 offset = 0 第11行：判断是否为内核代码段 1 bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text; 详细解析： 判断条件： 检查当前虚拟地址是否在内核代码段范围内 _start：内核代码起始 _end_kernel_text：内核代码结束 为什么需要区分？ 代码段应该是只读的（不应被修改） 数据段需要是可写的 这是基本的内存保护机制 内核内存布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌─────────────────────┐ _start (约 0xC0020000) │ │ │ .text 段 │ ← 代码段（只读） │ (内核代码) │ │ │ ├─────────────────────┤ _end_kernel_text │ │ │ .rodata 段 │ ← 只读数据 │ │ ├─────────────────────┤ │ │ │ .data 段 │ ← 已初始化数据（可写） │ │ ├─────────────────────┤ │ │ │ .bss 段 │ ← 未初始化数据（可写） │ │ └─────────────────────┘ 第12-16行：按需分配页表 1 2 3 4 5 if (pd[pde_idx] == 0) { pt = palloc_get_page (PAL_ASSERT | PAL_ZERO); pd[pde_idx] = pde_create (pt); } 详细解析： 检查条件： pd[pde_idx] == 0 表示该页目录项尚未指向任何页表 需要分配一个新的页表 分配页表： palloc_get_page(PAL_ASSERT | PAL_ZERO) 获取一个清零的页作为页表 一个页表可以容纳 1024 个 PTE 创建 PDE： pde_create(pt) 构造页目录项 设置标志位：PTE_U PTE_P PTE_W pde_create 函数分析： 1 2 3 4 static inline uint32_t pde_create (uint32_t *pt) { ASSERT (pg_ofs (pt) == 0); // 确保页表页对齐 return vtop (pt) | PTE_U | PTE_P | PTE_W; } vtop(pt)：将页表的虚拟地址转换为物理地址 PTE_P：Present 位，表示页表存在 PTE_W：Writable 位，允许写入 PTE_U：User 位，允许用户态访问（这里设置是为了支持用户程序） PDE 格式： 1 2 3 4 5 6 7 8 9 31 12 11 0 +---------------------------------------+----------+ | Page Table Physical Address | Flags | +---------------------------------------+----------+ PTE_U = 0x4 PTE_W = 0x2 PTE_P = 0x1 结果: PDE = (pt 物理地址) | 0x7 第17行：创建页表项 1 pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text); 详细解析： pte_create_kernel 调用： 第一个参数：虚拟地址（用于计算物理页地址） 第二个参数：是否可写 !in_kernel_text：如果在代码段内，不可写 代码段：writable = false 数据段：writable = true pte_create_kernel 函数分析： 1 2 3 4 static inline uint32_t pte_create_kernel (void *page, bool writable) { ASSERT (pg_ofs (page) == 0); // 确保地址页对齐 return vtop (page) | PTE_P | (writable ? PTE_W : 0); } vtop(page)：将虚拟地址转换为物理地址 PTE_P：Present 位 条件设置 PTE_W：根据 writable 参数决定 注意：没有设置 PTE_U，所以这些页只能在内核态（Ring 0）访问。 PTE 格式示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 代码段页（只读）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000001 | +------------------------------+----------+ PTE_P = 1 PTE_W = 0 (只读) PTE_U = 0 (仅内核) 数据段页（可写）： 31 12 11 0 +------------------------------+----------+ | Physical Page Address | 00000011 | +------------------------------+----------+ PTE_P = 1 PTE_W = 1 (可写) PTE_U = 0 (仅内核) 第18-22行：激活新页表 1 2 3 4 5 6 /* Store the physical address of the page directory into CR3 aka PDBR (page directory base register). This activates our new page tables immediately. See [IA32-v2a] &quot;MOV--Move to/from Control Registers&quot; and [IA32-v3a] 3.7.5 &quot;Base Address of the Page Directory&quot;. */ asm volatile (&quot;movl %0, %%cr3&quot; : : &quot;r&quot; (vtop (init_page_dir))); 详细解析： 内联汇编语法： asm volatile：告诉编译器这是汇编代码，不要优化 &quot;movl %0, %%cr3&quot;：将操作数 0 移动到 CR3 寄存器 : :：无输出操作数 &quot;r&quot; (vtop (init_page_dir))：输入操作数，使用任意通用寄存器 CR3 寄存器： 也称为 PDBR（Page Directory Base Register） 存储页目录的物理地址 修改 CR3 会导致 TLB（Translation Lookaside Buffer）刷新 地址转换： init_page_dir 是虚拟地址 vtop() 将其转换为物理地址 CPU 需要物理地址来定位页目录 为什么使用 volatile？ 防止编译器优化掉这条指令 确保页表切换立即发生 这是一个有副作用的操作（改变内存映射） 页表切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 切换前 (临时页表) ┌─────────────────────┐ │ 旧页目录 (BSS) │ CR3 ─────→ 位于 init.c │ └─────────────────────┘ ↓ movl %0, %%cr3 ↓ 切换后 (永久页表) ┌─────────────────────┐ │ 新页目录 (动态分配) │ CR3 ─────→ 位于内核池 │ └─────────────────────┘ 完整地址转换示例 假设访问虚拟地址 0xC0123456： 步骤1：分解虚拟地址 1 2 3 4 5 0xC0123456 = 1100 0000 0001 0010 0011 0100 0101 0110 PD Index = 1100 0000 01 = 769 (0x301) PT Index = 00 0010 0011 = 35 (0x23) Offset = 0100 0101 0110 = 0x456 步骤2：查找页目录 1 2 PDE = pd[769] = 页表的物理地址 | PTE_U | PTE_P | PTE_W 步骤3：查找页表 1 2 3 pt = PDE &amp; 0xFFFFF000 (提取页表物理地址) PTE = pt[35] = 物理页的地址 | PTE_P | (PTE_W) 步骤4：计算物理地址 1 2 3 4 物理页帧 = PTE &amp; 0xFFFFF000 物理地址 = 物理页帧 + 0x456 = 0x00123000 + 0x456 = 0x00123456 完整转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 虚拟地址: 0xC0123456 │ ↓ ┌─────────────────────────────────────────────────────┐ │ │ │ ┌──────────────┐ │ │ │ CR3 │──────────┐ │ │ └──────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────┐ │ │ │ Page Directory │ │ │ │ ┌───────────────────────────┐ │ │ │ │ │ pd[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pd[769] ─────────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pd[1023] │ │ │ │ │ │ └───────────────────────────┘ │ │ │ │ └─────────────────────────────────┘ │ │ │ ↓ │ │ ┌─────────────────────────────────────────┐ │ │ │ Page Table │ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ pt[0] │ │ │ │ │ │ ... │ │ │ │ │ │ pt[35] = 0x00123003 ─────────────────────┐ │ │ │ │ ... │ │ │ │ │ │ │ pt[1023] │ │ │ │ │ │ └───────────────────────────────────┘ │ │ │ │ └─────────────────────────────────────────┘ │ │ │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ │ Physical Page │◄──┘ │ │ │ ┌───────────────────────────────────┐ │ │ │ │ │ offset 0x000 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0x456 ◄── 目标数据 │ │ │ │ │ │ ... │ │ │ │ │ │ offset 0xFFF │ │ │ │ │ └───────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ │ │ └─────────────────────────────────────────────────────┘ │ ↓ 物理地址: 0x00123456 页表覆盖范围分析 内核地址空间布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 虚拟地址空间 (4GB) ┌───────────────────────────────────┐ 0xFFFFFFFF │ │ │ 内核空间 (1GB) │ │ │ │ ┌───────────────────────────┐ │ │ │ 物理内存直接映射 │ │ │ │ 0xC0000000 → 物理 0x0 │ │ │ │ 0xC0001000 → 物理 0x1000 │ │ │ │ ... │ │ │ │ 0xC0000000+RAM → 物理 RAM │ │ │ └───────────────────────────┘ │ │ │ ├───────────────────────────────────┤ 0xC0000000 (PHYS_BASE) │ │ │ │ │ 用户空间 (3GB) │ │ (未映射) │ │ │ │ │ └───────────────────────────────────┘ 0x00000000 需要的页表数量 假设物理内存为 N MB： 每个页表覆盖：4MB（1024 × 4KB） 需要的页表数：⌈N MB / 4 MB⌉ 示例： 物理内存 页目录索引范围 需要的页表数 4 MB 768 1 8 MB 768-769 2 64 MB 768-783 16 256 MB 768-831 64 页表索引计算 对于内核映射（从 PHYS_BASE 开始）： 1 2 3 PHYS_BASE = 0xC0000000 PD Index = 0xC0000000 &gt;&gt; 22 = 768 (0x300) 所以内核映射从页目录的第 768 项开始。 与临时页表的对比 临时页表（start.S） # 临时页表：固定映射 64MB .align PGSIZE init_page_dir: .long 0x00000087 # PDE[0]: 映射 0-4MB .fill 767, 4, 0 # PDE[1-767]: 空 .long 0x00000087 # PDE[768]: 映射 0-4MB 到 0xC0000000-0xC03FFFFF # ... 更多固定 PDE 永久页表（paging_init） 1 2 3 4 5 // 动态映射所有检测到的内存 for (page = 0; page &lt; init_ram_pages; page++) { // 按需分配页表 // 正确设置代码段保护 } 主要区别： 特性 临时页表 永久页表 大小 固定 64MB 动态（检测到的内存） 分配方式 静态（BSS） 动态（palloc） 代码保护 无 代码段只读 页表数量 固定 16 个 按需分配 恒等映射 有（方便切换） 无（不再需要） TLB 刷新 修改 CR3 会自动刷新整个 TLB： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 写入 CR3 前: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ VA 0xC0001000 → PA 0x1000│ │ 旧的缓存项 │ │ VA 0xC0002000 → PA 0x2000│ │ │ │ ... │ │ │ └─────────────────────────┘ │ └─────────────────────────────────┘ 写入 CR3 后: ┌─────────────────────────────────┐ │ TLB │ │ ┌─────────────────────────┐ │ │ │ (空) │ │ 所有条目被清除 │ └─────────────────────────┘ │ └─────────────────────────────────┘ 后续访问会重新填充 TLB 常见问题解答 Q1: 为什么页目录项设置了 PTE_U（用户位）？ A: 虽然内核映射只在内核态使用，但 PDE 的 PTE_U 位需要设置为 1，原因是： 用户程序的页表也会使用同一个页目录 如果 PDE 设置 PTE_U=0，即使 PTE 设置 PTE_U=1，用户程序也无法访问 实际的访问控制由 PTE 的 PTE_U 位决定 Q2: 为什么代码段设置为只读？ A: 安全性：防止恶意或错误代码修改内核指令 调试：写入代码段会触发 Page Fault，便于发现 bug 稳定性：防止缓冲区溢出覆盖代码 Q3: 切换页表时会不会导致问题？ A: 不会，因为： 新旧页表对内核地址的映射完全相同 CPU 当前执行的代码在切换前后都能正确访问 栈和数据也都被正确映射 Q4: 如果物理内存很大，页表会占用多少内存？ A: 页目录：1 页 = 4KB 每 4MB 物理内存需要 1 个页表 = 4KB 例如 256MB 内存：1 + 64 = 65 页 = 260KB 这是相当高效的：260KB 管理 256MB，开销约 0.1% 练习题 练习1：地址分解 给定虚拟地址 0xC0BADCAFE（假设有足够内存），计算： 页目录索引（PD Index） 页表索引（PT Index） 页内偏移（Offset） 对应的物理地址 练习2：页表数量估算 如果系统有 512MB 物理内存： 需要多少个页表？ 页目录和所有页表共占用多少内存？ 练习3：代码保护验证 修改 paging_init，使数据段也变为只读： 预测会发生什么？ 如何安全地测试这个修改？ 练习4：添加恒等映射 如果需要在永久页表中保留低地址的恒等映射（物理地址 = 虚拟地址），需要如何修改 paging_init？ 提示：考虑需要额外映射哪些地址，以及何时可以安全移除这些映射。 下一篇预告 在下一篇文档中，我们将详细解析线程系统的初始化 thread_init()，了解 Pintos 如何设置主线程和调度器基础设施。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide - Chapter 4: Paging Pintos Reference Guide - Virtual Memory OSDev Wiki - Paging","headline":"Pintos Kernel 11 Paging Init","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/pintos-kernel-11-paging-init/"},"url":"http://localhost:4000/posts/pintos-kernel-11-paging-init/"}</script>
<!-- End Jekyll SEO tag -->


  <title>Pintos Kernel 11 Paging Init | Zxsheather
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">



  <!-- Resource Hints -->
  
    
      
        <link rel="preconnect" href="https://fonts.googleapis.com" >
      
        <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
      
    
      
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      
        <link rel="dns-prefetch" href="https://fonts.gstatic.com" >
      
    
      
        <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      
        <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
      
    
  

  <!-- Bootstrap -->
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css">
  

  <!-- Theme style -->
  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  <!-- Web Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css">

  <!-- 3rd-party Dependencies -->

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Image Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css">
  

  <!-- Scripts -->

  <script src="/assets/js/dist/theme.min.js"></script>

  <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/zh.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script>







<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  



  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/3.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <a class="site-title d-block" href="/">Zxsheather</a>
    <p class="site-subtitle fst-italic mb-0">A CS Undergraduate</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>首页</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>分类</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>标签</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>归档</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>关于</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle">
        <i class="fas fa-adjust"></i>
      </button>

      
    

    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">首页</a>
            </span>

          
        
          
        
          
            
              <span>Pintos Kernel 11 Paging Init</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      文章
    </div>

    <button type="button" id="search-trigger" class="btn btn-link" aria-label="Search">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search id="search" class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="搜索..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->










<article class="px-1" data-toc="true">
  <header>
    <h1 data-toc-skip>Pintos Kernel 11 Paging Init</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        发表于
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1769011200"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2026/01/22
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          作者

          <em>
            
              <a href="https://github.com/zxsheather">Zxsheather</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="4746 字"
>
  <em>26 分钟</em>阅读</span>

        </div>
      </div>
    </div>
  </header>

  
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">Pintos Kernel 11 Paging Init</span>
      <button type="button" class="toc-trigger btn me-1">
        <i class="fa-solid fa-list-ul fa-fw"></i>
      </button>
    </div>

    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">文章内容</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>

    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">Pintos Kernel 11 Paging Init</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75">
          <i class="fas fa-close"></i>
        </button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  

  <div class="content">
    <h1 id="pintos-内核启动十一永久页表建立">Pintos 内核启动（十一）：永久页表建立</h1>

<h2 id="概述"><span class="me-2">概述</span><a href="#概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>本文档详细解析 Pintos 内核的 <code class="language-plaintext highlighter-rouge">paging_init()</code> 函数，该函数负责建立永久的页表结构，替换 <code class="language-plaintext highlighter-rouge">start.S</code> 中创建的临时页表。这是内核初始化过程中至关重要的一步，它建立了内核运行所需的完整地址映射。</p>

<p>在 <code class="language-plaintext highlighter-rouge">start.S</code> 中，我们创建了一个简单的临时页表，只映射了前 64MB 的物理内存。现在，<code class="language-plaintext highlighter-rouge">paging_init()</code> 将创建一个完整的页表，映射所有检测到的物理内存，并正确设置页面保护属性。</p>

<h2 id="原始代码"><span class="me-2">原始代码</span><a href="#原始代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="initc-中的-paging_init-函数"><span class="me-2">init.c 中的 paging_init() 函数</span><a href="#initc-中的-paging_init-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="cm">/** Populates the base page directory and page table with the
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">paging_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">page</span><span class="p">;</span>
  <span class="k">extern</span> <span class="kt">char</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_end_kernel_text</span><span class="p">;</span>

  <span class="n">pd</span> <span class="o">=</span> <span class="n">init_page_dir</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ASSERT</span> <span class="o">|</span> <span class="n">PAL_ZERO</span><span class="p">);</span>
  <span class="n">pt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">init_ram_pages</span><span class="p">;</span> <span class="n">page</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">uintptr_t</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">page</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
      <span class="kt">size_t</span> <span class="n">pde_idx</span> <span class="o">=</span> <span class="n">pd_no</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
      <span class="kt">size_t</span> <span class="n">pte_idx</span> <span class="o">=</span> <span class="n">pt_no</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
      <span class="n">bool</span> <span class="n">in_kernel_text</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_start</span> <span class="o">&lt;=</span> <span class="n">vaddr</span> <span class="o">&amp;&amp;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">_end_kernel_text</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">pde_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">pt</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ASSERT</span> <span class="o">|</span> <span class="n">PAL_ZERO</span><span class="p">);</span>
          <span class="n">pd</span><span class="p">[</span><span class="n">pde_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pde_create</span> <span class="p">(</span><span class="n">pt</span><span class="p">);</span>
        <span class="p">}</span>

      <span class="n">pt</span><span class="p">[</span><span class="n">pte_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte_create_kernel</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">!</span><span class="n">in_kernel_text</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"movl %0, %%cr3"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">vtop</span> <span class="p">(</span><span class="n">init_page_dir</span><span class="p">)));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="pteh-中的辅助函数和宏"><span class="me-2">pte.h 中的辅助函数和宏</span><a href="#pteh-中的辅助函数和宏" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre><span class="cm">/** Virtual addresses are structured as follows:

    31                  22 21                  12 11                   0
   +----------------------+----------------------+----------------------+
   | Page Directory Index |   Page Table Index   |    Page Offset       |
   +----------------------+----------------------+----------------------+
*/</span>

<span class="cm">/** Page table index (bits 12:21). */</span>
<span class="cp">#define PTSHIFT PGBITS                     </span><span class="cm">/* First page table bit. */</span><span class="cp">
#define PTBITS  10                         </span><span class="cm">/* Number of page table bits. */</span><span class="cp">
</span>
<span class="cm">/** Page directory index (bits 22:31). */</span>
<span class="cp">#define PDSHIFT (PTSHIFT + PTBITS)         </span><span class="cm">/* First page directory bit. */</span><span class="cp">
#define PDBITS  10                         </span><span class="cm">/* Number of page dir bits. */</span><span class="cp">
</span>
<span class="cm">/** Obtains page table index from a virtual address. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">pt_no</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">va</span> <span class="o">&amp;</span> <span class="n">PTMASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PTSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Obtains page directory index from a virtual address. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uintptr_t</span> <span class="nf">pd_no</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">va</span> <span class="o">&gt;&gt;</span> <span class="n">PDSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Page entry flags. */</span>
<span class="cp">#define PTE_P 0x1               </span><span class="cm">/* 1=present, 0=not present. */</span><span class="cp">
#define PTE_W 0x2               </span><span class="cm">/* 1=read/write, 0=read-only. */</span><span class="cp">
#define PTE_U 0x4               </span><span class="cm">/* 1=user/kernel, 0=kernel only. */</span><span class="cp">
</span>
<span class="cm">/** Returns a PDE that points to page table PT. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">pde_create</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">pg_ofs</span> <span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">vtop</span> <span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">pte_create_kernel</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">bool</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">pg_ofs</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">vtop</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="p">(</span><span class="n">writable</span> <span class="o">?</span> <span class="n">PTE_W</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="前置知识"><span class="me-2">前置知识</span><a href="#前置知识" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="1-x86-两级页表结构"><span class="me-2">1. x86 两级页表结构</span><a href="#1-x86-两级页表结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>x86 保护模式使用<strong>两级页表</strong>进行地址转换：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>32位虚拟地址
┌──────────────┬──────────────┬──────────────┐
│  PD Index    │  PT Index    │   Offset     │
│  (10 bits)   │  (10 bits)   │  (12 bits)   │
└──────┬───────┴──────┬───────┴──────┬───────┘
       │              │              │
       │   ┌──────────┘              │
       │   │                         │
       ↓   │                         ↓
   ┌───────┴──────┐             ┌─────────┐
   │ Page Dir     │   ┌─────→ │ Physical│
   │ (1024项)     │   │        │  Page   │
   │ ┌─────────┐  │   │        │ (4KB)   │
CR3→│ PDE 0   │  │   │        └────┬────┘
   │ ├─────────┤  │   │             │
   │ │  ...    │  │   │             │
   │ ├─────────┤  │   │             ↓
   │ │PDE[idx] │──┼───┤        ┌─────────┐
   │ ├─────────┤  │   │        │ 物理地址 │
   │ │  ...    │  │   │        └─────────┘
   │ └─────────┘  │   │
   └──────────────┘   │
                      │
   ┌──────────────┐   │
   │ Page Table   │◄──┘
   │ (1024项)     │
   │ ┌─────────┐  │
   │ │ PTE 0   │  │
   │ ├─────────┤  │
   │ │  ...    │  │
   │ ├─────────┤  │
   │ │PTE[idx] │──────────────────→ 物理页帧
   │ ├─────────┤  │
   │ │  ...    │  │
   │ └─────────┘  │
   └──────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="2-页目录项pde格式"><span class="me-2">2. 页目录项（PDE）格式</span><a href="#2-页目录项pde格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>31                                 12 11  9 8 7 6 5 4 3 2 1 0
+------------------------------------+-----+-+-+-+-+-+-+-+-+-+
|    Page Table Physical Address     | AVL |G|S|0|A|D|W|U|R|P|
+------------------------------------+-----+-+-+-+-+-+-+-+-+-+
                                           | | | | | | | | |
                                           | | | | | | | | +-- Present
                                           | | | | | | | +---- Read/Write
                                           | | | | | | +------ User/Supervisor
                                           | | | | | +-------- Write-Through
                                           | | | | +---------- Cache Disable
                                           | | | +------------ Accessed
                                           | | +-------------- (reserved)
                                           | +---------------- Page Size (0=4KB)
                                           +------------------ Global
</pre></td></tr></tbody></table></code></div></div>

<h3 id="3-页表项pte格式"><span class="me-2">3. 页表项（PTE）格式</span><a href="#3-页表项pte格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>31                                 12 11  9 8 7 6 5 4 3 2 1 0
+------------------------------------+-----+-+-+-+-+-+-+-+-+-+
|      Physical Page Address         | AVL |G|0|D|A|C|W|U|R|P|
+------------------------------------+-----+-+-+-+-+-+-+-+-+-+
                                           | | | | | | | | |
                                           | | | | | | | | +-- Present
                                           | | | | | | | +---- Read/Write
                                           | | | | | | +------ User/Supervisor
                                           | | | | | +-------- Write-Through
                                           | | | | +---------- Cache Disable
                                           | | | +------------ Accessed
                                           | | +-------------- Dirty
                                           | +---------------- (reserved)
                                           +------------------ Global
</pre></td></tr></tbody></table></code></div></div>

<h3 id="4-临时页表-vs-永久页表"><span class="me-2">4. 临时页表 vs 永久页表</span><a href="#4-临时页表-vs-永久页表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>特性</th>
      <th>临时页表 (start.S)</th>
      <th>永久页表 (paging_init)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>创建时机</td>
      <td>进入保护模式前</td>
      <td>内存系统初始化后</td>
    </tr>
    <tr>
      <td>覆盖范围</td>
      <td>固定 64MB</td>
      <td>所有检测到的物理内存</td>
    </tr>
    <tr>
      <td>位置</td>
      <td>BSS 段静态分配</td>
      <td>动态从内存池分配</td>
    </tr>
    <tr>
      <td>代码保护</td>
      <td>无</td>
      <td>内核代码段只读</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>启动过渡</td>
      <td>长期运行</td>
    </tr>
  </tbody>
</table></div>

<h3 id="5-链接器符号"><span class="me-2">5. 链接器符号</span><a href="#5-链接器符号" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>链接器脚本（linker script）定义了一些特殊符号：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">_start</code>：内核代码段起始地址</li>
  <li><code class="language-plaintext highlighter-rouge">_end_kernel_text</code>：内核代码段结束地址</li>
</ul>

<p>这些符号用于区分代码段和数据段，以便正确设置页面保护。</p>

<h2 id="逐行代码解析"><span class="me-2">逐行代码解析</span><a href="#逐行代码解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="第1-3行变量声明和外部符号"><span class="me-2">第1-3行：变量声明和外部符号</span><a href="#第1-3行变量声明和外部符号" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">page</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_end_kernel_text</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>pd（Page Directory）</strong>：
    <ul>
      <li>类型：<code class="language-plaintext highlighter-rouge">uint32_t *</code>（指向32位整数的指针）</li>
      <li>用途：指向页目录</li>
      <li>页目录包含 1024 个 PDE（页目录项）</li>
    </ul>
  </li>
  <li><strong>pt（Page Table）</strong>：
    <ul>
      <li>类型：<code class="language-plaintext highlighter-rouge">uint32_t *</code></li>
      <li>用途：指向当前正在填充的页表</li>
      <li>每个页表包含 1024 个 PTE（页表项）</li>
    </ul>
  </li>
  <li><strong>page</strong>：
    <ul>
      <li>循环变量，遍历所有物理页</li>
    </ul>
  </li>
  <li><strong>外部符号</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">_start</code>：内核代码起始位置</li>
      <li><code class="language-plaintext highlighter-rouge">_end_kernel_text</code>：内核代码结束位置</li>
      <li>这些符号由链接器自动生成</li>
    </ul>
  </li>
</ol>

<h3 id="第4行分配页目录"><span class="me-2">第4行：分配页目录</span><a href="#第4行分配页目录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">pd</span> <span class="o">=</span> <span class="n">init_page_dir</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ASSERT</span> <span class="o">|</span> <span class="n">PAL_ZERO</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>palloc_get_page 调用</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">PAL_ASSERT</code>：分配失败时触发 PANIC</li>
      <li><code class="language-plaintext highlighter-rouge">PAL_ZERO</code>：将页清零（所有 PDE 初始化为 0，即”不存在”）</li>
    </ul>
  </li>
  <li><strong>双重赋值</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pd</code>：局部变量，方便后续访问</li>
      <li><code class="language-plaintext highlighter-rouge">init_page_dir</code>：全局变量，供其他模块使用</li>
    </ul>
  </li>
  <li><strong>为什么需要清零</strong>？
    <ul>
      <li>PDE 值为 0 表示页表项”不存在”</li>
      <li>CPU 访问不存在的页会触发 Page Fault</li>
      <li>确保未映射的地址不会被意外访问</li>
    </ul>
  </li>
</ol>

<p><strong>页目录初始状态</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>页目录 (4KB)
┌───────────────┐ pd[0]
│      0        │ (不存在)
├───────────────┤ pd[1]
│      0        │ (不存在)
├───────────────┤
│     ...       │
├───────────────┤ pd[1023]
│      0        │ (不存在)
└───────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="第5行初始化页表指针"><span class="me-2">第5行：初始化页表指针</span><a href="#第5行初始化页表指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">pt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ul>
  <li>初始化为 NULL，表示还没有分配任何页表</li>
  <li>后续循环中会按需分配页表</li>
</ul>

<h3 id="第6-7行遍历所有物理页"><span class="me-2">第6-7行：遍历所有物理页</span><a href="#第6-7行遍历所有物理页" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">init_ram_pages</span><span class="p">;</span> <span class="n">page</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uintptr_t</span> <span class="n">paddr</span> <span class="o">=</span> <span class="n">page</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>循环范围</strong>：
    <ul>
      <li>从物理页 0 开始</li>
      <li>到 <code class="language-plaintext highlighter-rouge">init_ram_pages - 1</code> 结束</li>
      <li>覆盖所有检测到的物理内存</li>
    </ul>
  </li>
  <li><strong>物理地址计算</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">paddr = page * 4096</code></li>
      <li>每次循环处理一个 4KB 物理页</li>
    </ul>
  </li>
</ol>

<p><strong>示例</strong>：假设有 4MB 物理内存（1024 页）</p>
<ul>
  <li>page = 0: paddr = 0x00000000</li>
  <li>page = 1: paddr = 0x00001000</li>
  <li>page = 255: paddr = 0x000FF000</li>
  <li>page = 256: paddr = 0x00100000 (1MB)</li>
  <li>…</li>
</ul>

<h3 id="第8行计算虚拟地址"><span class="me-2">第8行：计算虚拟地址</span><a href="#第8行计算虚拟地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="n">paddr</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ptov(paddr) = paddr + PHYS_BASE = paddr + 0xC0000000</code></li>
  <li>建立物理地址到虚拟地址的映射</li>
</ul>

<p><strong>映射示例</strong>：</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>物理地址</th>
      <th>虚拟地址</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00000000</td>
      <td>0xC0000000</td>
    </tr>
    <tr>
      <td>0x00001000</td>
      <td>0xC0001000</td>
    </tr>
    <tr>
      <td>0x00100000</td>
      <td>0xC0100000</td>
    </tr>
    <tr>
      <td>0x003FF000</td>
      <td>0xC03FF000</td>
    </tr>
  </tbody>
</table></div>

<h3 id="第9-10行提取页表索引"><span class="me-2">第9-10行：提取页表索引</span><a href="#第9-10行提取页表索引" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">pde_idx</span> <span class="o">=</span> <span class="n">pd_no</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">pte_idx</span> <span class="o">=</span> <span class="n">pt_no</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>pd_no (vaddr)</strong>：
    <ul>
      <li>提取虚拟地址的高 10 位（bits 22-31）</li>
      <li>范围：0 - 1023</li>
      <li>用于索引页目录</li>
    </ul>
  </li>
  <li><strong>pt_no (vaddr)</strong>：
    <ul>
      <li>提取虚拟地址的中间 10 位（bits 12-21）</li>
      <li>范围：0 - 1023</li>
      <li>用于索引页表</li>
    </ul>
  </li>
</ol>

<p><strong>地址分解示例</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>虚拟地址 0xC0001000 (对应物理地址 0x00001000)

二进制: 1100 0000 0000 0000 0001 0000 0000 0000
        ├────────┬─┤├────────┬─┤├────────┬───┤
         PD Index    PT Index     Offset
           768          1           0

pde_idx = 768 (0x300)
pte_idx = 1
offset  = 0
</pre></td></tr></tbody></table></code></div></div>

<h3 id="第11行判断是否为内核代码段"><span class="me-2">第11行：判断是否为内核代码段</span><a href="#第11行判断是否为内核代码段" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">bool</span> <span class="n">in_kernel_text</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_start</span> <span class="o">&lt;=</span> <span class="n">vaddr</span> <span class="o">&amp;&amp;</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">_end_kernel_text</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>判断条件</strong>：
    <ul>
      <li>检查当前虚拟地址是否在内核代码段范围内</li>
      <li><code class="language-plaintext highlighter-rouge">_start</code>：内核代码起始</li>
      <li><code class="language-plaintext highlighter-rouge">_end_kernel_text</code>：内核代码结束</li>
    </ul>
  </li>
  <li><strong>为什么需要区分</strong>？
    <ul>
      <li>代码段应该是<strong>只读</strong>的（不应被修改）</li>
      <li>数据段需要是<strong>可写</strong>的</li>
      <li>这是基本的内存保护机制</li>
    </ul>
  </li>
</ol>

<p><strong>内核内存布局</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>┌─────────────────────┐ _start (约 0xC0020000)
│                     │
│    .text 段         │ ← 代码段（只读）
│    (内核代码)        │
│                     │
├─────────────────────┤ _end_kernel_text
│                     │
│    .rodata 段       │ ← 只读数据
│                     │
├─────────────────────┤
│                     │
│    .data 段         │ ← 已初始化数据（可写）
│                     │
├─────────────────────┤
│                     │
│    .bss 段          │ ← 未初始化数据（可写）
│                     │
└─────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="第12-16行按需分配页表"><span class="me-2">第12-16行：按需分配页表</span><a href="#第12-16行按需分配页表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="p">[</span><span class="n">pde_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pt</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ASSERT</span> <span class="o">|</span> <span class="n">PAL_ZERO</span><span class="p">);</span>
  <span class="n">pd</span><span class="p">[</span><span class="n">pde_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pde_create</span> <span class="p">(</span><span class="n">pt</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>检查条件</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pd[pde_idx] == 0</code> 表示该页目录项尚未指向任何页表</li>
      <li>需要分配一个新的页表</li>
    </ul>
  </li>
  <li><strong>分配页表</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">palloc_get_page(PAL_ASSERT | PAL_ZERO)</code></li>
      <li>获取一个清零的页作为页表</li>
      <li>一个页表可以容纳 1024 个 PTE</li>
    </ul>
  </li>
  <li><strong>创建 PDE</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pde_create(pt)</code> 构造页目录项</li>
      <li>
        <div class="table-wrapper"><table>
          <tbody>
            <tr>
              <td>设置标志位：PTE_U</td>
              <td>PTE_P</td>
              <td>PTE_W</td>
            </tr>
          </tbody>
        </table></div>
      </li>
    </ul>
  </li>
</ol>

<p><strong>pde_create 函数分析</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">pde_create</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">pg_ofs</span> <span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>        <span class="c1">// 确保页表页对齐</span>
  <span class="k">return</span> <span class="n">vtop</span> <span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vtop(pt)</code>：将页表的虚拟地址转换为物理地址</li>
  <li><code class="language-plaintext highlighter-rouge">PTE_P</code>：Present 位，表示页表存在</li>
  <li><code class="language-plaintext highlighter-rouge">PTE_W</code>：Writable 位，允许写入</li>
  <li><code class="language-plaintext highlighter-rouge">PTE_U</code>：User 位，允许用户态访问（这里设置是为了支持用户程序）</li>
</ul>

<p><strong>PDE 格式</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>31                                    12 11        0
+---------------------------------------+----------+
|     Page Table Physical Address       |   Flags  |
+---------------------------------------+----------+
                                        PTE_U = 0x4
                                        PTE_W = 0x2
                                        PTE_P = 0x1
                                        
结果: PDE = (pt 物理地址) | 0x7
</pre></td></tr></tbody></table></code></div></div>

<h3 id="第17行创建页表项"><span class="me-2">第17行：创建页表项</span><a href="#第17行创建页表项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">pt</span><span class="p">[</span><span class="n">pte_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pte_create_kernel</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="o">!</span><span class="n">in_kernel_text</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>pte_create_kernel 调用</strong>：
    <ul>
      <li>第一个参数：虚拟地址（用于计算物理页地址）</li>
      <li>第二个参数：是否可写
        <ul>
          <li><code class="language-plaintext highlighter-rouge">!in_kernel_text</code>：如果在代码段内，不可写</li>
          <li>代码段：writable = false</li>
          <li>数据段：writable = true</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><strong>pte_create_kernel 函数分析</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">pte_create_kernel</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">bool</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">pg_ofs</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>      <span class="c1">// 确保地址页对齐</span>
  <span class="k">return</span> <span class="n">vtop</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="p">(</span><span class="n">writable</span> <span class="o">?</span> <span class="n">PTE_W</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vtop(page)</code>：将虚拟地址转换为物理地址</li>
  <li><code class="language-plaintext highlighter-rouge">PTE_P</code>：Present 位</li>
  <li>条件设置 <code class="language-plaintext highlighter-rouge">PTE_W</code>：根据 writable 参数决定</li>
</ul>

<p><strong>注意</strong>：没有设置 <code class="language-plaintext highlighter-rouge">PTE_U</code>，所以这些页只能在内核态（Ring 0）访问。</p>

<p><strong>PTE 格式示例</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>代码段页（只读）：
31                           12 11        0
+------------------------------+----------+
|    Physical Page Address     | 00000001 |
+------------------------------+----------+
                                 PTE_P = 1
                                 PTE_W = 0 (只读)
                                 PTE_U = 0 (仅内核)

数据段页（可写）：
31                           12 11        0
+------------------------------+----------+
|    Physical Page Address     | 00000011 |
+------------------------------+----------+
                                 PTE_P = 1
                                 PTE_W = 1 (可写)
                                 PTE_U = 0 (仅内核)
</pre></td></tr></tbody></table></code></div></div>

<h3 id="第18-22行激活新页表"><span class="me-2">第18-22行：激活新页表</span><a href="#第18-22行激活新页表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="cm">/* Store the physical address of the page directory into CR3
   aka PDBR (page directory base register).  This activates our
   new page tables immediately.  See [IA32-v2a] "MOV--Move
   to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
   of the Page Directory". */</span>
<span class="n">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">"movl %0, %%cr3"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">vtop</span> <span class="p">(</span><span class="n">init_page_dir</span><span class="p">)));</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>内联汇编语法</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">asm volatile</code>：告诉编译器这是汇编代码，不要优化</li>
      <li><code class="language-plaintext highlighter-rouge">"movl %0, %%cr3"</code>：将操作数 0 移动到 CR3 寄存器</li>
      <li><code class="language-plaintext highlighter-rouge">: :</code>：无输出操作数</li>
      <li><code class="language-plaintext highlighter-rouge">"r" (vtop (init_page_dir))</code>：输入操作数，使用任意通用寄存器</li>
    </ul>
  </li>
  <li><strong>CR3 寄存器</strong>：
    <ul>
      <li>也称为 PDBR（Page Directory Base Register）</li>
      <li>存储页目录的<strong>物理地址</strong></li>
      <li>修改 CR3 会导致 TLB（Translation Lookaside Buffer）刷新</li>
    </ul>
  </li>
  <li><strong>地址转换</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">init_page_dir</code> 是虚拟地址</li>
      <li><code class="language-plaintext highlighter-rouge">vtop()</code> 将其转换为物理地址</li>
      <li>CPU 需要物理地址来定位页目录</li>
    </ul>
  </li>
</ol>

<p><strong>为什么使用 volatile</strong>？</p>

<ul>
  <li>防止编译器优化掉这条指令</li>
  <li>确保页表切换立即发生</li>
  <li>这是一个有副作用的操作（改变内存映射）</li>
</ul>

<p><strong>页表切换图示</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>                        切换前 (临时页表)
                    ┌─────────────────────┐
                    │  旧页目录 (BSS)      │
           CR3 ─────→  位于 init.c        │
                    └─────────────────────┘

                        ↓ movl %0, %%cr3 ↓

                        切换后 (永久页表)
                    ┌─────────────────────┐
                    │  新页目录 (动态分配) │
           CR3 ─────→  位于内核池         │
                    └─────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h2 id="完整地址转换示例"><span class="me-2">完整地址转换示例</span><a href="#完整地址转换示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>假设访问虚拟地址 <code class="language-plaintext highlighter-rouge">0xC0123456</code>：</p>

<p><strong>步骤1：分解虚拟地址</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>0xC0123456 = 1100 0000 0001 0010 0011 0100 0101 0110

PD Index  = 1100 0000 01 = 769 (0x301)
PT Index  = 00 0010 0011 = 35 (0x23)
Offset    = 0100 0101 0110 = 0x456
</pre></td></tr></tbody></table></code></div></div>

<p><strong>步骤2：查找页目录</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>PDE = pd[769]
    = 页表的物理地址 | PTE_U | PTE_P | PTE_W
</pre></td></tr></tbody></table></code></div></div>

<p><strong>步骤3：查找页表</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>pt = PDE &amp; 0xFFFFF000  (提取页表物理地址)
PTE = pt[35]
    = 物理页的地址 | PTE_P | (PTE_W)
</pre></td></tr></tbody></table></code></div></div>

<p><strong>步骤4：计算物理地址</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>物理页帧 = PTE &amp; 0xFFFFF000
物理地址 = 物理页帧 + 0x456
         = 0x00123000 + 0x456
         = 0x00123456
</pre></td></tr></tbody></table></code></div></div>

<p><strong>完整转换图</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>虚拟地址: 0xC0123456
              │
              ↓
┌─────────────────────────────────────────────────────┐
│                                                     │
│    ┌──────────────┐                                │
│    │    CR3       │──────────┐                     │
│    └──────────────┘          │                     │
│                              ↓                     │
│    ┌─────────────────────────────────┐             │
│    │         Page Directory          │             │
│    │  ┌───────────────────────────┐  │             │
│    │  │ pd[0]                     │  │             │
│    │  │ ...                       │  │             │
│    │  │ pd[769] ─────────────────────────┐         │
│    │  │ ...                       │  │   │         │
│    │  │ pd[1023]                  │  │   │         │
│    │  └───────────────────────────┘  │   │         │
│    └─────────────────────────────────┘   │         │
│                                          ↓         │
│    ┌─────────────────────────────────────────┐     │
│    │            Page Table                   │     │
│    │  ┌───────────────────────────────────┐  │     │
│    │  │ pt[0]                             │  │     │
│    │  │ ...                               │  │     │
│    │  │ pt[35] = 0x00123003 ─────────────────────┐ │
│    │  │ ...                               │  │   │ │
│    │  │ pt[1023]                          │  │   │ │
│    │  └───────────────────────────────────┘  │   │ │
│    └─────────────────────────────────────────┘   │ │
│                                                  │ │
│    ┌─────────────────────────────────────────┐   │ │
│    │          Physical Page                  │◄──┘ │
│    │  ┌───────────────────────────────────┐  │     │
│    │  │ offset 0x000                      │  │     │
│    │  │ ...                               │  │     │
│    │  │ offset 0x456 ◄── 目标数据         │  │     │
│    │  │ ...                               │  │     │
│    │  │ offset 0xFFF                      │  │     │
│    │  └───────────────────────────────────┘  │     │
│    └─────────────────────────────────────────┘     │
│                                                     │
└─────────────────────────────────────────────────────┘
              │
              ↓
物理地址: 0x00123456
</pre></td></tr></tbody></table></code></div></div>

<h2 id="页表覆盖范围分析"><span class="me-2">页表覆盖范围分析</span><a href="#页表覆盖范围分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="内核地址空间布局"><span class="me-2">内核地址空间布局</span><a href="#内核地址空间布局" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>虚拟地址空间 (4GB)
┌───────────────────────────────────┐ 0xFFFFFFFF
│                                   │
│         内核空间 (1GB)            │
│                                   │
│  ┌───────────────────────────┐   │
│  │ 物理内存直接映射           │   │
│  │ 0xC0000000 → 物理 0x0     │   │
│  │ 0xC0001000 → 物理 0x1000  │   │
│  │      ...                   │   │
│  │ 0xC0000000+RAM → 物理 RAM │   │
│  └───────────────────────────┘   │
│                                   │
├───────────────────────────────────┤ 0xC0000000 (PHYS_BASE)
│                                   │
│                                   │
│         用户空间 (3GB)            │
│         (未映射)                  │
│                                   │
│                                   │
└───────────────────────────────────┘ 0x00000000
</pre></td></tr></tbody></table></code></div></div>

<h3 id="需要的页表数量"><span class="me-2">需要的页表数量</span><a href="#需要的页表数量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>假设物理内存为 N MB：</p>

<ul>
  <li>每个页表覆盖：4MB（1024 × 4KB）</li>
  <li>需要的页表数：⌈N MB / 4 MB⌉</li>
</ul>

<p><strong>示例</strong>：</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>物理内存</th>
      <th>页目录索引范围</th>
      <th>需要的页表数</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4 MB</td>
      <td>768</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8 MB</td>
      <td>768-769</td>
      <td>2</td>
    </tr>
    <tr>
      <td>64 MB</td>
      <td>768-783</td>
      <td>16</td>
    </tr>
    <tr>
      <td>256 MB</td>
      <td>768-831</td>
      <td>64</td>
    </tr>
  </tbody>
</table></div>

<h3 id="页表索引计算"><span class="me-2">页表索引计算</span><a href="#页表索引计算" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>对于内核映射（从 PHYS_BASE 开始）：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>PHYS_BASE = 0xC0000000

PD Index = 0xC0000000 &gt;&gt; 22 = 768 (0x300)
</pre></td></tr></tbody></table></code></div></div>

<p>所以内核映射从页目录的第 768 项开始。</p>

<h2 id="与临时页表的对比"><span class="me-2">与临时页表的对比</span><a href="#与临时页表的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="临时页表starts"><span class="me-2">临时页表（start.S）</span><a href="#临时页表starts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<pre><code class="language-assembly"># 临时页表：固定映射 64MB
.align PGSIZE
init_page_dir:
    .long 0x00000087    # PDE[0]: 映射 0-4MB
    .fill 767, 4, 0     # PDE[1-767]: 空
    .long 0x00000087    # PDE[768]: 映射 0-4MB 到 0xC0000000-0xC03FFFFF
    # ... 更多固定 PDE
</code></pre>

<h3 id="永久页表paging_init"><span class="me-2">永久页表（paging_init）</span><a href="#永久页表paging_init" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">// 动态映射所有检测到的内存</span>
<span class="k">for</span> <span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">init_ram_pages</span><span class="p">;</span> <span class="n">page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 按需分配页表</span>
    <span class="c1">// 正确设置代码段保护</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>主要区别</strong>：</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>特性</th>
      <th>临时页表</th>
      <th>永久页表</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>大小</td>
      <td>固定 64MB</td>
      <td>动态（检测到的内存）</td>
    </tr>
    <tr>
      <td>分配方式</td>
      <td>静态（BSS）</td>
      <td>动态（palloc）</td>
    </tr>
    <tr>
      <td>代码保护</td>
      <td>无</td>
      <td>代码段只读</td>
    </tr>
    <tr>
      <td>页表数量</td>
      <td>固定 16 个</td>
      <td>按需分配</td>
    </tr>
    <tr>
      <td>恒等映射</td>
      <td>有（方便切换）</td>
      <td>无（不再需要）</td>
    </tr>
  </tbody>
</table></div>

<h2 id="tlb-刷新"><span class="me-2">TLB 刷新</span><a href="#tlb-刷新" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>修改 CR3 会自动刷新整个 TLB：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>写入 CR3 前:
┌─────────────────────────────────┐
│             TLB                 │
│  ┌─────────────────────────┐   │
│  │ VA 0xC0001000 → PA 0x1000│   │ 旧的缓存项
│  │ VA 0xC0002000 → PA 0x2000│   │
│  │ ...                      │   │
│  └─────────────────────────┘   │
└─────────────────────────────────┘

写入 CR3 后:
┌─────────────────────────────────┐
│             TLB                 │
│  ┌─────────────────────────┐   │
│  │         (空)             │   │ 所有条目被清除
│  └─────────────────────────┘   │
└─────────────────────────────────┘

后续访问会重新填充 TLB
</pre></td></tr></tbody></table></code></div></div>

<h2 id="常见问题解答"><span class="me-2">常见问题解答</span><a href="#常见问题解答" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="q1-为什么页目录项设置了-pte_u用户位"><span class="me-2">Q1: 为什么页目录项设置了 PTE_U（用户位）？</span><a href="#q1-为什么页目录项设置了-pte_u用户位" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: 虽然内核映射只在内核态使用，但 PDE 的 PTE_U 位需要设置为 1，原因是：</p>
<ol>
  <li>用户程序的页表也会使用同一个页目录</li>
  <li>如果 PDE 设置 PTE_U=0，即使 PTE 设置 PTE_U=1，用户程序也无法访问</li>
  <li>实际的访问控制由 PTE 的 PTE_U 位决定</li>
</ol>

<h3 id="q2-为什么代码段设置为只读"><span class="me-2">Q2: 为什么代码段设置为只读？</span><a href="#q2-为什么代码段设置为只读" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ol>
  <li><strong>安全性</strong>：防止恶意或错误代码修改内核指令</li>
  <li><strong>调试</strong>：写入代码段会触发 Page Fault，便于发现 bug</li>
  <li><strong>稳定性</strong>：防止缓冲区溢出覆盖代码</li>
</ol>

<h3 id="q3-切换页表时会不会导致问题"><span class="me-2">Q3: 切换页表时会不会导致问题？</span><a href="#q3-切换页表时会不会导致问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: 不会，因为：</p>
<ol>
  <li>新旧页表对内核地址的映射完全相同</li>
  <li>CPU 当前执行的代码在切换前后都能正确访问</li>
  <li>栈和数据也都被正确映射</li>
</ol>

<h3 id="q4-如果物理内存很大页表会占用多少内存"><span class="me-2">Q4: 如果物理内存很大，页表会占用多少内存？</span><a href="#q4-如果物理内存很大页表会占用多少内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ul>
  <li>页目录：1 页 = 4KB</li>
  <li>每 4MB 物理内存需要 1 个页表 = 4KB</li>
  <li>例如 256MB 内存：1 + 64 = 65 页 = 260KB</li>
</ul>

<p>这是相当高效的：260KB 管理 256MB，开销约 0.1%</p>

<h2 id="练习题"><span class="me-2">练习题</span><a href="#练习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="练习1地址分解"><span class="me-2">练习1：地址分解</span><a href="#练习1地址分解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>给定虚拟地址 <code class="language-plaintext highlighter-rouge">0xC0BADCAFE</code>（假设有足够内存），计算：</p>
<ol>
  <li>页目录索引（PD Index）</li>
  <li>页表索引（PT Index）</li>
  <li>页内偏移（Offset）</li>
  <li>对应的物理地址</li>
</ol>

<h3 id="练习2页表数量估算"><span class="me-2">练习2：页表数量估算</span><a href="#练习2页表数量估算" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>如果系统有 512MB 物理内存：</p>
<ol>
  <li>需要多少个页表？</li>
  <li>页目录和所有页表共占用多少内存？</li>
</ol>

<h3 id="练习3代码保护验证"><span class="me-2">练习3：代码保护验证</span><a href="#练习3代码保护验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>修改 paging_init，使数据段也变为只读：</p>
<ol>
  <li>预测会发生什么？</li>
  <li>如何安全地测试这个修改？</li>
</ol>

<h3 id="练习4添加恒等映射"><span class="me-2">练习4：添加恒等映射</span><a href="#练习4添加恒等映射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>如果需要在永久页表中保留低地址的恒等映射（物理地址 = 虚拟地址），需要如何修改 paging_init？</p>

<p><strong>提示</strong>：考虑需要额外映射哪些地址，以及何时可以安全移除这些映射。</p>

<h2 id="下一篇预告"><span class="me-2">下一篇预告</span><a href="#下一篇预告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>在下一篇文档中，我们将详细解析线程系统的初始化 <code class="language-plaintext highlighter-rouge">thread_init()</code>，了解 Pintos 如何设置主线程和调度器基础设施。</p>

<h2 id="参考资料"><span class="me-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<ol>
  <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide</a> - Chapter 4: Paging</li>
  <li><a href="https://web.stanford.edu/class/cs140/projects/pintos/pintos_6.html">Pintos Reference Guide - Virtual Memory</a></li>
  <li><a href="https://wiki.osdev.org/Paging">OSDev Wiki - Paging</a></li>
</ol>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">分享</span>
  <span class="share-icons">
    
    
    

    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="分享链接"
      data-title-succeed="链接已复制！"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">最近更新</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-03-create/">Pintos 线程系统详解（三）：线程创建</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-04-schedule/">Pintos 线程系统详解（四）：线程调度</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-05-switch/">Pintos 线程系统详解（五）：上下文切换</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-06-block-unblock/">Pintos 线程系统详解（六）：阻塞与唤醒</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-07-semaphore/">Pintos 线程系统详解（七）：信号量</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


            </div>

            
              
              






  <div class="toc-border-cover z-3"></div>
  <section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4">
    <h2 class="panel-heading ps-3 pb-2 mb-0">文章内容</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->


























            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/pintos-kernel-10-memory-init/"
      class="btn btn-outline-primary"
      aria-label="上一篇"
    >
      <p>Pintos Kernel 10 Memory Init</p>
    </a>
  

  
    <a
      href="/posts/pintos-kernel-12-thread-init/"
      class="btn btn-outline-primary"
      aria-label="下一篇"
    >
      <p>Pintos Kernel 12 Thread Init</p>
    </a>
  
</nav>

            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2026</time>

    
      <a href="https://github.com/zxsheather">Zxsheather</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"
      >保留部分权利。</span>
    
  </p>

  <p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v7.4.1"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center d-none">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">发现新版本的内容。</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      更新
    </button>
  </div>
</aside>

    

    <!-- Embedded scripts -->

    
      
      <!-- The comments switcher -->


    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  
  document.addEventListener('DOMContentLoaded', () => {
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('search-results'),
      json: '/assets/js/data/search.json',
      searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{content}</p>  </article>',
      noResultsText: '<p class="mt-5">搜索结果为空</p>',
      templateMiddleware: function(prop, value, template) {
        if (prop === 'categories') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
          }
        }

        if (prop === 'tags') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
          }
        }
      }
    });
  });
</script>

  </body>
</html>

