<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="zh-CN" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Pintos Kernel 14 Device Init" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Pintos 内核启动（十四）：设备初始化 概述 本文档详细解析 Pintos 内核的设备初始化过程。在中断系统初始化完成后，内核需要初始化各种硬件设备，使它们能够正常工作。Pintos 涉及的主要设备包括： 定时器（Timer）：提供时间基准和周期性中断 键盘（Keyboard）：处理用户输入 串口（Serial Port）：用于调试输出和通信 控制台（Console）：管理屏幕输出 这些设备的初始化顺序是精心设计的，确保系统能够正确响应硬件事件。 初始化顺序 1 2 3 4 5 6 7 8 9 10 11 12 /* pintos_init() 中的设备初始化顺序 */ /* Initialize interrupt handlers. */ intr_init (); // 中断系统 timer_init (); // 定时器 kbd_init (); // 键盘 input_init (); // 输入缓冲区 /* Start thread scheduler and enable interrupts. */ thread_start (); // 启动调度（开中断） serial_init_queue ();// 串口队列模式 timer_calibrate (); // 定时器校准 初始化时序图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 时间轴 ────────────────────────────────────────────────────→ 中断关闭 │ 中断开启 ─────────────────────────────────│─────────────────────────── │ intr_init() │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ │ timer_init() │ │ │ └─→ 配置 PIT │ 注册定时器中断 │ │ kbd_init() │ │ │ └─→ 注册键盘中断 │ │ input_init() │ │ │ └─→ 初始化输入队列 │ │ thread_start() │ ├─→ 创建空闲线程 │ └─→ intr_enable() │ ↓ 中断开始被处理 serial_init_queue() │ └─→ 启用串口中断 timer_calibrate() │ └─→ 测量 CPU 速度 定时器初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* timer.c */ /** Number of timer ticks since OS booted. */ static int64_t ticks; /** Sets up the timer to interrupt TIMER_FREQ times per second, and registers the corresponding interrupt. */ void timer_init (void) { pit_configure_channel (0, 2, TIMER_FREQ); intr_register_ext (0x20, timer_interrupt, &quot;8254 Timer&quot;); } /* pit.c */ /** 8254 registers. */ #define PIT_PORT_CONTROL 0x43 #define PIT_PORT_COUNTER(CHANNEL) (0x40 + (CHANNEL)) /** PIT cycles per second. */ #define PIT_HZ 1193180 void pit_configure_channel (int channel, int mode, int frequency) { uint16_t count; enum intr_level old_level; ASSERT (channel == 0 || channel == 2); ASSERT (mode == 2 || mode == 3); /* Convert FREQUENCY to a PIT counter value. */ if (frequency &lt; 19) count = 0; else if (frequency &gt; PIT_HZ) count = 2; else count = (PIT_HZ + frequency / 2) / frequency; /* Configure the PIT. */ old_level = intr_disable (); outb (PIT_PORT_CONTROL, ((channel &lt;&lt; 6) | 0x30 | (mode &lt;&lt; 1))); outb (PIT_PORT_COUNTER (channel), count); outb (PIT_PORT_COUNTER (channel), count &gt;&gt; 8); intr_set_level (old_level); } 8254 PIT 硬件架构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌───────────────────────────────────────┐ │ 8254 PIT │ │ │ 时钟输入 ─────────┼─→ CLK (1.193180 MHz) │ (1.193180 MHz) │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │ Channel 0 │ │ Channel 1 │ │ │ │ │ │ │ │ │ │ 计数器 │ │ 计数器 │ │ │ │ │ │ (DRAM) │ │ │ │ OUT0 ───────┼─┼─────────────┼─→ IRQ0 (定时器中断) │ └─────────────┘ └─────────────┘ │ │ │ │ ┌─────────────┐ │ │ │ Channel 2 │ │ │ │ │ │ │ │ 计数器 │ │ │ │ │ │ │ │ OUT2 ───────┼───────────────────→ Speaker │ └─────────────┘ │ │ │ 端口 0x40-0x43 ────┼─→ 控制/数据 │ └───────────────────────────────────────┘ PIT 配置详解 pit_configure_channel() 参数计算： 1 2 3 4 5 6 7 8 /* TIMER_FREQ = 100 Hz (每秒 100 次中断) */ /* PIT_HZ = 1193180 Hz */ count = PIT_HZ / TIMER_FREQ = 1193180 / 100 = 11932 (约) /* 实际频率 = 1193180 / 11932 ≈ 100.007 Hz */ 控制字格式（端口 0x43）： 1 2 3 4 5 6 7 位 7-6: 通道选择 (00=Ch0, 01=Ch1, 10=Ch2) 位 5-4: 访问模式 (11=先低后高) 位 3-1: 工作模式 (010=Mode 2, 011=Mode 3) 位 0: BCD/二进制 (0=二进制) 对于 Channel 0, Mode 2: (0 &lt;&lt; 6) | 0x30 | (2 &lt;&lt; 1) = 0x34 Mode 2（速率发生器）工作原理： 1 2 3 4 5 6 7 8 9 10 计数值 = 11932 时间轴 ─────────────────────────────────────────────→ │←────── 11932 个时钟周期 ──────→│ │ │ OUT ─────┘ ┌┘ ↑ ↑ 计数开始 计数到0 (输出变高) (脉冲，输出变低，然后立即变高) 同时重新加载计数值 timer_init() 流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 timer_init() │ ├─→ pit_configure_channel(0, 2, TIMER_FREQ) │ │ │ ├─→ 计算 count = 11932 │ │ │ ├─→ 关中断（防止配置过程中产生中断） │ │ │ ├─→ outb(0x43, 0x34) // 控制字 │ │ │ ├─→ outb(0x40, 11932 &amp; 0xFF) // 计数值低字节 │ │ │ ├─→ outb(0x40, 11932 &gt;&gt; 8) // 计数值高字节 │ │ │ └─→ 恢复中断状态 │ └─→ intr_register_ext(0x20, timer_interrupt, &quot;8254 Timer&quot;) │ └─→ 注册中断处理程序 向量号 = 0x20 (IRQ0) 处理函数 = timer_interrupt 定时器中断处理 1 2 3 4 5 6 7 /** Timer interrupt handler. */ static void timer_interrupt (struct intr_frame *args UNUSED) { ticks++; thread_tick (); } 每次定时器中断执行的操作： 增加 ticks：全局计时器，记录系统运行的时钟周期数 thread_tick()： 更新线程统计信息 检查时间片是否用完 如果用完，设置 yield_on_return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void thread_tick (void) { struct thread *t = thread_current (); /* Update statistics. */ if (t == idle_thread) idle_ticks++; else if (t-&gt;pagedir != NULL) user_ticks++; else kernel_ticks++; /* Enforce preemption. */ if (++thread_ticks &gt;= TIME_SLICE) intr_yield_on_return (); } 定时器校准 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void timer_calibrate (void) { unsigned high_bit, test_bit; ASSERT (intr_get_level () == INTR_ON); printf (&quot;Calibrating timer... &quot;); /* Approximate loops_per_tick as the largest power-of-two still less than one timer tick. */ loops_per_tick = 1u &lt;&lt; 10; while (!too_many_loops (loops_per_tick &lt;&lt; 1)) { loops_per_tick &lt;&lt;= 1; ASSERT (loops_per_tick != 0); } /* Refine the next 8 bits of loops_per_tick. */ high_bit = loops_per_tick; for (test_bit = high_bit &gt;&gt; 1; test_bit != high_bit &gt;&gt; 10; test_bit &gt;&gt;= 1) if (!too_many_loops (high_bit | test_bit)) loops_per_tick |= test_bit; printf (&quot;%&#39;&quot;PRIu64&quot; loops/s.\n&quot;, (uint64_t) loops_per_tick * TIMER_FREQ); } 校准目的： 测量 CPU 在一个时钟周期内能执行多少次空循环 用于实现 timer_mdelay() 等忙等待函数 在不同速度的 CPU 上提供一致的延迟 校准算法： 1 2 3 4 5 6 7 8 9 10 11 12 13 1. 初始值 = 1024 (2^10) 2. 二分查找最大值： while (loops_per_tick * 2 &lt; 一个 tick 的循环数) loops_per_tick *= 2 结果：找到最大的 2 的幂次 3. 精细调整（8位精度）： 逐位测试，得到更精确的值 示例输出： Calibrating timer... 1,234,567 loops/s. 键盘初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 /* kbd.c */ /** Keyboard data register port. */ #define DATA_REG 0x60 static intr_handler_func keyboard_interrupt; /** Initializes the keyboard. */ void kbd_init (void) { intr_register_ext (0x21, keyboard_interrupt, &quot;8042 Keyboard&quot;); } 8042 键盘控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ┌─────────────────────────────────────────────────────────────┐ │ 8042 键盘控制器 │ │ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输入缓冲 │ ◄── 端口 0x60 写 ◄── │ CPU 命令 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ │ │ │ 控制器 │ │ │ └─────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输出缓冲 │ ─→ 端口 0x60 读 ─→ │ CPU 接收数据 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ IRQ1 (向量 0x21) │ │ │ └─────────────────────────────────────────────────────────────┘ ↑ │ PS/2 协议 ↓ ┌─────────────┐ │ 键盘 │ └─────────────┘ 键盘中断处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void keyboard_interrupt (struct intr_frame *args UNUSED) { /* Must read scancode to clear interrupt. */ uint8_t scancode = inb (DATA_REG); /* 处理扫描码 */ if (scancode &amp; 0x80) { /* 按键释放 */ scancode &amp;= ~0x80; handle_key_release (scancode); } else { /* 按键按下 */ handle_key_press (scancode); } } 扫描码到字符的转换： 1 2 3 4 5 6 扫描码 → 查表 → ASCII 字符 示例： 扫描码 0x1E = &#39;A&#39; (无 Shift) 扫描码 0x1E + Shift = &#39;A&#39; (有 Shift) 扫描码 0x9E = &#39;A&#39; 释放 (0x1E | 0x80) 输入缓冲区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* input.c */ /** Stores a character in the input buffer. */ void input_putc (uint8_t key) { ASSERT (intr_get_level () == INTR_OFF); if (!intq_full (&amp;buffer)) intq_putc (&amp;buffer, key); } /** Retrieves a character from the input buffer. */ uint8_t input_getc (void) { enum intr_level old_level; uint8_t key; old_level = intr_disable (); key = intq_getc (&amp;buffer); intr_set_level (old_level); return key; } 缓冲区结构： 1 2 3 4 5 6 7 8 9 10 写入 (中断上下文) │ ↓ ┌─────────────────────────────┐ buffer: │ a │ b │ c │ │ │ │ │ │ └─────────────────────────────┘ ↑ ↑ head tail │ └── 读取 (进程上下文) 串口初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* serial.c */ /** I/O port base address for the first serial port. */ #define IO_BASE 0x3f8 /** Transmission mode. */ static enum { UNINIT, POLL, QUEUE } mode; /** Initializes the serial port device for polling mode. */ static void init_poll (void) { ASSERT (mode == UNINIT); outb (IER_REG, 0); /* Turn off all interrupts. */ outb (FCR_REG, 0); /* Disable FIFO. */ set_serial (9600); /* 9.6 kbps, N-8-1. */ outb (MCR_REG, MCR_OUT2); /* Required to enable interrupts. */ intq_init (&amp;txq); mode = POLL; } /** Initializes the serial port device for queued mode. */ void serial_init_queue (void) { enum intr_level old_level; if (mode == UNINIT) init_poll (); ASSERT (mode == POLL); intr_register_ext (0x24, serial_interrupt, &quot;16550A Serial&quot;); mode = QUEUE; old_level = intr_disable (); write_ier (); intr_set_level (old_level); } 16550A UART 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌─────────────────────────────────────────────────────────────────┐ │ 16550A UART │ │ │ │ 端口 0x3F8 (DLAB=0): │ │ 读: RBR (接收缓冲) 写: THR (发送保持) │ │ │ │ 端口 0x3F9 (DLAB=0): │ │ 读/写: IER (中断使能) │ │ │ │ 端口 0x3F8 (DLAB=1): │ │ 读/写: DLL (除数锁存低字节) │ │ │ │ 端口 0x3F9 (DLAB=1): │ │ 读/写: DLM (除数锁存高字节) │ │ │ │ 端口 0x3FA: │ │ 读: IIR (中断识别) 写: FCR (FIFO 控制) │ │ │ │ 端口 0x3FB: LCR (线路控制) │ │ 端口 0x3FC: MCR (调制解调器控制) │ │ 端口 0x3FD: LSR (线路状态) [只读] │ │ │ └─────────────────────────────────────────────────────────────────┘ 串口配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void set_serial (int bps) { int base_rate = 1843200 / 16; uint16_t divisor = base_rate / bps; ASSERT (googol &gt;= 300 &amp;&amp; bps &lt;= 115200); /* Enable DLAB. */ outb (LCR_REG, LCR_DLAB); /* Set data rate. */ outb (LS_REG, divisor &amp; 0xff); outb (MS_REG, divisor &gt;&gt; 8); /* Reset DLAB, set N-8-1. */ outb (LCR_REG, LCR_N81); } 波特率计算： 1 2 3 4 基准频率 = 1843200 Hz / 16 = 115200 Hz 除数 = 115200 / 目标波特率 9600 bps: 除数 = 115200 / 9600 = 12 串口模式 模式 描述 使用场景 UNINIT 未初始化 系统启动初期 POLL 轮询模式 中断未启用时 QUEUE 队列模式 正常运行时 轮询模式 vs 队列模式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 轮询模式： serial_putc() │ └─→ 循环等待 THR 空 │ └─→ 写入字符到 THR 队列模式： serial_putc() │ └─→ 写入字符到发送队列 │ └─→ 启用发送中断 │ ↓ (中断触发时) serial_interrupt() │ └─→ 从队列取字符写入 THR 控制台初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* console.c */ static struct lock console_lock; void console_init (void) { lock_init (&amp;console_lock); } void console_print_stats (void) { printf (&quot;Console: %lld characters output\n&quot;, write_cnt); } 控制台输出路径 1 2 3 4 5 6 7 8 9 10 11 printf() / putchar() │ ↓ console_lock │ ↓ ┌────┴────┐ │ │ ↓ ↓ VGA Serial (屏幕) (串口) 多设备输出： 1 2 3 4 5 6 7 8 9 10 /* console.c */ static void putchar_unlocked (uint8_t c) { if (vga_write_to_screen) vga_putc (c); if (serial_write_to_serial) serial_putc (c); write_cnt++; } VGA 初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* vga.c */ /** VGA text screen support. */ /** Number of columns and rows on the text display. */ #define COL_CNT 80 #define ROW_CNT 25 /** Current cursor position. */ static size_t cx, cy; void vga_init (void) { /* 通常不需要特别初始化 */ /* BIOS 已经设置好文本模式 */ } VGA 文本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 VGA 显存地址: 0xB8000 ┌────────────────────────────────────────────────────────────┐ │ 屏幕 (80x25) │ │ │ │ 每个字符占 2 字节: │ │ ┌─────────┬─────────┐ │ │ │ 字符 │ 属性 │ │ │ │ (ASCII) │ (颜色) │ │ │ └─────────┴─────────┘ │ │ │ │ 属性字节: │ │ ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ │ │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │ │ │ │ B │ R │ G │ B │ I │ R │ G │ B │ │ │ │ ← 背景色 →│← 前景色 →│ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ │ │ │ │ B=闪烁, I=高亮, R=红, G=绿, B=蓝 │ │ │ └────────────────────────────────────────────────────────────┘ VGA 输出函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void vga_putc (int c) { /* 处理特殊字符 */ if (c == &#39;\n&#39;) { newline (); } else if (c == &#39;\r&#39;) { cx = 0; } else if (c == &#39;\t&#39;) { do { vga_putc (&#39; &#39;); } while (cx % 8 != 0); } else if (c == &#39;\b&#39;) { if (cx &gt; 0) cx--; } else { /* 普通字符 */ write_char (c); if (++cx &gt;= COL_CNT) { newline (); } } /* 更新硬件光标 */ move_cursor (); } 设备初始化时序 完整初始化流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 pintos_init() │ ├─→ bss_init() // BSS 清零 │ ├─→ read_command_line() // 读取命令行 │ ├─→ thread_init() // 线程系统 │ ├─→ console_init() // 控制台锁 │ │ │ └─→ 此时 printf 可用（轮询模式） │ ├─→ palloc_init() // 页分配器 │ ├─→ malloc_init() // 块分配器 │ ├─→ paging_init() // 永久页表 │ ├─→ intr_init() // 中断系统 │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ ├─→ timer_init() // 定时器 │ │ │ └─→ 注册 IRQ0 (0x20) │ ├─→ kbd_init() // 键盘 │ │ │ └─→ 注册 IRQ1 (0x21) │ ├─→ input_init() // 输入缓冲 │ ├─→ thread_start() // 开始调度 │ │ │ ├─→ 创建空闲线程 │ │ │ └─→ intr_enable() ← 中断开始被处理 │ ├─→ serial_init_queue() // 串口队列模式 │ │ │ └─→ 注册 IRQ4 (0x24) │ └─→ timer_calibrate() // 校准定时器 │ └─→ 测量 loops_per_tick 中断优先级 PIC 默认中断优先级（数字越小优先级越高）： IRQ 向量 设备 优先级 0 0x20 定时器 1（最高） 1 0x21 键盘 2 2 0x22 级联 3 3 0x23 COM2 4 4 0x24 COM1 5 … … … … 常见问题解答 Q1: 为什么定时器要在中断开启前初始化？ A: 配置 PIT 需要写多个端口，必须是原子操作 关中断状态下配置可以防止配置过程中产生中断 注册中断处理程序不需要中断开启 Q2: 为什么串口有两种模式？ A: 轮询模式：系统启动早期，中断未初始化 队列模式：正常运行，不浪费 CPU 等待 Q3: timer_calibrate 必须在中断开启后吗？ A: 是的，需要定时器中断来测量时间 通过等待 ticks 变化来确定循环次数 Q4: 键盘初始化为什么如此简单？ A: 8042 控制器由 BIOS 初始化 只需要注册中断处理程序 键盘硬件已经准备好发送扫描码 练习题 练习1：修改定时器频率 将 TIMER_FREQ 从 100 Hz 改为 1000 Hz： 需要修改哪些代码？ 这对系统有什么影响？ 练习2：实现键盘 LED 控制 实现函数控制键盘 LED（Caps Lock, Num Lock, Scroll Lock）： 1 void kbd_set_leds(bool caps, bool num, bool scroll); 提示：向 8042 发送命令 0xED。 练习3：串口接收 当前代码主要关注串口输出。添加串口输入支持： 在串口中断中处理接收 将接收到的字符放入输入缓冲区 练习4：计算实际定时器频率 给定 PIT_HZ = 1193180 和 TIMER_FREQ = 100： 计算实际的中断频率 计算一小时后的时间误差 下一篇预告 在下一篇文档中，我们将详细解析启动完成和任务执行过程，了解 Pintos 如何从初始化阶段过渡到正常运行，以及如何执行用户指定的命令。 参考资料 Intel 8254 Programmable Interval Timer Datasheet 8042 PS/2 Controller 16550 UART VGA Hardware" />
<meta property="og:description" content="Pintos 内核启动（十四）：设备初始化 概述 本文档详细解析 Pintos 内核的设备初始化过程。在中断系统初始化完成后，内核需要初始化各种硬件设备，使它们能够正常工作。Pintos 涉及的主要设备包括： 定时器（Timer）：提供时间基准和周期性中断 键盘（Keyboard）：处理用户输入 串口（Serial Port）：用于调试输出和通信 控制台（Console）：管理屏幕输出 这些设备的初始化顺序是精心设计的，确保系统能够正确响应硬件事件。 初始化顺序 1 2 3 4 5 6 7 8 9 10 11 12 /* pintos_init() 中的设备初始化顺序 */ /* Initialize interrupt handlers. */ intr_init (); // 中断系统 timer_init (); // 定时器 kbd_init (); // 键盘 input_init (); // 输入缓冲区 /* Start thread scheduler and enable interrupts. */ thread_start (); // 启动调度（开中断） serial_init_queue ();// 串口队列模式 timer_calibrate (); // 定时器校准 初始化时序图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 时间轴 ────────────────────────────────────────────────────→ 中断关闭 │ 中断开启 ─────────────────────────────────│─────────────────────────── │ intr_init() │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ │ timer_init() │ │ │ └─→ 配置 PIT │ 注册定时器中断 │ │ kbd_init() │ │ │ └─→ 注册键盘中断 │ │ input_init() │ │ │ └─→ 初始化输入队列 │ │ thread_start() │ ├─→ 创建空闲线程 │ └─→ intr_enable() │ ↓ 中断开始被处理 serial_init_queue() │ └─→ 启用串口中断 timer_calibrate() │ └─→ 测量 CPU 速度 定时器初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* timer.c */ /** Number of timer ticks since OS booted. */ static int64_t ticks; /** Sets up the timer to interrupt TIMER_FREQ times per second, and registers the corresponding interrupt. */ void timer_init (void) { pit_configure_channel (0, 2, TIMER_FREQ); intr_register_ext (0x20, timer_interrupt, &quot;8254 Timer&quot;); } /* pit.c */ /** 8254 registers. */ #define PIT_PORT_CONTROL 0x43 #define PIT_PORT_COUNTER(CHANNEL) (0x40 + (CHANNEL)) /** PIT cycles per second. */ #define PIT_HZ 1193180 void pit_configure_channel (int channel, int mode, int frequency) { uint16_t count; enum intr_level old_level; ASSERT (channel == 0 || channel == 2); ASSERT (mode == 2 || mode == 3); /* Convert FREQUENCY to a PIT counter value. */ if (frequency &lt; 19) count = 0; else if (frequency &gt; PIT_HZ) count = 2; else count = (PIT_HZ + frequency / 2) / frequency; /* Configure the PIT. */ old_level = intr_disable (); outb (PIT_PORT_CONTROL, ((channel &lt;&lt; 6) | 0x30 | (mode &lt;&lt; 1))); outb (PIT_PORT_COUNTER (channel), count); outb (PIT_PORT_COUNTER (channel), count &gt;&gt; 8); intr_set_level (old_level); } 8254 PIT 硬件架构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌───────────────────────────────────────┐ │ 8254 PIT │ │ │ 时钟输入 ─────────┼─→ CLK (1.193180 MHz) │ (1.193180 MHz) │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │ Channel 0 │ │ Channel 1 │ │ │ │ │ │ │ │ │ │ 计数器 │ │ 计数器 │ │ │ │ │ │ (DRAM) │ │ │ │ OUT0 ───────┼─┼─────────────┼─→ IRQ0 (定时器中断) │ └─────────────┘ └─────────────┘ │ │ │ │ ┌─────────────┐ │ │ │ Channel 2 │ │ │ │ │ │ │ │ 计数器 │ │ │ │ │ │ │ │ OUT2 ───────┼───────────────────→ Speaker │ └─────────────┘ │ │ │ 端口 0x40-0x43 ────┼─→ 控制/数据 │ └───────────────────────────────────────┘ PIT 配置详解 pit_configure_channel() 参数计算： 1 2 3 4 5 6 7 8 /* TIMER_FREQ = 100 Hz (每秒 100 次中断) */ /* PIT_HZ = 1193180 Hz */ count = PIT_HZ / TIMER_FREQ = 1193180 / 100 = 11932 (约) /* 实际频率 = 1193180 / 11932 ≈ 100.007 Hz */ 控制字格式（端口 0x43）： 1 2 3 4 5 6 7 位 7-6: 通道选择 (00=Ch0, 01=Ch1, 10=Ch2) 位 5-4: 访问模式 (11=先低后高) 位 3-1: 工作模式 (010=Mode 2, 011=Mode 3) 位 0: BCD/二进制 (0=二进制) 对于 Channel 0, Mode 2: (0 &lt;&lt; 6) | 0x30 | (2 &lt;&lt; 1) = 0x34 Mode 2（速率发生器）工作原理： 1 2 3 4 5 6 7 8 9 10 计数值 = 11932 时间轴 ─────────────────────────────────────────────→ │←────── 11932 个时钟周期 ──────→│ │ │ OUT ─────┘ ┌┘ ↑ ↑ 计数开始 计数到0 (输出变高) (脉冲，输出变低，然后立即变高) 同时重新加载计数值 timer_init() 流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 timer_init() │ ├─→ pit_configure_channel(0, 2, TIMER_FREQ) │ │ │ ├─→ 计算 count = 11932 │ │ │ ├─→ 关中断（防止配置过程中产生中断） │ │ │ ├─→ outb(0x43, 0x34) // 控制字 │ │ │ ├─→ outb(0x40, 11932 &amp; 0xFF) // 计数值低字节 │ │ │ ├─→ outb(0x40, 11932 &gt;&gt; 8) // 计数值高字节 │ │ │ └─→ 恢复中断状态 │ └─→ intr_register_ext(0x20, timer_interrupt, &quot;8254 Timer&quot;) │ └─→ 注册中断处理程序 向量号 = 0x20 (IRQ0) 处理函数 = timer_interrupt 定时器中断处理 1 2 3 4 5 6 7 /** Timer interrupt handler. */ static void timer_interrupt (struct intr_frame *args UNUSED) { ticks++; thread_tick (); } 每次定时器中断执行的操作： 增加 ticks：全局计时器，记录系统运行的时钟周期数 thread_tick()： 更新线程统计信息 检查时间片是否用完 如果用完，设置 yield_on_return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void thread_tick (void) { struct thread *t = thread_current (); /* Update statistics. */ if (t == idle_thread) idle_ticks++; else if (t-&gt;pagedir != NULL) user_ticks++; else kernel_ticks++; /* Enforce preemption. */ if (++thread_ticks &gt;= TIME_SLICE) intr_yield_on_return (); } 定时器校准 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void timer_calibrate (void) { unsigned high_bit, test_bit; ASSERT (intr_get_level () == INTR_ON); printf (&quot;Calibrating timer... &quot;); /* Approximate loops_per_tick as the largest power-of-two still less than one timer tick. */ loops_per_tick = 1u &lt;&lt; 10; while (!too_many_loops (loops_per_tick &lt;&lt; 1)) { loops_per_tick &lt;&lt;= 1; ASSERT (loops_per_tick != 0); } /* Refine the next 8 bits of loops_per_tick. */ high_bit = loops_per_tick; for (test_bit = high_bit &gt;&gt; 1; test_bit != high_bit &gt;&gt; 10; test_bit &gt;&gt;= 1) if (!too_many_loops (high_bit | test_bit)) loops_per_tick |= test_bit; printf (&quot;%&#39;&quot;PRIu64&quot; loops/s.\n&quot;, (uint64_t) loops_per_tick * TIMER_FREQ); } 校准目的： 测量 CPU 在一个时钟周期内能执行多少次空循环 用于实现 timer_mdelay() 等忙等待函数 在不同速度的 CPU 上提供一致的延迟 校准算法： 1 2 3 4 5 6 7 8 9 10 11 12 13 1. 初始值 = 1024 (2^10) 2. 二分查找最大值： while (loops_per_tick * 2 &lt; 一个 tick 的循环数) loops_per_tick *= 2 结果：找到最大的 2 的幂次 3. 精细调整（8位精度）： 逐位测试，得到更精确的值 示例输出： Calibrating timer... 1,234,567 loops/s. 键盘初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 /* kbd.c */ /** Keyboard data register port. */ #define DATA_REG 0x60 static intr_handler_func keyboard_interrupt; /** Initializes the keyboard. */ void kbd_init (void) { intr_register_ext (0x21, keyboard_interrupt, &quot;8042 Keyboard&quot;); } 8042 键盘控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ┌─────────────────────────────────────────────────────────────┐ │ 8042 键盘控制器 │ │ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输入缓冲 │ ◄── 端口 0x60 写 ◄── │ CPU 命令 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ │ │ │ 控制器 │ │ │ └─────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输出缓冲 │ ─→ 端口 0x60 读 ─→ │ CPU 接收数据 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ IRQ1 (向量 0x21) │ │ │ └─────────────────────────────────────────────────────────────┘ ↑ │ PS/2 协议 ↓ ┌─────────────┐ │ 键盘 │ └─────────────┘ 键盘中断处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void keyboard_interrupt (struct intr_frame *args UNUSED) { /* Must read scancode to clear interrupt. */ uint8_t scancode = inb (DATA_REG); /* 处理扫描码 */ if (scancode &amp; 0x80) { /* 按键释放 */ scancode &amp;= ~0x80; handle_key_release (scancode); } else { /* 按键按下 */ handle_key_press (scancode); } } 扫描码到字符的转换： 1 2 3 4 5 6 扫描码 → 查表 → ASCII 字符 示例： 扫描码 0x1E = &#39;A&#39; (无 Shift) 扫描码 0x1E + Shift = &#39;A&#39; (有 Shift) 扫描码 0x9E = &#39;A&#39; 释放 (0x1E | 0x80) 输入缓冲区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* input.c */ /** Stores a character in the input buffer. */ void input_putc (uint8_t key) { ASSERT (intr_get_level () == INTR_OFF); if (!intq_full (&amp;buffer)) intq_putc (&amp;buffer, key); } /** Retrieves a character from the input buffer. */ uint8_t input_getc (void) { enum intr_level old_level; uint8_t key; old_level = intr_disable (); key = intq_getc (&amp;buffer); intr_set_level (old_level); return key; } 缓冲区结构： 1 2 3 4 5 6 7 8 9 10 写入 (中断上下文) │ ↓ ┌─────────────────────────────┐ buffer: │ a │ b │ c │ │ │ │ │ │ └─────────────────────────────┘ ↑ ↑ head tail │ └── 读取 (进程上下文) 串口初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* serial.c */ /** I/O port base address for the first serial port. */ #define IO_BASE 0x3f8 /** Transmission mode. */ static enum { UNINIT, POLL, QUEUE } mode; /** Initializes the serial port device for polling mode. */ static void init_poll (void) { ASSERT (mode == UNINIT); outb (IER_REG, 0); /* Turn off all interrupts. */ outb (FCR_REG, 0); /* Disable FIFO. */ set_serial (9600); /* 9.6 kbps, N-8-1. */ outb (MCR_REG, MCR_OUT2); /* Required to enable interrupts. */ intq_init (&amp;txq); mode = POLL; } /** Initializes the serial port device for queued mode. */ void serial_init_queue (void) { enum intr_level old_level; if (mode == UNINIT) init_poll (); ASSERT (mode == POLL); intr_register_ext (0x24, serial_interrupt, &quot;16550A Serial&quot;); mode = QUEUE; old_level = intr_disable (); write_ier (); intr_set_level (old_level); } 16550A UART 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌─────────────────────────────────────────────────────────────────┐ │ 16550A UART │ │ │ │ 端口 0x3F8 (DLAB=0): │ │ 读: RBR (接收缓冲) 写: THR (发送保持) │ │ │ │ 端口 0x3F9 (DLAB=0): │ │ 读/写: IER (中断使能) │ │ │ │ 端口 0x3F8 (DLAB=1): │ │ 读/写: DLL (除数锁存低字节) │ │ │ │ 端口 0x3F9 (DLAB=1): │ │ 读/写: DLM (除数锁存高字节) │ │ │ │ 端口 0x3FA: │ │ 读: IIR (中断识别) 写: FCR (FIFO 控制) │ │ │ │ 端口 0x3FB: LCR (线路控制) │ │ 端口 0x3FC: MCR (调制解调器控制) │ │ 端口 0x3FD: LSR (线路状态) [只读] │ │ │ └─────────────────────────────────────────────────────────────────┘ 串口配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void set_serial (int bps) { int base_rate = 1843200 / 16; uint16_t divisor = base_rate / bps; ASSERT (googol &gt;= 300 &amp;&amp; bps &lt;= 115200); /* Enable DLAB. */ outb (LCR_REG, LCR_DLAB); /* Set data rate. */ outb (LS_REG, divisor &amp; 0xff); outb (MS_REG, divisor &gt;&gt; 8); /* Reset DLAB, set N-8-1. */ outb (LCR_REG, LCR_N81); } 波特率计算： 1 2 3 4 基准频率 = 1843200 Hz / 16 = 115200 Hz 除数 = 115200 / 目标波特率 9600 bps: 除数 = 115200 / 9600 = 12 串口模式 模式 描述 使用场景 UNINIT 未初始化 系统启动初期 POLL 轮询模式 中断未启用时 QUEUE 队列模式 正常运行时 轮询模式 vs 队列模式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 轮询模式： serial_putc() │ └─→ 循环等待 THR 空 │ └─→ 写入字符到 THR 队列模式： serial_putc() │ └─→ 写入字符到发送队列 │ └─→ 启用发送中断 │ ↓ (中断触发时) serial_interrupt() │ └─→ 从队列取字符写入 THR 控制台初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* console.c */ static struct lock console_lock; void console_init (void) { lock_init (&amp;console_lock); } void console_print_stats (void) { printf (&quot;Console: %lld characters output\n&quot;, write_cnt); } 控制台输出路径 1 2 3 4 5 6 7 8 9 10 11 printf() / putchar() │ ↓ console_lock │ ↓ ┌────┴────┐ │ │ ↓ ↓ VGA Serial (屏幕) (串口) 多设备输出： 1 2 3 4 5 6 7 8 9 10 /* console.c */ static void putchar_unlocked (uint8_t c) { if (vga_write_to_screen) vga_putc (c); if (serial_write_to_serial) serial_putc (c); write_cnt++; } VGA 初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* vga.c */ /** VGA text screen support. */ /** Number of columns and rows on the text display. */ #define COL_CNT 80 #define ROW_CNT 25 /** Current cursor position. */ static size_t cx, cy; void vga_init (void) { /* 通常不需要特别初始化 */ /* BIOS 已经设置好文本模式 */ } VGA 文本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 VGA 显存地址: 0xB8000 ┌────────────────────────────────────────────────────────────┐ │ 屏幕 (80x25) │ │ │ │ 每个字符占 2 字节: │ │ ┌─────────┬─────────┐ │ │ │ 字符 │ 属性 │ │ │ │ (ASCII) │ (颜色) │ │ │ └─────────┴─────────┘ │ │ │ │ 属性字节: │ │ ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ │ │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │ │ │ │ B │ R │ G │ B │ I │ R │ G │ B │ │ │ │ ← 背景色 →│← 前景色 →│ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ │ │ │ │ B=闪烁, I=高亮, R=红, G=绿, B=蓝 │ │ │ └────────────────────────────────────────────────────────────┘ VGA 输出函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void vga_putc (int c) { /* 处理特殊字符 */ if (c == &#39;\n&#39;) { newline (); } else if (c == &#39;\r&#39;) { cx = 0; } else if (c == &#39;\t&#39;) { do { vga_putc (&#39; &#39;); } while (cx % 8 != 0); } else if (c == &#39;\b&#39;) { if (cx &gt; 0) cx--; } else { /* 普通字符 */ write_char (c); if (++cx &gt;= COL_CNT) { newline (); } } /* 更新硬件光标 */ move_cursor (); } 设备初始化时序 完整初始化流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 pintos_init() │ ├─→ bss_init() // BSS 清零 │ ├─→ read_command_line() // 读取命令行 │ ├─→ thread_init() // 线程系统 │ ├─→ console_init() // 控制台锁 │ │ │ └─→ 此时 printf 可用（轮询模式） │ ├─→ palloc_init() // 页分配器 │ ├─→ malloc_init() // 块分配器 │ ├─→ paging_init() // 永久页表 │ ├─→ intr_init() // 中断系统 │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ ├─→ timer_init() // 定时器 │ │ │ └─→ 注册 IRQ0 (0x20) │ ├─→ kbd_init() // 键盘 │ │ │ └─→ 注册 IRQ1 (0x21) │ ├─→ input_init() // 输入缓冲 │ ├─→ thread_start() // 开始调度 │ │ │ ├─→ 创建空闲线程 │ │ │ └─→ intr_enable() ← 中断开始被处理 │ ├─→ serial_init_queue() // 串口队列模式 │ │ │ └─→ 注册 IRQ4 (0x24) │ └─→ timer_calibrate() // 校准定时器 │ └─→ 测量 loops_per_tick 中断优先级 PIC 默认中断优先级（数字越小优先级越高）： IRQ 向量 设备 优先级 0 0x20 定时器 1（最高） 1 0x21 键盘 2 2 0x22 级联 3 3 0x23 COM2 4 4 0x24 COM1 5 … … … … 常见问题解答 Q1: 为什么定时器要在中断开启前初始化？ A: 配置 PIT 需要写多个端口，必须是原子操作 关中断状态下配置可以防止配置过程中产生中断 注册中断处理程序不需要中断开启 Q2: 为什么串口有两种模式？ A: 轮询模式：系统启动早期，中断未初始化 队列模式：正常运行，不浪费 CPU 等待 Q3: timer_calibrate 必须在中断开启后吗？ A: 是的，需要定时器中断来测量时间 通过等待 ticks 变化来确定循环次数 Q4: 键盘初始化为什么如此简单？ A: 8042 控制器由 BIOS 初始化 只需要注册中断处理程序 键盘硬件已经准备好发送扫描码 练习题 练习1：修改定时器频率 将 TIMER_FREQ 从 100 Hz 改为 1000 Hz： 需要修改哪些代码？ 这对系统有什么影响？ 练习2：实现键盘 LED 控制 实现函数控制键盘 LED（Caps Lock, Num Lock, Scroll Lock）： 1 void kbd_set_leds(bool caps, bool num, bool scroll); 提示：向 8042 发送命令 0xED。 练习3：串口接收 当前代码主要关注串口输出。添加串口输入支持： 在串口中断中处理接收 将接收到的字符放入输入缓冲区 练习4：计算实际定时器频率 给定 PIT_HZ = 1193180 和 TIMER_FREQ = 100： 计算实际的中断频率 计算一小时后的时间误差 下一篇预告 在下一篇文档中，我们将详细解析启动完成和任务执行过程，了解 Pintos 如何从初始化阶段过渡到正常运行，以及如何执行用户指定的命令。 参考资料 Intel 8254 Programmable Interval Timer Datasheet 8042 PS/2 Controller 16550 UART VGA Hardware" />
<link rel="canonical" href="http://localhost:4000/posts/pintos-kernel-14-device-init/" />
<meta property="og:url" content="http://localhost:4000/posts/pintos-kernel-14-device-init/" />
<meta property="og:site_name" content="Zxsheather" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-01-22T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pintos Kernel 14 Device Init" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-22T00:00:00+08:00","datePublished":"2026-01-22T00:00:00+08:00","description":"Pintos 内核启动（十四）：设备初始化 概述 本文档详细解析 Pintos 内核的设备初始化过程。在中断系统初始化完成后，内核需要初始化各种硬件设备，使它们能够正常工作。Pintos 涉及的主要设备包括： 定时器（Timer）：提供时间基准和周期性中断 键盘（Keyboard）：处理用户输入 串口（Serial Port）：用于调试输出和通信 控制台（Console）：管理屏幕输出 这些设备的初始化顺序是精心设计的，确保系统能够正确响应硬件事件。 初始化顺序 1 2 3 4 5 6 7 8 9 10 11 12 /* pintos_init() 中的设备初始化顺序 */ /* Initialize interrupt handlers. */ intr_init (); // 中断系统 timer_init (); // 定时器 kbd_init (); // 键盘 input_init (); // 输入缓冲区 /* Start thread scheduler and enable interrupts. */ thread_start (); // 启动调度（开中断） serial_init_queue ();// 串口队列模式 timer_calibrate (); // 定时器校准 初始化时序图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 时间轴 ────────────────────────────────────────────────────→ 中断关闭 │ 中断开启 ─────────────────────────────────│─────────────────────────── │ intr_init() │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ │ timer_init() │ │ │ └─→ 配置 PIT │ 注册定时器中断 │ │ kbd_init() │ │ │ └─→ 注册键盘中断 │ │ input_init() │ │ │ └─→ 初始化输入队列 │ │ thread_start() │ ├─→ 创建空闲线程 │ └─→ intr_enable() │ ↓ 中断开始被处理 serial_init_queue() │ └─→ 启用串口中断 timer_calibrate() │ └─→ 测量 CPU 速度 定时器初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* timer.c */ /** Number of timer ticks since OS booted. */ static int64_t ticks; /** Sets up the timer to interrupt TIMER_FREQ times per second, and registers the corresponding interrupt. */ void timer_init (void) { pit_configure_channel (0, 2, TIMER_FREQ); intr_register_ext (0x20, timer_interrupt, &quot;8254 Timer&quot;); } /* pit.c */ /** 8254 registers. */ #define PIT_PORT_CONTROL 0x43 #define PIT_PORT_COUNTER(CHANNEL) (0x40 + (CHANNEL)) /** PIT cycles per second. */ #define PIT_HZ 1193180 void pit_configure_channel (int channel, int mode, int frequency) { uint16_t count; enum intr_level old_level; ASSERT (channel == 0 || channel == 2); ASSERT (mode == 2 || mode == 3); /* Convert FREQUENCY to a PIT counter value. */ if (frequency &lt; 19) count = 0; else if (frequency &gt; PIT_HZ) count = 2; else count = (PIT_HZ + frequency / 2) / frequency; /* Configure the PIT. */ old_level = intr_disable (); outb (PIT_PORT_CONTROL, ((channel &lt;&lt; 6) | 0x30 | (mode &lt;&lt; 1))); outb (PIT_PORT_COUNTER (channel), count); outb (PIT_PORT_COUNTER (channel), count &gt;&gt; 8); intr_set_level (old_level); } 8254 PIT 硬件架构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌───────────────────────────────────────┐ │ 8254 PIT │ │ │ 时钟输入 ─────────┼─→ CLK (1.193180 MHz) │ (1.193180 MHz) │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │ Channel 0 │ │ Channel 1 │ │ │ │ │ │ │ │ │ │ 计数器 │ │ 计数器 │ │ │ │ │ │ (DRAM) │ │ │ │ OUT0 ───────┼─┼─────────────┼─→ IRQ0 (定时器中断) │ └─────────────┘ └─────────────┘ │ │ │ │ ┌─────────────┐ │ │ │ Channel 2 │ │ │ │ │ │ │ │ 计数器 │ │ │ │ │ │ │ │ OUT2 ───────┼───────────────────→ Speaker │ └─────────────┘ │ │ │ 端口 0x40-0x43 ────┼─→ 控制/数据 │ └───────────────────────────────────────┘ PIT 配置详解 pit_configure_channel() 参数计算： 1 2 3 4 5 6 7 8 /* TIMER_FREQ = 100 Hz (每秒 100 次中断) */ /* PIT_HZ = 1193180 Hz */ count = PIT_HZ / TIMER_FREQ = 1193180 / 100 = 11932 (约) /* 实际频率 = 1193180 / 11932 ≈ 100.007 Hz */ 控制字格式（端口 0x43）： 1 2 3 4 5 6 7 位 7-6: 通道选择 (00=Ch0, 01=Ch1, 10=Ch2) 位 5-4: 访问模式 (11=先低后高) 位 3-1: 工作模式 (010=Mode 2, 011=Mode 3) 位 0: BCD/二进制 (0=二进制) 对于 Channel 0, Mode 2: (0 &lt;&lt; 6) | 0x30 | (2 &lt;&lt; 1) = 0x34 Mode 2（速率发生器）工作原理： 1 2 3 4 5 6 7 8 9 10 计数值 = 11932 时间轴 ─────────────────────────────────────────────→ │←────── 11932 个时钟周期 ──────→│ │ │ OUT ─────┘ ┌┘ ↑ ↑ 计数开始 计数到0 (输出变高) (脉冲，输出变低，然后立即变高) 同时重新加载计数值 timer_init() 流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 timer_init() │ ├─→ pit_configure_channel(0, 2, TIMER_FREQ) │ │ │ ├─→ 计算 count = 11932 │ │ │ ├─→ 关中断（防止配置过程中产生中断） │ │ │ ├─→ outb(0x43, 0x34) // 控制字 │ │ │ ├─→ outb(0x40, 11932 &amp; 0xFF) // 计数值低字节 │ │ │ ├─→ outb(0x40, 11932 &gt;&gt; 8) // 计数值高字节 │ │ │ └─→ 恢复中断状态 │ └─→ intr_register_ext(0x20, timer_interrupt, &quot;8254 Timer&quot;) │ └─→ 注册中断处理程序 向量号 = 0x20 (IRQ0) 处理函数 = timer_interrupt 定时器中断处理 1 2 3 4 5 6 7 /** Timer interrupt handler. */ static void timer_interrupt (struct intr_frame *args UNUSED) { ticks++; thread_tick (); } 每次定时器中断执行的操作： 增加 ticks：全局计时器，记录系统运行的时钟周期数 thread_tick()： 更新线程统计信息 检查时间片是否用完 如果用完，设置 yield_on_return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void thread_tick (void) { struct thread *t = thread_current (); /* Update statistics. */ if (t == idle_thread) idle_ticks++; else if (t-&gt;pagedir != NULL) user_ticks++; else kernel_ticks++; /* Enforce preemption. */ if (++thread_ticks &gt;= TIME_SLICE) intr_yield_on_return (); } 定时器校准 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void timer_calibrate (void) { unsigned high_bit, test_bit; ASSERT (intr_get_level () == INTR_ON); printf (&quot;Calibrating timer... &quot;); /* Approximate loops_per_tick as the largest power-of-two still less than one timer tick. */ loops_per_tick = 1u &lt;&lt; 10; while (!too_many_loops (loops_per_tick &lt;&lt; 1)) { loops_per_tick &lt;&lt;= 1; ASSERT (loops_per_tick != 0); } /* Refine the next 8 bits of loops_per_tick. */ high_bit = loops_per_tick; for (test_bit = high_bit &gt;&gt; 1; test_bit != high_bit &gt;&gt; 10; test_bit &gt;&gt;= 1) if (!too_many_loops (high_bit | test_bit)) loops_per_tick |= test_bit; printf (&quot;%&#39;&quot;PRIu64&quot; loops/s.\\n&quot;, (uint64_t) loops_per_tick * TIMER_FREQ); } 校准目的： 测量 CPU 在一个时钟周期内能执行多少次空循环 用于实现 timer_mdelay() 等忙等待函数 在不同速度的 CPU 上提供一致的延迟 校准算法： 1 2 3 4 5 6 7 8 9 10 11 12 13 1. 初始值 = 1024 (2^10) 2. 二分查找最大值： while (loops_per_tick * 2 &lt; 一个 tick 的循环数) loops_per_tick *= 2 结果：找到最大的 2 的幂次 3. 精细调整（8位精度）： 逐位测试，得到更精确的值 示例输出： Calibrating timer... 1,234,567 loops/s. 键盘初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 /* kbd.c */ /** Keyboard data register port. */ #define DATA_REG 0x60 static intr_handler_func keyboard_interrupt; /** Initializes the keyboard. */ void kbd_init (void) { intr_register_ext (0x21, keyboard_interrupt, &quot;8042 Keyboard&quot;); } 8042 键盘控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ┌─────────────────────────────────────────────────────────────┐ │ 8042 键盘控制器 │ │ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输入缓冲 │ ◄── 端口 0x60 写 ◄── │ CPU 命令 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ │ │ │ 控制器 │ │ │ └─────────────┘ │ │ │ │ │ ↓ │ │ ┌─────────────┐ ┌─────────────────┐ │ │ │ 输出缓冲 │ ─→ 端口 0x60 读 ─→ │ CPU 接收数据 │ │ │ └─────────────┘ └─────────────────┘ │ │ │ │ │ ↓ │ │ IRQ1 (向量 0x21) │ │ │ └─────────────────────────────────────────────────────────────┘ ↑ │ PS/2 协议 ↓ ┌─────────────┐ │ 键盘 │ └─────────────┘ 键盘中断处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void keyboard_interrupt (struct intr_frame *args UNUSED) { /* Must read scancode to clear interrupt. */ uint8_t scancode = inb (DATA_REG); /* 处理扫描码 */ if (scancode &amp; 0x80) { /* 按键释放 */ scancode &amp;= ~0x80; handle_key_release (scancode); } else { /* 按键按下 */ handle_key_press (scancode); } } 扫描码到字符的转换： 1 2 3 4 5 6 扫描码 → 查表 → ASCII 字符 示例： 扫描码 0x1E = &#39;A&#39; (无 Shift) 扫描码 0x1E + Shift = &#39;A&#39; (有 Shift) 扫描码 0x9E = &#39;A&#39; 释放 (0x1E | 0x80) 输入缓冲区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* input.c */ /** Stores a character in the input buffer. */ void input_putc (uint8_t key) { ASSERT (intr_get_level () == INTR_OFF); if (!intq_full (&amp;buffer)) intq_putc (&amp;buffer, key); } /** Retrieves a character from the input buffer. */ uint8_t input_getc (void) { enum intr_level old_level; uint8_t key; old_level = intr_disable (); key = intq_getc (&amp;buffer); intr_set_level (old_level); return key; } 缓冲区结构： 1 2 3 4 5 6 7 8 9 10 写入 (中断上下文) │ ↓ ┌─────────────────────────────┐ buffer: │ a │ b │ c │ │ │ │ │ │ └─────────────────────────────┘ ↑ ↑ head tail │ └── 读取 (进程上下文) 串口初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* serial.c */ /** I/O port base address for the first serial port. */ #define IO_BASE 0x3f8 /** Transmission mode. */ static enum { UNINIT, POLL, QUEUE } mode; /** Initializes the serial port device for polling mode. */ static void init_poll (void) { ASSERT (mode == UNINIT); outb (IER_REG, 0); /* Turn off all interrupts. */ outb (FCR_REG, 0); /* Disable FIFO. */ set_serial (9600); /* 9.6 kbps, N-8-1. */ outb (MCR_REG, MCR_OUT2); /* Required to enable interrupts. */ intq_init (&amp;txq); mode = POLL; } /** Initializes the serial port device for queued mode. */ void serial_init_queue (void) { enum intr_level old_level; if (mode == UNINIT) init_poll (); ASSERT (mode == POLL); intr_register_ext (0x24, serial_interrupt, &quot;16550A Serial&quot;); mode = QUEUE; old_level = intr_disable (); write_ier (); intr_set_level (old_level); } 16550A UART 寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ┌─────────────────────────────────────────────────────────────────┐ │ 16550A UART │ │ │ │ 端口 0x3F8 (DLAB=0): │ │ 读: RBR (接收缓冲) 写: THR (发送保持) │ │ │ │ 端口 0x3F9 (DLAB=0): │ │ 读/写: IER (中断使能) │ │ │ │ 端口 0x3F8 (DLAB=1): │ │ 读/写: DLL (除数锁存低字节) │ │ │ │ 端口 0x3F9 (DLAB=1): │ │ 读/写: DLM (除数锁存高字节) │ │ │ │ 端口 0x3FA: │ │ 读: IIR (中断识别) 写: FCR (FIFO 控制) │ │ │ │ 端口 0x3FB: LCR (线路控制) │ │ 端口 0x3FC: MCR (调制解调器控制) │ │ 端口 0x3FD: LSR (线路状态) [只读] │ │ │ └─────────────────────────────────────────────────────────────────┘ 串口配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void set_serial (int bps) { int base_rate = 1843200 / 16; uint16_t divisor = base_rate / bps; ASSERT (googol &gt;= 300 &amp;&amp; bps &lt;= 115200); /* Enable DLAB. */ outb (LCR_REG, LCR_DLAB); /* Set data rate. */ outb (LS_REG, divisor &amp; 0xff); outb (MS_REG, divisor &gt;&gt; 8); /* Reset DLAB, set N-8-1. */ outb (LCR_REG, LCR_N81); } 波特率计算： 1 2 3 4 基准频率 = 1843200 Hz / 16 = 115200 Hz 除数 = 115200 / 目标波特率 9600 bps: 除数 = 115200 / 9600 = 12 串口模式 模式 描述 使用场景 UNINIT 未初始化 系统启动初期 POLL 轮询模式 中断未启用时 QUEUE 队列模式 正常运行时 轮询模式 vs 队列模式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 轮询模式： serial_putc() │ └─→ 循环等待 THR 空 │ └─→ 写入字符到 THR 队列模式： serial_putc() │ └─→ 写入字符到发送队列 │ └─→ 启用发送中断 │ ↓ (中断触发时) serial_interrupt() │ └─→ 从队列取字符写入 THR 控制台初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* console.c */ static struct lock console_lock; void console_init (void) { lock_init (&amp;console_lock); } void console_print_stats (void) { printf (&quot;Console: %lld characters output\\n&quot;, write_cnt); } 控制台输出路径 1 2 3 4 5 6 7 8 9 10 11 printf() / putchar() │ ↓ console_lock │ ↓ ┌────┴────┐ │ │ ↓ ↓ VGA Serial (屏幕) (串口) 多设备输出： 1 2 3 4 5 6 7 8 9 10 /* console.c */ static void putchar_unlocked (uint8_t c) { if (vga_write_to_screen) vga_putc (c); if (serial_write_to_serial) serial_putc (c); write_cnt++; } VGA 初始化 原始代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* vga.c */ /** VGA text screen support. */ /** Number of columns and rows on the text display. */ #define COL_CNT 80 #define ROW_CNT 25 /** Current cursor position. */ static size_t cx, cy; void vga_init (void) { /* 通常不需要特别初始化 */ /* BIOS 已经设置好文本模式 */ } VGA 文本模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 VGA 显存地址: 0xB8000 ┌────────────────────────────────────────────────────────────┐ │ 屏幕 (80x25) │ │ │ │ 每个字符占 2 字节: │ │ ┌─────────┬─────────┐ │ │ │ 字符 │ 属性 │ │ │ │ (ASCII) │ (颜色) │ │ │ └─────────┴─────────┘ │ │ │ │ 属性字节: │ │ ┌───┬───┬───┬───┬───┬───┬───┬───┐ │ │ │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │ │ │ │ B │ R │ G │ B │ I │ R │ G │ B │ │ │ │ ← 背景色 →│← 前景色 →│ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ │ │ │ │ B=闪烁, I=高亮, R=红, G=绿, B=蓝 │ │ │ └────────────────────────────────────────────────────────────┘ VGA 输出函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void vga_putc (int c) { /* 处理特殊字符 */ if (c == &#39;\\n&#39;) { newline (); } else if (c == &#39;\\r&#39;) { cx = 0; } else if (c == &#39;\\t&#39;) { do { vga_putc (&#39; &#39;); } while (cx % 8 != 0); } else if (c == &#39;\\b&#39;) { if (cx &gt; 0) cx--; } else { /* 普通字符 */ write_char (c); if (++cx &gt;= COL_CNT) { newline (); } } /* 更新硬件光标 */ move_cursor (); } 设备初始化时序 完整初始化流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 pintos_init() │ ├─→ bss_init() // BSS 清零 │ ├─→ read_command_line() // 读取命令行 │ ├─→ thread_init() // 线程系统 │ ├─→ console_init() // 控制台锁 │ │ │ └─→ 此时 printf 可用（轮询模式） │ ├─→ palloc_init() // 页分配器 │ ├─→ malloc_init() // 块分配器 │ ├─→ paging_init() // 永久页表 │ ├─→ intr_init() // 中断系统 │ │ │ ├─→ pic_init() │ │ │ └─→ 加载 IDT │ ├─→ timer_init() // 定时器 │ │ │ └─→ 注册 IRQ0 (0x20) │ ├─→ kbd_init() // 键盘 │ │ │ └─→ 注册 IRQ1 (0x21) │ ├─→ input_init() // 输入缓冲 │ ├─→ thread_start() // 开始调度 │ │ │ ├─→ 创建空闲线程 │ │ │ └─→ intr_enable() ← 中断开始被处理 │ ├─→ serial_init_queue() // 串口队列模式 │ │ │ └─→ 注册 IRQ4 (0x24) │ └─→ timer_calibrate() // 校准定时器 │ └─→ 测量 loops_per_tick 中断优先级 PIC 默认中断优先级（数字越小优先级越高）： IRQ 向量 设备 优先级 0 0x20 定时器 1（最高） 1 0x21 键盘 2 2 0x22 级联 3 3 0x23 COM2 4 4 0x24 COM1 5 … … … … 常见问题解答 Q1: 为什么定时器要在中断开启前初始化？ A: 配置 PIT 需要写多个端口，必须是原子操作 关中断状态下配置可以防止配置过程中产生中断 注册中断处理程序不需要中断开启 Q2: 为什么串口有两种模式？ A: 轮询模式：系统启动早期，中断未初始化 队列模式：正常运行，不浪费 CPU 等待 Q3: timer_calibrate 必须在中断开启后吗？ A: 是的，需要定时器中断来测量时间 通过等待 ticks 变化来确定循环次数 Q4: 键盘初始化为什么如此简单？ A: 8042 控制器由 BIOS 初始化 只需要注册中断处理程序 键盘硬件已经准备好发送扫描码 练习题 练习1：修改定时器频率 将 TIMER_FREQ 从 100 Hz 改为 1000 Hz： 需要修改哪些代码？ 这对系统有什么影响？ 练习2：实现键盘 LED 控制 实现函数控制键盘 LED（Caps Lock, Num Lock, Scroll Lock）： 1 void kbd_set_leds(bool caps, bool num, bool scroll); 提示：向 8042 发送命令 0xED。 练习3：串口接收 当前代码主要关注串口输出。添加串口输入支持： 在串口中断中处理接收 将接收到的字符放入输入缓冲区 练习4：计算实际定时器频率 给定 PIT_HZ = 1193180 和 TIMER_FREQ = 100： 计算实际的中断频率 计算一小时后的时间误差 下一篇预告 在下一篇文档中，我们将详细解析启动完成和任务执行过程，了解 Pintos 如何从初始化阶段过渡到正常运行，以及如何执行用户指定的命令。 参考资料 Intel 8254 Programmable Interval Timer Datasheet 8042 PS/2 Controller 16550 UART VGA Hardware","headline":"Pintos Kernel 14 Device Init","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/pintos-kernel-14-device-init/"},"url":"http://localhost:4000/posts/pintos-kernel-14-device-init/"}</script>
<!-- End Jekyll SEO tag -->


  <title>Pintos Kernel 14 Device Init | Zxsheather
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">



  <!-- Resource Hints -->
  
    
      
        <link rel="preconnect" href="https://fonts.googleapis.com" >
      
        <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
      
    
      
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      
        <link rel="dns-prefetch" href="https://fonts.gstatic.com" >
      
    
      
        <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      
        <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
      
    
  

  <!-- Bootstrap -->
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css">
  

  <!-- Theme style -->
  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  <!-- Web Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css">

  <!-- 3rd-party Dependencies -->

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Image Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css">
  

  <!-- Scripts -->

  <script src="/assets/js/dist/theme.min.js"></script>

  <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/zh.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script>







<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  



  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/3.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <a class="site-title d-block" href="/">Zxsheather</a>
    <p class="site-subtitle fst-italic mb-0">A CS Undergraduate</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>首页</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>分类</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>标签</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>归档</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>关于</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle">
        <i class="fas fa-adjust"></i>
      </button>

      
    

    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">首页</a>
            </span>

          
        
          
        
          
            
              <span>Pintos Kernel 14 Device Init</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      文章
    </div>

    <button type="button" id="search-trigger" class="btn btn-link" aria-label="Search">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search id="search" class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="搜索..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  

  
  

  




<!-- return -->










<article class="px-1" data-toc="true">
  <header>
    <h1 data-toc-skip>Pintos Kernel 14 Device Init</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        发表于
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1769011200"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2026/01/22
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          作者

          <em>
            
              <a href="https://github.com/zxsheather">Zxsheather</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="3992 字"
>
  <em>22 分钟</em>阅读</span>

        </div>
      </div>
    </div>
  </header>

  
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">Pintos Kernel 14 Device Init</span>
      <button type="button" class="toc-trigger btn me-1">
        <i class="fa-solid fa-list-ul fa-fw"></i>
      </button>
    </div>

    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">文章内容</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>

    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">Pintos Kernel 14 Device Init</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75">
          <i class="fas fa-close"></i>
        </button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  

  <div class="content">
    <h1 id="pintos-内核启动十四设备初始化">Pintos 内核启动（十四）：设备初始化</h1>

<h2 id="概述"><span class="me-2">概述</span><a href="#概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>本文档详细解析 Pintos 内核的设备初始化过程。在中断系统初始化完成后，内核需要初始化各种硬件设备，使它们能够正常工作。Pintos 涉及的主要设备包括：</p>

<ol>
  <li><strong>定时器（Timer）</strong>：提供时间基准和周期性中断</li>
  <li><strong>键盘（Keyboard）</strong>：处理用户输入</li>
  <li><strong>串口（Serial Port）</strong>：用于调试输出和通信</li>
  <li><strong>控制台（Console）</strong>：管理屏幕输出</li>
</ol>

<p>这些设备的初始化顺序是精心设计的，确保系统能够正确响应硬件事件。</p>

<h2 id="初始化顺序"><span class="me-2">初始化顺序</span><a href="#初始化顺序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="cm">/* pintos_init() 中的设备初始化顺序 */</span>

<span class="cm">/* Initialize interrupt handlers. */</span>
<span class="n">intr_init</span> <span class="p">();</span>        <span class="c1">// 中断系统</span>
<span class="n">timer_init</span> <span class="p">();</span>       <span class="c1">// 定时器</span>
<span class="n">kbd_init</span> <span class="p">();</span>         <span class="c1">// 键盘</span>
<span class="n">input_init</span> <span class="p">();</span>       <span class="c1">// 输入缓冲区</span>

<span class="cm">/* Start thread scheduler and enable interrupts. */</span>
<span class="n">thread_start</span> <span class="p">();</span>     <span class="c1">// 启动调度（开中断）</span>
<span class="n">serial_init_queue</span> <span class="p">();</span><span class="c1">// 串口队列模式</span>
<span class="n">timer_calibrate</span> <span class="p">();</span>  <span class="c1">// 定时器校准</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>初始化时序图</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>时间轴 ────────────────────────────────────────────────────→

中断关闭                           │  中断开启
─────────────────────────────────│───────────────────────────
                                  │
intr_init()                       │
    │                             │
    ├─→ pic_init()               │
    │                             │
    └─→ 加载 IDT                  │
                                  │
timer_init()                      │
    │                             │
    └─→ 配置 PIT                  │
        注册定时器中断            │
                                  │
kbd_init()                        │
    │                             │
    └─→ 注册键盘中断              │
                                  │
input_init()                      │
    │                             │
    └─→ 初始化输入队列            │
                                  │
                              thread_start()
                                  │
                                  ├─→ 创建空闲线程
                                  │
                                  └─→ intr_enable()
                                        │
                                        ↓ 中断开始被处理
                                        
                              serial_init_queue()
                                  │
                                  └─→ 启用串口中断
                                  
                              timer_calibrate()
                                  │
                                  └─→ 测量 CPU 速度
</pre></td></tr></tbody></table></code></div></div>

<h2 id="定时器初始化"><span class="me-2">定时器初始化</span><a href="#定时器初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="原始代码"><span class="me-2">原始代码</span><a href="#原始代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="cm">/* timer.c */</span>

<span class="cm">/** Number of timer ticks since OS booted. */</span>
<span class="k">static</span> <span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">;</span>

<span class="cm">/** Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */</span>
<span class="kt">void</span>
<span class="nf">timer_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">pit_configure_channel</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">TIMER_FREQ</span><span class="p">);</span>
  <span class="n">intr_register_ext</span> <span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">timer_interrupt</span><span class="p">,</span> <span class="s">"8254 Timer"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pit.c */</span>

<span class="cm">/** 8254 registers. */</span>
<span class="cp">#define PIT_PORT_CONTROL          0x43
#define PIT_PORT_COUNTER(CHANNEL) (0x40 + (CHANNEL))
</span>
<span class="cm">/** PIT cycles per second. */</span>
<span class="cp">#define PIT_HZ 1193180
</span>
<span class="kt">void</span>
<span class="nf">pit_configure_channel</span> <span class="p">(</span><span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frequency</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">channel</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">channel</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

  <span class="cm">/* Convert FREQUENCY to a PIT counter value. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="mi">19</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">PIT_HZ</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIT_HZ</span> <span class="o">+</span> <span class="n">frequency</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">;</span>

  <span class="cm">/* Configure the PIT. */</span>
  <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">PIT_PORT_CONTROL</span><span class="p">,</span> <span class="p">((</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x30</span> <span class="o">|</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)));</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">PIT_PORT_COUNTER</span> <span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">PIT_PORT_COUNTER</span> <span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">count</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
  <span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="8254-pit-硬件架构"><span class="me-2">8254 PIT 硬件架构</span><a href="#8254-pit-硬件架构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>                    ┌───────────────────────────────────────┐
                    │           8254 PIT                    │
                    │                                       │
  时钟输入 ─────────┼─→ CLK (1.193180 MHz)                  │
  (1.193180 MHz)    │                                       │
                    │ ┌─────────────┐ ┌─────────────┐       │
                    │ │  Channel 0  │ │  Channel 1  │       │
                    │ │             │ │             │       │
                    │ │ 计数器      │ │ 计数器      │       │
                    │ │             │ │   (DRAM)    │       │
                    │ │ OUT0 ───────┼─┼─────────────┼─→ IRQ0 (定时器中断)
                    │ └─────────────┘ └─────────────┘       │
                    │                                       │
                    │ ┌─────────────┐                       │
                    │ │  Channel 2  │                       │
                    │ │             │                       │
                    │ │ 计数器      │                       │
                    │ │             │                       │
                    │ │ OUT2 ───────┼───────────────────→ Speaker
                    │ └─────────────┘                       │
                    │                                       │
端口 0x40-0x43 ────┼─→ 控制/数据                           │
                    └───────────────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="pit-配置详解"><span class="me-2">PIT 配置详解</span><a href="#pit-配置详解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>pit_configure_channel() 参数计算</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="cm">/* TIMER_FREQ = 100 Hz (每秒 100 次中断) */</span>
<span class="cm">/* PIT_HZ = 1193180 Hz */</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">PIT_HZ</span> <span class="o">/</span> <span class="n">TIMER_FREQ</span>
      <span class="o">=</span> <span class="mi">1193180</span> <span class="o">/</span> <span class="mi">100</span>
      <span class="o">=</span> <span class="mi">11932</span> <span class="p">(</span><span class="err">约</span><span class="p">)</span>

<span class="cm">/* 实际频率 = 1193180 / 11932 ≈ 100.007 Hz */</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>控制字格式</strong>（端口 0x43）：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>位 7-6: 通道选择 (00=Ch0, 01=Ch1, 10=Ch2)
位 5-4: 访问模式 (11=先低后高)
位 3-1: 工作模式 (010=Mode 2, 011=Mode 3)
位 0:   BCD/二进制 (0=二进制)

对于 Channel 0, Mode 2:
(0 &lt;&lt; 6) | 0x30 | (2 &lt;&lt; 1) = 0x34
</pre></td></tr></tbody></table></code></div></div>

<p><strong>Mode 2（速率发生器）工作原理</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>计数值 = 11932

时间轴 ─────────────────────────────────────────────→
         │←────── 11932 个时钟周期 ──────→│
         │                                │
OUT ─────┘                               ┌┘
         ↑                               ↑
      计数开始                        计数到0
      (输出变高)                      (脉冲，输出变低，然后立即变高)
                                      同时重新加载计数值
</pre></td></tr></tbody></table></code></div></div>

<h3 id="timer_init-流程"><span class="me-2">timer_init() 流程</span><a href="#timer_init-流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>timer_init()
    │
    ├─→ pit_configure_channel(0, 2, TIMER_FREQ)
    │   │
    │   ├─→ 计算 count = 11932
    │   │
    │   ├─→ 关中断（防止配置过程中产生中断）
    │   │
    │   ├─→ outb(0x43, 0x34)  // 控制字
    │   │
    │   ├─→ outb(0x40, 11932 &amp; 0xFF)  // 计数值低字节
    │   │
    │   ├─→ outb(0x40, 11932 &gt;&gt; 8)    // 计数值高字节
    │   │
    │   └─→ 恢复中断状态
    │
    └─→ intr_register_ext(0x20, timer_interrupt, "8254 Timer")
        │
        └─→ 注册中断处理程序
            向量号 = 0x20 (IRQ0)
            处理函数 = timer_interrupt
</pre></td></tr></tbody></table></code></div></div>

<h3 id="定时器中断处理"><span class="me-2">定时器中断处理</span><a href="#定时器中断处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="cm">/** Timer interrupt handler. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">timer_interrupt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">intr_frame</span> <span class="o">*</span><span class="n">args</span> <span class="n">UNUSED</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
  <span class="n">thread_tick</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>每次定时器中断执行的操作</strong>：</p>

<ol>
  <li><strong>增加 ticks</strong>：全局计时器，记录系统运行的时钟周期数</li>
  <li><strong>thread_tick()</strong>：
    <ul>
      <li>更新线程统计信息</li>
      <li>检查时间片是否用完</li>
      <li>如果用完，设置 <code class="language-plaintext highlighter-rouge">yield_on_return</code></li>
    </ul>
  </li>
</ol>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">thread_tick</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">thread_current</span> <span class="p">();</span>

  <span class="cm">/* Update statistics. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">idle_thread</span><span class="p">)</span>
    <span class="n">idle_ticks</span><span class="o">++</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pagedir</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">user_ticks</span><span class="o">++</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">kernel_ticks</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* Enforce preemption. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">thread_ticks</span> <span class="o">&gt;=</span> <span class="n">TIME_SLICE</span><span class="p">)</span>
    <span class="n">intr_yield_on_return</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="定时器校准"><span class="me-2">定时器校准</span><a href="#定时器校准" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">timer_calibrate</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">high_bit</span><span class="p">,</span> <span class="n">test_bit</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_ON</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Calibrating timer...  "</span><span class="p">);</span>

  <span class="cm">/* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */</span>
  <span class="n">loops_per_tick</span> <span class="o">=</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">too_many_loops</span> <span class="p">(</span><span class="n">loops_per_tick</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> 
    <span class="p">{</span>
      <span class="n">loops_per_tick</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">ASSERT</span> <span class="p">(</span><span class="n">loops_per_tick</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* Refine the next 8 bits of loops_per_tick. */</span>
  <span class="n">high_bit</span> <span class="o">=</span> <span class="n">loops_per_tick</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">test_bit</span> <span class="o">=</span> <span class="n">high_bit</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">test_bit</span> <span class="o">!=</span> <span class="n">high_bit</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">test_bit</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">too_many_loops</span> <span class="p">(</span><span class="n">high_bit</span> <span class="o">|</span> <span class="n">test_bit</span><span class="p">))</span>
      <span class="n">loops_per_tick</span> <span class="o">|=</span> <span class="n">test_bit</span><span class="p">;</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"%'"</span><span class="n">PRIu64</span><span class="s">" loops/s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">loops_per_tick</span> <span class="o">*</span> <span class="n">TIMER_FREQ</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>校准目的</strong>：</p>

<ul>
  <li>测量 CPU 在一个时钟周期内能执行多少次空循环</li>
  <li>用于实现 <code class="language-plaintext highlighter-rouge">timer_mdelay()</code> 等忙等待函数</li>
  <li>在不同速度的 CPU 上提供一致的延迟</li>
</ul>

<p><strong>校准算法</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>1. 初始值 = 1024 (2^10)

2. 二分查找最大值：
   while (loops_per_tick * 2 &lt; 一个 tick 的循环数)
       loops_per_tick *= 2
   
   结果：找到最大的 2 的幂次

3. 精细调整（8位精度）：
   逐位测试，得到更精确的值

示例输出：
Calibrating timer...  1,234,567 loops/s.
</pre></td></tr></tbody></table></code></div></div>

<h2 id="键盘初始化"><span class="me-2">键盘初始化</span><a href="#键盘初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="原始代码-1"><span class="me-2">原始代码</span><a href="#原始代码-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="cm">/* kbd.c */</span>

<span class="cm">/** Keyboard data register port. */</span>
<span class="cp">#define DATA_REG 0x60
</span>
<span class="k">static</span> <span class="n">intr_handler_func</span> <span class="n">keyboard_interrupt</span><span class="p">;</span>

<span class="cm">/** Initializes the keyboard. */</span>
<span class="kt">void</span>
<span class="nf">kbd_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">intr_register_ext</span> <span class="p">(</span><span class="mh">0x21</span><span class="p">,</span> <span class="n">keyboard_interrupt</span><span class="p">,</span> <span class="s">"8042 Keyboard"</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="8042-键盘控制器"><span class="me-2">8042 键盘控制器</span><a href="#8042-键盘控制器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>┌─────────────────────────────────────────────────────────────┐
│                     8042 键盘控制器                          │
│                                                             │
│  ┌─────────────┐                      ┌─────────────────┐  │
│  │   输入缓冲   │ ◄── 端口 0x60 写 ◄── │  CPU 命令       │  │
│  └─────────────┘                      └─────────────────┘  │
│          │                                                  │
│          ↓                                                  │
│  ┌─────────────┐                                           │
│  │   控制器     │                                           │
│  └─────────────┘                                           │
│          │                                                  │
│          ↓                                                  │
│  ┌─────────────┐                      ┌─────────────────┐  │
│  │   输出缓冲   │ ─→ 端口 0x60 读 ─→  │  CPU 接收数据   │  │
│  └─────────────┘                      └─────────────────┘  │
│          │                                                  │
│          ↓                                                  │
│      IRQ1 (向量 0x21)                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
            ↑
            │ PS/2 协议
            ↓
      ┌─────────────┐
      │   键盘      │
      └─────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="键盘中断处理"><span class="me-2">键盘中断处理</span><a href="#键盘中断处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">keyboard_interrupt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">intr_frame</span> <span class="o">*</span><span class="n">args</span> <span class="n">UNUSED</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="cm">/* Must read scancode to clear interrupt. */</span>
  <span class="kt">uint8_t</span> <span class="n">scancode</span> <span class="o">=</span> <span class="n">inb</span> <span class="p">(</span><span class="n">DATA_REG</span><span class="p">);</span>
  
  <span class="cm">/* 处理扫描码 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">scancode</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 按键释放 */</span>
    <span class="n">scancode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">;</span>
    <span class="n">handle_key_release</span> <span class="p">(</span><span class="n">scancode</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* 按键按下 */</span>
    <span class="n">handle_key_press</span> <span class="p">(</span><span class="n">scancode</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>扫描码到字符的转换</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>扫描码 → 查表 → ASCII 字符

示例：
扫描码 0x1E = 'A' (无 Shift)
扫描码 0x1E + Shift = 'A' (有 Shift)
扫描码 0x9E = 'A' 释放 (0x1E | 0x80)
</pre></td></tr></tbody></table></code></div></div>

<h3 id="输入缓冲区"><span class="me-2">输入缓冲区</span><a href="#输入缓冲区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="cm">/* input.c */</span>

<span class="cm">/** Stores a character in the input buffer. */</span>
<span class="kt">void</span>
<span class="nf">input_putc</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intq_full</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">))</span>
    <span class="n">intq_putc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/** Retrieves a character from the input buffer. */</span>
<span class="kt">uint8_t</span>
<span class="nf">input_getc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">key</span><span class="p">;</span>

  <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
  <span class="n">key</span> <span class="o">=</span> <span class="n">intq_getc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
  <span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>缓冲区结构</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>              写入 (中断上下文)
                   │
                   ↓
         ┌─────────────────────────────┐
buffer:  │ a │ b │ c │   │   │   │   │ │
         └─────────────────────────────┘
           ↑                       ↑
          head                    tail
           │
           └── 读取 (进程上下文)
</pre></td></tr></tbody></table></code></div></div>

<h2 id="串口初始化"><span class="me-2">串口初始化</span><a href="#串口初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="原始代码-2"><span class="me-2">原始代码</span><a href="#原始代码-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="cm">/* serial.c */</span>

<span class="cm">/** I/O port base address for the first serial port. */</span>
<span class="cp">#define IO_BASE 0x3f8
</span>
<span class="cm">/** Transmission mode. */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">UNINIT</span><span class="p">,</span> <span class="n">POLL</span><span class="p">,</span> <span class="n">QUEUE</span> <span class="p">}</span> <span class="n">mode</span><span class="p">;</span>

<span class="cm">/** Initializes the serial port device for polling mode. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_poll</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UNINIT</span><span class="p">);</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">IER_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                    <span class="cm">/* Turn off all interrupts. */</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">FCR_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                    <span class="cm">/* Disable FIFO. */</span>
  <span class="n">set_serial</span> <span class="p">(</span><span class="mi">9600</span><span class="p">);</span>                    <span class="cm">/* 9.6 kbps, N-8-1. */</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">MCR_REG</span><span class="p">,</span> <span class="n">MCR_OUT2</span><span class="p">);</span>             <span class="cm">/* Required to enable interrupts. */</span>
  <span class="n">intq_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="p">);</span>
  <span class="n">mode</span> <span class="o">=</span> <span class="n">POLL</span><span class="p">;</span>
<span class="p">}</span> 

<span class="cm">/** Initializes the serial port device for queued mode. */</span>
<span class="kt">void</span>
<span class="nf">serial_init_queue</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UNINIT</span><span class="p">)</span>
    <span class="n">init_poll</span> <span class="p">();</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">POLL</span><span class="p">);</span>

  <span class="n">intr_register_ext</span> <span class="p">(</span><span class="mh">0x24</span><span class="p">,</span> <span class="n">serial_interrupt</span><span class="p">,</span> <span class="s">"16550A Serial"</span><span class="p">);</span>
  <span class="n">mode</span> <span class="o">=</span> <span class="n">QUEUE</span><span class="p">;</span>
  <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
  <span class="n">write_ier</span> <span class="p">();</span>
  <span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="16550a-uart-寄存器"><span class="me-2">16550A UART 寄存器</span><a href="#16550a-uart-寄存器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>┌─────────────────────────────────────────────────────────────────┐
│                      16550A UART                                │
│                                                                 │
│  端口 0x3F8 (DLAB=0):                                           │
│    读: RBR (接收缓冲)     写: THR (发送保持)                    │
│                                                                 │
│  端口 0x3F9 (DLAB=0):                                           │
│    读/写: IER (中断使能)                                        │
│                                                                 │
│  端口 0x3F8 (DLAB=1):                                           │
│    读/写: DLL (除数锁存低字节)                                  │
│                                                                 │
│  端口 0x3F9 (DLAB=1):                                           │
│    读/写: DLM (除数锁存高字节)                                  │
│                                                                 │
│  端口 0x3FA:                                                    │
│    读: IIR (中断识别)     写: FCR (FIFO 控制)                   │
│                                                                 │
│  端口 0x3FB: LCR (线路控制)                                     │
│  端口 0x3FC: MCR (调制解调器控制)                               │
│  端口 0x3FD: LSR (线路状态) [只读]                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="串口配置"><span class="me-2">串口配置</span><a href="#串口配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">set_serial</span> <span class="p">(</span><span class="kt">int</span> <span class="n">bps</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">base_rate</span> <span class="o">=</span> <span class="mi">1843200</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">base_rate</span> <span class="o">/</span> <span class="n">bps</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">googol</span> <span class="o">&gt;=</span> <span class="mi">300</span> <span class="o">&amp;&amp;</span> <span class="n">bps</span> <span class="o">&lt;=</span> <span class="mi">115200</span><span class="p">);</span>

  <span class="cm">/* Enable DLAB. */</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">LCR_REG</span><span class="p">,</span> <span class="n">LCR_DLAB</span><span class="p">);</span>

  <span class="cm">/* Set data rate. */</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">LS_REG</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">MS_REG</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

  <span class="cm">/* Reset DLAB, set N-8-1. */</span>
  <span class="n">outb</span> <span class="p">(</span><span class="n">LCR_REG</span><span class="p">,</span> <span class="n">LCR_N81</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>波特率计算</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>基准频率 = 1843200 Hz / 16 = 115200 Hz
除数 = 115200 / 目标波特率

9600 bps: 除数 = 115200 / 9600 = 12
</pre></td></tr></tbody></table></code></div></div>

<h3 id="串口模式"><span class="me-2">串口模式</span><a href="#串口模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>模式</th>
      <th>描述</th>
      <th>使用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>UNINIT</td>
      <td>未初始化</td>
      <td>系统启动初期</td>
    </tr>
    <tr>
      <td>POLL</td>
      <td>轮询模式</td>
      <td>中断未启用时</td>
    </tr>
    <tr>
      <td>QUEUE</td>
      <td>队列模式</td>
      <td>正常运行时</td>
    </tr>
  </tbody>
</table></div>

<p><strong>轮询模式 vs 队列模式</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>轮询模式：
  serial_putc()
      │
      └─→ 循环等待 THR 空
          │
          └─→ 写入字符到 THR

队列模式：
  serial_putc()
      │
      └─→ 写入字符到发送队列
          │
          └─→ 启用发送中断
              │
              ↓ (中断触发时)
          serial_interrupt()
              │
              └─→ 从队列取字符写入 THR
</pre></td></tr></tbody></table></code></div></div>

<h2 id="控制台初始化"><span class="me-2">控制台初始化</span><a href="#控制台初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="原始代码-3"><span class="me-2">原始代码</span><a href="#原始代码-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="cm">/* console.c */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock</span> <span class="n">console_lock</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">console_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">console_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">console_print_stats</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Console: %lld characters output</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">write_cnt</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="控制台输出路径"><span class="me-2">控制台输出路径</span><a href="#控制台输出路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>printf() / putchar()
        │
        ↓
    console_lock
        │
        ↓
   ┌────┴────┐
   │         │
   ↓         ↓
  VGA     Serial
(屏幕)    (串口)
</pre></td></tr></tbody></table></code></div></div>

<p><strong>多设备输出</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="cm">/* console.c */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">putchar_unlocked</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vga_write_to_screen</span><span class="p">)</span>
    <span class="n">vga_putc</span> <span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">serial_write_to_serial</span><span class="p">)</span>
    <span class="n">serial_putc</span> <span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">write_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="vga-初始化"><span class="me-2">VGA 初始化</span><a href="#vga-初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="原始代码-4"><span class="me-2">原始代码</span><a href="#原始代码-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="cm">/* vga.c */</span>

<span class="cm">/** VGA text screen support. */</span>

<span class="cm">/** Number of columns and rows on the text display. */</span>
<span class="cp">#define COL_CNT 80
#define ROW_CNT 25
</span>
<span class="cm">/** Current cursor position. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">vga_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* 通常不需要特别初始化 */</span>
  <span class="cm">/* BIOS 已经设置好文本模式 */</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="vga-文本模式"><span class="me-2">VGA 文本模式</span><a href="#vga-文本模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>VGA 显存地址: 0xB8000

┌────────────────────────────────────────────────────────────┐
│                     屏幕 (80x25)                            │
│                                                            │
│  每个字符占 2 字节:                                         │
│  ┌─────────┬─────────┐                                     │
│  │ 字符    │ 属性    │                                     │
│  │ (ASCII) │ (颜色)  │                                     │
│  └─────────┴─────────┘                                     │
│                                                            │
│  属性字节:                                                  │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                        │
│  │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │                        │
│  │ B │ R │ G │ B │ I │ R │ G │ B │                        │
│  │ ← 背景色  →│← 前景色    →│                              │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                        │
│                                                            │
│  B=闪烁, I=高亮, R=红, G=绿, B=蓝                          │
│                                                            │
└────────────────────────────────────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="vga-输出函数"><span class="me-2">VGA 输出函数</span><a href="#vga-输出函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">vga_putc</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* 处理特殊字符 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">newline</span> <span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\r'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\t'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">vga_putc</span> <span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cx</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'\b'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">cx</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* 普通字符 */</span>
    <span class="n">write_char</span> <span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cx</span> <span class="o">&gt;=</span> <span class="n">COL_CNT</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">newline</span> <span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="cm">/* 更新硬件光标 */</span>
  <span class="n">move_cursor</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="设备初始化时序"><span class="me-2">设备初始化时序</span><a href="#设备初始化时序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="完整初始化流程"><span class="me-2">完整初始化流程</span><a href="#完整初始化流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre>pintos_init()
    │
    ├─→ bss_init()          // BSS 清零
    │
    ├─→ read_command_line() // 读取命令行
    │
    ├─→ thread_init()       // 线程系统
    │
    ├─→ console_init()      // 控制台锁
    │       │
    │       └─→ 此时 printf 可用（轮询模式）
    │
    ├─→ palloc_init()       // 页分配器
    │
    ├─→ malloc_init()       // 块分配器
    │
    ├─→ paging_init()       // 永久页表
    │
    ├─→ intr_init()         // 中断系统
    │       │
    │       ├─→ pic_init()
    │       │
    │       └─→ 加载 IDT
    │
    ├─→ timer_init()        // 定时器
    │       │
    │       └─→ 注册 IRQ0 (0x20)
    │
    ├─→ kbd_init()          // 键盘
    │       │
    │       └─→ 注册 IRQ1 (0x21)
    │
    ├─→ input_init()        // 输入缓冲
    │
    ├─→ thread_start()      // 开始调度
    │       │
    │       ├─→ 创建空闲线程
    │       │
    │       └─→ intr_enable()  ← 中断开始被处理
    │
    ├─→ serial_init_queue() // 串口队列模式
    │       │
    │       └─→ 注册 IRQ4 (0x24)
    │
    └─→ timer_calibrate()   // 校准定时器
            │
            └─→ 测量 loops_per_tick
</pre></td></tr></tbody></table></code></div></div>

<h3 id="中断优先级"><span class="me-2">中断优先级</span><a href="#中断优先级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>PIC 默认中断优先级（数字越小优先级越高）：</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>IRQ</th>
      <th>向量</th>
      <th>设备</th>
      <th>优先级</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0x20</td>
      <td>定时器</td>
      <td>1（最高）</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0x21</td>
      <td>键盘</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0x22</td>
      <td>级联</td>
      <td>3</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0x23</td>
      <td>COM2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>4</td>
      <td>0x24</td>
      <td>COM1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table></div>

<h2 id="常见问题解答"><span class="me-2">常见问题解答</span><a href="#常见问题解答" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="q1-为什么定时器要在中断开启前初始化"><span class="me-2">Q1: 为什么定时器要在中断开启前初始化？</span><a href="#q1-为什么定时器要在中断开启前初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ul>
  <li>配置 PIT 需要写多个端口，必须是原子操作</li>
  <li>关中断状态下配置可以防止配置过程中产生中断</li>
  <li>注册中断处理程序不需要中断开启</li>
</ul>

<h3 id="q2-为什么串口有两种模式"><span class="me-2">Q2: 为什么串口有两种模式？</span><a href="#q2-为什么串口有两种模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ul>
  <li>轮询模式：系统启动早期，中断未初始化</li>
  <li>队列模式：正常运行，不浪费 CPU 等待</li>
</ul>

<h3 id="q3-timer_calibrate-必须在中断开启后吗"><span class="me-2">Q3: timer_calibrate 必须在中断开启后吗？</span><a href="#q3-timer_calibrate-必须在中断开启后吗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ul>
  <li>是的，需要定时器中断来测量时间</li>
  <li>通过等待 ticks 变化来确定循环次数</li>
</ul>

<h3 id="q4-键盘初始化为什么如此简单"><span class="me-2">Q4: 键盘初始化为什么如此简单？</span><a href="#q4-键盘初始化为什么如此简单" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ul>
  <li>8042 控制器由 BIOS 初始化</li>
  <li>只需要注册中断处理程序</li>
  <li>键盘硬件已经准备好发送扫描码</li>
</ul>

<h2 id="练习题"><span class="me-2">练习题</span><a href="#练习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="练习1修改定时器频率"><span class="me-2">练习1：修改定时器频率</span><a href="#练习1修改定时器频率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>将 TIMER_FREQ 从 100 Hz 改为 1000 Hz：</p>
<ol>
  <li>需要修改哪些代码？</li>
  <li>这对系统有什么影响？</li>
</ol>

<h3 id="练习2实现键盘-led-控制"><span class="me-2">练习2：实现键盘 LED 控制</span><a href="#练习2实现键盘-led-控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>实现函数控制键盘 LED（Caps Lock, Num Lock, Scroll Lock）：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">kbd_set_leds</span><span class="p">(</span><span class="n">bool</span> <span class="n">caps</span><span class="p">,</span> <span class="n">bool</span> <span class="n">num</span><span class="p">,</span> <span class="n">bool</span> <span class="n">scroll</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>提示</strong>：向 8042 发送命令 0xED。</p>

<h3 id="练习3串口接收"><span class="me-2">练习3：串口接收</span><a href="#练习3串口接收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>当前代码主要关注串口输出。添加串口输入支持：</p>
<ol>
  <li>在串口中断中处理接收</li>
  <li>将接收到的字符放入输入缓冲区</li>
</ol>

<h3 id="练习4计算实际定时器频率"><span class="me-2">练习4：计算实际定时器频率</span><a href="#练习4计算实际定时器频率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>给定 PIT_HZ = 1193180 和 TIMER_FREQ = 100：</p>
<ol>
  <li>计算实际的中断频率</li>
  <li>计算一小时后的时间误差</li>
</ol>

<h2 id="下一篇预告"><span class="me-2">下一篇预告</span><a href="#下一篇预告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>在下一篇文档中，我们将详细解析启动完成和任务执行过程，了解 Pintos 如何从初始化阶段过渡到正常运行，以及如何执行用户指定的命令。</p>

<h2 id="参考资料"><span class="me-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<ol>
  <li><a href="https://www.scs.stanford.edu/10wi-cs140/pintos/specs/8254.pdf">Intel 8254 Programmable Interval Timer Datasheet</a></li>
  <li><a href="https://wiki.osdev.org/%228042%22_PS/2_Controller">8042 PS/2 Controller</a></li>
  <li><a href="https://wiki.osdev.org/Serial_Ports">16550 UART</a></li>
  <li><a href="https://wiki.osdev.org/VGA_Hardware">VGA Hardware</a></li>
</ol>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">分享</span>
  <span class="share-icons">
    
    
    

    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="分享链接"
      data-title-succeed="链接已复制！"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">最近更新</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-03-create/">Pintos 线程系统详解（三）：线程创建</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-04-schedule/">Pintos 线程系统详解（四）：线程调度</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-05-switch/">Pintos 线程系统详解（五）：上下文切换</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-06-block-unblock/">Pintos 线程系统详解（六）：阻塞与唤醒</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-07-semaphore/">Pintos 线程系统详解（七）：信号量</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


            </div>

            
              
              






  <div class="toc-border-cover z-3"></div>
  <section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4">
    <h2 class="panel-heading ps-3 pb-2 mb-0">文章内容</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->


























            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/pintos-kernel-13-interrupt-init/"
      class="btn btn-outline-primary"
      aria-label="上一篇"
    >
      <p>Pintos Kernel 13 Interrupt Init</p>
    </a>
  

  
    <a
      href="/posts/pintos-kernel-15-boot-complete/"
      class="btn btn-outline-primary"
      aria-label="下一篇"
    >
      <p>Pintos Kernel 15 Boot Complete</p>
    </a>
  
</nav>

            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2026</time>

    
      <a href="https://github.com/zxsheather">Zxsheather</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"
      >保留部分权利。</span>
    
  </p>

  <p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v7.4.1"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center d-none">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">发现新版本的内容。</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      更新
    </button>
  </div>
</aside>

    

    <!-- Embedded scripts -->

    
      
      <!-- The comments switcher -->


    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  
  document.addEventListener('DOMContentLoaded', () => {
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('search-results'),
      json: '/assets/js/data/search.json',
      searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{content}</p>  </article>',
      noResultsText: '<p class="mt-5">搜索结果为空</p>',
      templateMiddleware: function(prop, value, template) {
        if (prop === 'categories') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
          }
        }

        if (prop === 'tags') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
          }
        }
      }
    });
  });
</script>

  </body>
</html>

