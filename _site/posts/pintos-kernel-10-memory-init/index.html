<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="zh-CN" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Pintos Kernel 10 Memory Init" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Pintos 内核启动（十）：内存系统初始化 概述 本文档详细解析 Pintos 内核的内存系统初始化过程，包括页分配器 palloc_init() 和动态内存分配器 malloc_init() 的初始化。内存系统是操作系统最核心的子系统之一，它为内核和用户程序提供内存分配服务。 Pintos 的内存管理采用两级分配策略： 页分配器（Page Allocator）：以页（4KB）为单位分配物理内存 块分配器（Block Allocator）：在页的基础上，提供任意大小的内存分配 原始代码 palloc.c 中的 palloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Pool allocator data structure. */ struct pool { struct lock lock; /* Mutual exclusion. */ struct bitmap *used_map; /* Bitmap of free pages. */ uint8_t *base; /* Base of pool. */ }; /* Two pools: one for kernel data, one for user pages. */ static struct pool kernel_pool, user_pool; /* Initializes the page allocator. At most USER_PAGE_LIMIT pages are put into the user pool. */ void palloc_init (size_t user_page_limit) { /* Free memory starts at 1 MB and runs to the end of RAM. */ uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; /* Give half of memory to kernel, half to user. */ init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); } /* Initializes pool P as starting at START and ending at END, naming it NAME for debugging purposes. */ static void init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) { /* We&#39;ll put the pool&#39;s used_map at its base. Calculate the space needed for the bitmap and subtract it from the pool&#39;s size. */ size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; printf (&quot;%zu pages available in %s.\n&quot;, page_cnt, name); /* Initialize the pool. */ lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; } malloc.c 中的 malloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Descriptor. */ struct desc { size_t block_size; /* Size of each element in bytes. */ size_t blocks_per_arena; /* Number of blocks in an arena. */ struct list free_list; /* List of free blocks. */ struct lock lock; /* Lock. */ }; /* Arena. */ struct arena { unsigned magic; /* Always set to ARENA_MAGIC. */ struct desc *desc; /* Owning descriptor, null for big block. */ size_t free_cnt; /* Free blocks; pages in big block. */ }; /* Our set of descriptors. */ static struct desc descs[10]; /* Descriptors. */ static size_t desc_cnt; /* Number of descriptors. */ /* Initializes the malloc() descriptors. */ void malloc_init (void) { size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } } 前置知识 1. 内存布局回顾 在 Pintos 启动时，内存布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 物理地址 内容 ┌─────────────────────┐ │ 0x00000 - 0x003FF │ 实模式中断向量表 ├─────────────────────┤ │ 0x00400 - 0x004FF │ BIOS 数据区 ├─────────────────────┤ │ 0x07C00 - 0x07DFF │ 引导扇区（loader） ├─────────────────────┤ │ 0x20000 - 0x????? │ 内核代码和数据 ├─────────────────────┤ │ 0xA0000 - 0xBFFFF │ VGA 显存 ├─────────────────────┤ │ 0xC0000 - 0xFFFFF │ BIOS ROM ├─────────────────────┤ │ 0x100000 (1 MB) │ 可用内存开始 │ ... │ 空闲内存 │ init_ram_pages*4KB │ 内存结束 └─────────────────────┘ 2. 虚拟地址与物理地址转换 Pintos 使用简单的地址映射： 物理地址 → 虚拟地址：ptov(phys) = phys + PHYS_BASE 虚拟地址 → 物理地址：vtop(virt) = virt - PHYS_BASE 其中 PHYS_BASE = 0xC0000000（3GB）。 3. 位图（Bitmap） 位图是一种高效的数据结构，用于追踪资源的使用状态： 每个比特代表一个页的状态（0=空闲，1=已使用） 空间效率高：管理 N 页只需要 N/8 字节 操作效率：O(1) 的单页操作，O(N) 的连续页搜索 4. Slab 分配器思想 malloc 实现采用了类似 Slab 分配器的思想： Arena：一个页大小的内存块 Block：Arena 中固定大小的分配单元 Descriptor：管理某种大小块的描述符 逐行代码解析 palloc_init() 函数解析 第1-2行：计算可用内存范围 1 2 uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); 详细解析： free_start 的计算： 1024 * 1024 = 0x100000 是物理地址 1MB ptov(0x100000) 转换为虚拟地址 0xC0100000 为什么从 1MB 开始？因为低 1MB 包含： 实模式中断向量表和 BIOS 数据区 引导代码 内核代码（加载到 0x20000） VGA 显存（0xA0000-0xBFFFF） BIOS ROM（0xC0000-0xFFFFF） free_end 的计算： init_ram_pages 是在 start.S 中通过 BIOS 调用检测到的内存页数 init_ram_pages * PGSIZE 是物理内存的总大小（字节） ptov() 将其转换为对应的虚拟地址 第3-7行：计算内核和用户页数 1 2 3 4 5 6 size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; 详细解析： free_pages：总的可用页数 = (内存结束 - 1MB) / 页大小 内存分配策略： 默认将可用内存平分给内核和用户 user_page_limit 参数可以限制用户池的最大大小 内核池获得剩余的所有页 为什么需要 user_page_limit？ 在测试环境中，可能需要限制用户内存来测试内存不足的情况 默认值来自命令行参数 --ul= 数值示例： 假设物理内存为 4MB（init_ram_pages = 1024）： free_pages = (4MB - 1MB) / 4KB = 768 页 user_pages = 768 / 2 = 384 页 kernel_pages = 768 - 384 = 384 页 第8-10行：初始化内存池 1 2 3 init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); 详细解析： 内存池的布局： 1 2 3 4 5 6 7 8 9 10 虚拟地址 ┌─────────────────────────────┐ 0xC0100000 (1MB 物理地址) │ │ │ 内核池（kernel_pool） │ │ │ ├─────────────────────────────┤ 0xC0100000 + kernel_pages * 4KB │ │ │ 用户池（user_pool） │ │ │ └─────────────────────────────┘ 内存结束 init_pool() 函数解析 第1-4行：计算位图所需空间 1 2 3 4 size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; 详细解析： 位图大小计算： bitmap_buf_size(page_cnt) 返回管理 page_cnt 页需要的位图字节数 公式：ceiling(page_cnt / 8) 字节 DIV_ROUND_UP 将字节数向上取整到页 空间检查： 如果位图本身需要的页数超过了总页数，说明内存太小 这是一个致命错误，触发内核 PANIC 调整可用页数： 位图占用的页不能再用于分配 实际可用页数 = 原始页数 - 位图页数 数值示例： 假设 page_cnt = 384： 位图需要 384 / 8 = 48 字节 向上取整到页：1 页 实际可用：384 - 1 = 383 页 第5-9行：初始化池结构 1 2 3 4 5 printf (&quot;%zu pages available in %s.\n&quot;, page_cnt, name); lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; 详细解析： 打印信息：启动时会看到类似输出： 1 2 383 pages available in kernel pool. 383 pages available in user pool. 锁初始化： 每个池有独立的锁 保证多线程访问时的互斥 位图创建： bitmap_create_in_buf 在预分配的缓冲区中创建位图 位图放在池的起始位置 所有位初始化为 0（表示空闲） 基址调整： p-&gt;base 是实际可分配内存的起始地址 跳过位图占用的空间 池结构布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pool 结构 ┌─────────────┐ │ lock │ 互斥锁 ├─────────────┤ │ used_map │───┐ 指向位图 ├─────────────┤ │ │ base │───┼──┐ 指向可分配内存 └─────────────┘ │ │ │ │ 池内存布局 │ │ ┌─────────────────────────────┐ │ │ │ 位图区（bm_pages） │◄──┘ │ │ [0|0|0|0|0|0|0|0|...] │ │ ├─────────────────────────────┤◄─────┘ │ 第 0 页 │ ├─────────────────────────────┤ │ 第 1 页 │ ├─────────────────────────────┤ │ ... │ ├─────────────────────────────┤ │ 第 page_cnt-1 页 │ └─────────────────────────────┘ malloc_init() 函数解析 第1-2行：循环初始化描述符 1 2 3 size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) 详细解析： 块大小范围： 最小块：16 字节 最大块：PGSIZE / 2 = 2048 字节（不含） 实际大小：16, 32, 64, 128, 256, 512, 1024 字节 为什么最小是 16 字节？ struct block 至少需要存储一个 list_elem（8 字节） 对齐要求和实用性考虑 为什么最大是 2KB？ Arena 头部占用空间 需要保证至少能放 2 个块 第3-9行：初始化每个描述符 1 2 3 4 5 6 7 8 { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } 详细解析： 描述符数组： descs[10] 预分配 10 个描述符槽位 实际使用 7 个（16 到 1024） 每 Arena 块数计算： PGSIZE = 4096 字节 sizeof(struct arena) 约 12 字节 公式：(4096 - 12) / block_size 各描述符配置： desc_cnt block_size blocks_per_arena 0 16 255 1 32 127 2 64 63 3 128 31 4 256 15 5 512 7 6 1024 3 空闲链表： 每个描述符维护一个空闲块链表 初始为空，按需分配 Arena 锁： 每个描述符有独立的锁 不同大小的分配可以并行进行 描述符与 Arena 关系图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 描述符数组 descs[] ┌─────────────┬─────────────┬─────────────┬─────────────┐ │ desc[0] │ desc[1] │ desc[2] │ ... │ │ size=16 │ size=32 │ size=64 │ │ │ blocks=255 │ blocks=127 │ blocks=63 │ │ │ free_list ──┼─→ │ free_list ──┼─→ │ └──────┼──────┴─────────────┴──────┼──────┴─────────────┘ │ │ ↓ ↓ ┌───────┐ ┌───────┐ │Arena A│ │Arena C│ │header │ │header │ ├───────┤ ├───────┤ │block 0│ │block 0│ │block 1│ │block 1│ │ ... │ │ ... │ │blk 254│ │blk 62 │ └───────┘ └───────┘ 内存分配流程 页分配 palloc_get_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void * palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) { struct pool *pool = flags &amp; PAL_USER ? &amp;user_pool : &amp;kernel_pool; void *pages; size_t page_idx; if (page_cnt == 0) return NULL; lock_acquire (&amp;pool-&gt;lock); page_idx = bitmap_scan_and_flip (pool-&gt;used_map, 0, page_cnt, false); lock_release (&amp;pool-&gt;lock); if (page_idx != BITMAP_ERROR) pages = pool-&gt;base + PGSIZE * page_idx; else pages = NULL; if (pages != NULL) { if (flags &amp; PAL_ZERO) memset (pages, 0, PGSIZE * page_cnt); } else { if (flags &amp; PAL_ASSERT) PANIC (&quot;palloc_get: out of pages&quot;); } return pages; } 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 palloc_get_multiple(PAL_USER | PAL_ZERO, 3) │ ↓ ┌─────────────────────┐ │ 1. 选择内存池 │ │ PAL_USER → user │ │ 否则 → kernel │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 2. 获取池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 3. 在位图中搜索 │ │ 连续3个空闲位 │ │ 并设置为已使用 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 4. 释放池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 5. 计算页地址 │ │ addr = base + idx*4K│ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 6. PAL_ZERO? │ │ 是 → memset(0) │ └─────────┬───────────┘ ↓ 返回地址 块分配 malloc() 1 void *malloc (size_t size) 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 malloc(100) │ ↓ ┌───────────────────────┐ │ 1. 查找合适的描述符 │ │ 100 → desc[3] │ │ (block_size=128) │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 2. 获取描述符锁 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 3. free_list 空? │ │ 是 → 分配新 Arena │ │ 否 → 跳到步骤 5 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 4. 初始化 Arena │ │ - 设置 magic │ │ - 关联描述符 │ │ - 添加所有块到 │ │ free_list │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 5. 从 free_list 取块 │ │ 更新 arena.free_cnt│ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 6. 释放描述符锁 │ └───────────┬───────────┘ ↓ 返回块地址 内存释放流程 页释放 palloc_free_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void palloc_free_multiple (void *pages, size_t page_cnt) { struct pool *pool; size_t page_idx; ASSERT (pg_ofs (pages) == 0); if (pages == NULL || page_cnt == 0) return; if (page_from_pool (&amp;kernel_pool, pages)) pool = &amp;kernel_pool; else if (page_from_pool (&amp;user_pool, pages)) pool = &amp;user_pool; else NOT_REACHED (); page_idx = pg_no (pages) - pg_no (pool-&gt;base); #ifndef NDEBUG memset (pages, 0xcc, PGSIZE * page_cnt); #endif ASSERT (bitmap_all (pool-&gt;used_map, page_idx, page_cnt)); bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, false); } 释放流程： 地址验证：检查地址是否页对齐 确定所属池：判断页属于内核池还是用户池 计算页索引：page_idx = 页号 - 池基址页号 调试填充：非 Release 版本填充 0xCC（帮助检测 use-after-free） 更新位图：将对应位设置为 0（空闲） 块释放 free() 1 void free (void *p) 释放流程： 找到块所属的 Arena 验证 Arena 魔数 获取描述符锁 将块加入空闲链表 如果 Arena 完全空闲： 从空闲链表移除所有块 归还页给页分配器 释放描述符锁 内存分配标志 1 2 3 4 5 6 enum palloc_flags { PAL_ASSERT = 001, /* 分配失败时 panic */ PAL_ZERO = 002, /* 将页清零 */ PAL_USER = 004 /* 从用户池分配 */ }; 使用示例： 1 2 3 4 5 6 7 8 /* 分配一个清零的内核页 */ void *kpage = palloc_get_page(PAL_ZERO); /* 分配一个用户页，失败时 panic */ void *upage = palloc_get_page(PAL_USER | PAL_ASSERT); /* 分配 4 个连续的内核页 */ void *pages = palloc_get_multiple(0, 4); Arena 内存布局 单个 Arena 的详细布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Arena (4096 字节 = 1 页) ┌─────────────────────────────────┐ offset 0 │ struct arena │ │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ desc (指向描述符) │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ free_cnt │ │ 4 bytes │ └─────────────────────────┘ │ ├─────────────────────────────────┤ offset ~12 │ Block 0 │ │ ┌─────────────────────────┐ │ │ │ free_elem (if free) │ │ │ │ 或 用户数据 (if used) │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ Block 1 │ ├─────────────────────────────────┤ │ ... │ ├─────────────────────────────────┤ │ Block (blocks_per_arena-1) │ └─────────────────────────────────┘ offset 4096 大块分配 对于超过 1KB 的分配请求： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (d == descs + desc_cnt) { /* SIZE is too big for any descriptor. Allocate enough pages to hold SIZE plus an arena. */ size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE); a = palloc_get_multiple (0, page_cnt); if (a == NULL) return NULL; /* Initialize the arena to indicate a big block of PAGE_CNT pages, and return it. */ a-&gt;magic = ARENA_MAGIC; a-&gt;desc = NULL; /* 标记为大块 */ a-&gt;free_cnt = page_cnt; /* 存储页数 */ return a + 1; } 大块布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ┌─────────────────────────────────┐ │ struct arena │ 第 0 页 │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ │ │ desc = NULL (大块标记) │ │ │ │ free_cnt = 页数 │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ │ │ 用户数据区 │ │ (page_cnt * 4KB │ │ - sizeof arena) │ │ │ └─────────────────────────────────┘ 调试支持 Use-After-Free 检测 1 2 3 4 #ifndef NDEBUG /* Clear the block to help detect use-after-free bugs. */ memset (b, 0xcc, d-&gt;block_size); #endif 释放的内存填充 0xCC 如果程序访问已释放的内存，会读到 0xCCCCCCCC 这个值作为指针是无效的，容易暴露 bug Arena 完整性检查 1 2 3 /* Check that the arena is valid. */ ASSERT (a != NULL); ASSERT (a-&gt;magic == ARENA_MAGIC); 魔数 0x9a548eed 检测内存损坏 如果 Arena 头部被覆写，魔数会变化 常见问题解答 Q1: 为什么需要两个内存池？ A: 分离内核和用户内存有多个好处： 安全性：用户程序无法直接访问内核内存 资源控制：可以限制用户程序的内存使用 简化回收：进程退出时只需回收用户池中的页 Q2: 为什么 malloc 使用 2 的幂次块大小？ A: 对齐友好：2 的幂次自然满足各种对齐要求 减少碎片：标准化的块大小减少外部碎片 快速匹配：可以用位操作快速找到合适的描述符 内部碎片可控：最多浪费 50% Q3: 如何处理内存碎片？ A: Pintos 的设计减少了碎片： 页分配器：只有外部碎片（无法找到连续空闲页） 块分配器： 内部碎片：请求 20 字节分配 32 字节 外部碎片：通过 Arena 归还机制缓解 Q4: palloc_init 为什么从 1MB 开始？ A: 低 1MB 内存布局复杂： 0-1KB：实模式中断向量表 1KB-640KB：常规内存（但已被内核占用） 640KB-1MB：VGA 和 BIOS ROM 从 1MB 开始可以获得干净的连续内存。 练习题 练习1：分析内存效率 假设系统有 8MB 物理内存，计算： 内核池和用户池各有多少可用页？ 内核池位图占用多少空间？ 提示： 可用内存 = 8MB - 1MB = 7MB 总页数 = 7MB / 4KB = 1792 页 练习2：理解 malloc 选择 对于以下分配请求，malloc 会使用哪个描述符？ malloc(1) malloc(17) malloc(1000) malloc(2000) malloc(5000) 练习3：实现内存统计 在 palloc.c 中添加函数，返回当前可用的空闲页数： 1 size_t palloc_free_pages(enum palloc_flags flags); 练习4：分析并发安全 分析以下场景是否线程安全： 线程 A 调用 malloc(32)，线程 B 调用 malloc(64) 线程 A 调用 malloc(32)，线程 B 调用 malloc(32) 线程 A 调用 palloc_get_page(PAL_USER)，线程 B 调用 palloc_get_page(0) 下一篇预告 在下一篇文档中，我们将详细解析 paging_init() 函数，了解 Pintos 如何建立永久的页表结构，替换 start.S 中创建的临时页表。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Memory Allocation The Slab Allocator: An Object-Caching Kernel Memory Allocator" />
<meta property="og:description" content="Pintos 内核启动（十）：内存系统初始化 概述 本文档详细解析 Pintos 内核的内存系统初始化过程，包括页分配器 palloc_init() 和动态内存分配器 malloc_init() 的初始化。内存系统是操作系统最核心的子系统之一，它为内核和用户程序提供内存分配服务。 Pintos 的内存管理采用两级分配策略： 页分配器（Page Allocator）：以页（4KB）为单位分配物理内存 块分配器（Block Allocator）：在页的基础上，提供任意大小的内存分配 原始代码 palloc.c 中的 palloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Pool allocator data structure. */ struct pool { struct lock lock; /* Mutual exclusion. */ struct bitmap *used_map; /* Bitmap of free pages. */ uint8_t *base; /* Base of pool. */ }; /* Two pools: one for kernel data, one for user pages. */ static struct pool kernel_pool, user_pool; /* Initializes the page allocator. At most USER_PAGE_LIMIT pages are put into the user pool. */ void palloc_init (size_t user_page_limit) { /* Free memory starts at 1 MB and runs to the end of RAM. */ uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; /* Give half of memory to kernel, half to user. */ init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); } /* Initializes pool P as starting at START and ending at END, naming it NAME for debugging purposes. */ static void init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) { /* We&#39;ll put the pool&#39;s used_map at its base. Calculate the space needed for the bitmap and subtract it from the pool&#39;s size. */ size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; printf (&quot;%zu pages available in %s.\n&quot;, page_cnt, name); /* Initialize the pool. */ lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; } malloc.c 中的 malloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Descriptor. */ struct desc { size_t block_size; /* Size of each element in bytes. */ size_t blocks_per_arena; /* Number of blocks in an arena. */ struct list free_list; /* List of free blocks. */ struct lock lock; /* Lock. */ }; /* Arena. */ struct arena { unsigned magic; /* Always set to ARENA_MAGIC. */ struct desc *desc; /* Owning descriptor, null for big block. */ size_t free_cnt; /* Free blocks; pages in big block. */ }; /* Our set of descriptors. */ static struct desc descs[10]; /* Descriptors. */ static size_t desc_cnt; /* Number of descriptors. */ /* Initializes the malloc() descriptors. */ void malloc_init (void) { size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } } 前置知识 1. 内存布局回顾 在 Pintos 启动时，内存布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 物理地址 内容 ┌─────────────────────┐ │ 0x00000 - 0x003FF │ 实模式中断向量表 ├─────────────────────┤ │ 0x00400 - 0x004FF │ BIOS 数据区 ├─────────────────────┤ │ 0x07C00 - 0x07DFF │ 引导扇区（loader） ├─────────────────────┤ │ 0x20000 - 0x????? │ 内核代码和数据 ├─────────────────────┤ │ 0xA0000 - 0xBFFFF │ VGA 显存 ├─────────────────────┤ │ 0xC0000 - 0xFFFFF │ BIOS ROM ├─────────────────────┤ │ 0x100000 (1 MB) │ 可用内存开始 │ ... │ 空闲内存 │ init_ram_pages*4KB │ 内存结束 └─────────────────────┘ 2. 虚拟地址与物理地址转换 Pintos 使用简单的地址映射： 物理地址 → 虚拟地址：ptov(phys) = phys + PHYS_BASE 虚拟地址 → 物理地址：vtop(virt) = virt - PHYS_BASE 其中 PHYS_BASE = 0xC0000000（3GB）。 3. 位图（Bitmap） 位图是一种高效的数据结构，用于追踪资源的使用状态： 每个比特代表一个页的状态（0=空闲，1=已使用） 空间效率高：管理 N 页只需要 N/8 字节 操作效率：O(1) 的单页操作，O(N) 的连续页搜索 4. Slab 分配器思想 malloc 实现采用了类似 Slab 分配器的思想： Arena：一个页大小的内存块 Block：Arena 中固定大小的分配单元 Descriptor：管理某种大小块的描述符 逐行代码解析 palloc_init() 函数解析 第1-2行：计算可用内存范围 1 2 uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); 详细解析： free_start 的计算： 1024 * 1024 = 0x100000 是物理地址 1MB ptov(0x100000) 转换为虚拟地址 0xC0100000 为什么从 1MB 开始？因为低 1MB 包含： 实模式中断向量表和 BIOS 数据区 引导代码 内核代码（加载到 0x20000） VGA 显存（0xA0000-0xBFFFF） BIOS ROM（0xC0000-0xFFFFF） free_end 的计算： init_ram_pages 是在 start.S 中通过 BIOS 调用检测到的内存页数 init_ram_pages * PGSIZE 是物理内存的总大小（字节） ptov() 将其转换为对应的虚拟地址 第3-7行：计算内核和用户页数 1 2 3 4 5 6 size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; 详细解析： free_pages：总的可用页数 = (内存结束 - 1MB) / 页大小 内存分配策略： 默认将可用内存平分给内核和用户 user_page_limit 参数可以限制用户池的最大大小 内核池获得剩余的所有页 为什么需要 user_page_limit？ 在测试环境中，可能需要限制用户内存来测试内存不足的情况 默认值来自命令行参数 --ul= 数值示例： 假设物理内存为 4MB（init_ram_pages = 1024）： free_pages = (4MB - 1MB) / 4KB = 768 页 user_pages = 768 / 2 = 384 页 kernel_pages = 768 - 384 = 384 页 第8-10行：初始化内存池 1 2 3 init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); 详细解析： 内存池的布局： 1 2 3 4 5 6 7 8 9 10 虚拟地址 ┌─────────────────────────────┐ 0xC0100000 (1MB 物理地址) │ │ │ 内核池（kernel_pool） │ │ │ ├─────────────────────────────┤ 0xC0100000 + kernel_pages * 4KB │ │ │ 用户池（user_pool） │ │ │ └─────────────────────────────┘ 内存结束 init_pool() 函数解析 第1-4行：计算位图所需空间 1 2 3 4 size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; 详细解析： 位图大小计算： bitmap_buf_size(page_cnt) 返回管理 page_cnt 页需要的位图字节数 公式：ceiling(page_cnt / 8) 字节 DIV_ROUND_UP 将字节数向上取整到页 空间检查： 如果位图本身需要的页数超过了总页数，说明内存太小 这是一个致命错误，触发内核 PANIC 调整可用页数： 位图占用的页不能再用于分配 实际可用页数 = 原始页数 - 位图页数 数值示例： 假设 page_cnt = 384： 位图需要 384 / 8 = 48 字节 向上取整到页：1 页 实际可用：384 - 1 = 383 页 第5-9行：初始化池结构 1 2 3 4 5 printf (&quot;%zu pages available in %s.\n&quot;, page_cnt, name); lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; 详细解析： 打印信息：启动时会看到类似输出： 1 2 383 pages available in kernel pool. 383 pages available in user pool. 锁初始化： 每个池有独立的锁 保证多线程访问时的互斥 位图创建： bitmap_create_in_buf 在预分配的缓冲区中创建位图 位图放在池的起始位置 所有位初始化为 0（表示空闲） 基址调整： p-&gt;base 是实际可分配内存的起始地址 跳过位图占用的空间 池结构布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pool 结构 ┌─────────────┐ │ lock │ 互斥锁 ├─────────────┤ │ used_map │───┐ 指向位图 ├─────────────┤ │ │ base │───┼──┐ 指向可分配内存 └─────────────┘ │ │ │ │ 池内存布局 │ │ ┌─────────────────────────────┐ │ │ │ 位图区（bm_pages） │◄──┘ │ │ [0|0|0|0|0|0|0|0|...] │ │ ├─────────────────────────────┤◄─────┘ │ 第 0 页 │ ├─────────────────────────────┤ │ 第 1 页 │ ├─────────────────────────────┤ │ ... │ ├─────────────────────────────┤ │ 第 page_cnt-1 页 │ └─────────────────────────────┘ malloc_init() 函数解析 第1-2行：循环初始化描述符 1 2 3 size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) 详细解析： 块大小范围： 最小块：16 字节 最大块：PGSIZE / 2 = 2048 字节（不含） 实际大小：16, 32, 64, 128, 256, 512, 1024 字节 为什么最小是 16 字节？ struct block 至少需要存储一个 list_elem（8 字节） 对齐要求和实用性考虑 为什么最大是 2KB？ Arena 头部占用空间 需要保证至少能放 2 个块 第3-9行：初始化每个描述符 1 2 3 4 5 6 7 8 { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } 详细解析： 描述符数组： descs[10] 预分配 10 个描述符槽位 实际使用 7 个（16 到 1024） 每 Arena 块数计算： PGSIZE = 4096 字节 sizeof(struct arena) 约 12 字节 公式：(4096 - 12) / block_size 各描述符配置： desc_cnt block_size blocks_per_arena 0 16 255 1 32 127 2 64 63 3 128 31 4 256 15 5 512 7 6 1024 3 空闲链表： 每个描述符维护一个空闲块链表 初始为空，按需分配 Arena 锁： 每个描述符有独立的锁 不同大小的分配可以并行进行 描述符与 Arena 关系图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 描述符数组 descs[] ┌─────────────┬─────────────┬─────────────┬─────────────┐ │ desc[0] │ desc[1] │ desc[2] │ ... │ │ size=16 │ size=32 │ size=64 │ │ │ blocks=255 │ blocks=127 │ blocks=63 │ │ │ free_list ──┼─→ │ free_list ──┼─→ │ └──────┼──────┴─────────────┴──────┼──────┴─────────────┘ │ │ ↓ ↓ ┌───────┐ ┌───────┐ │Arena A│ │Arena C│ │header │ │header │ ├───────┤ ├───────┤ │block 0│ │block 0│ │block 1│ │block 1│ │ ... │ │ ... │ │blk 254│ │blk 62 │ └───────┘ └───────┘ 内存分配流程 页分配 palloc_get_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void * palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) { struct pool *pool = flags &amp; PAL_USER ? &amp;user_pool : &amp;kernel_pool; void *pages; size_t page_idx; if (page_cnt == 0) return NULL; lock_acquire (&amp;pool-&gt;lock); page_idx = bitmap_scan_and_flip (pool-&gt;used_map, 0, page_cnt, false); lock_release (&amp;pool-&gt;lock); if (page_idx != BITMAP_ERROR) pages = pool-&gt;base + PGSIZE * page_idx; else pages = NULL; if (pages != NULL) { if (flags &amp; PAL_ZERO) memset (pages, 0, PGSIZE * page_cnt); } else { if (flags &amp; PAL_ASSERT) PANIC (&quot;palloc_get: out of pages&quot;); } return pages; } 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 palloc_get_multiple(PAL_USER | PAL_ZERO, 3) │ ↓ ┌─────────────────────┐ │ 1. 选择内存池 │ │ PAL_USER → user │ │ 否则 → kernel │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 2. 获取池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 3. 在位图中搜索 │ │ 连续3个空闲位 │ │ 并设置为已使用 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 4. 释放池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 5. 计算页地址 │ │ addr = base + idx*4K│ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 6. PAL_ZERO? │ │ 是 → memset(0) │ └─────────┬───────────┘ ↓ 返回地址 块分配 malloc() 1 void *malloc (size_t size) 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 malloc(100) │ ↓ ┌───────────────────────┐ │ 1. 查找合适的描述符 │ │ 100 → desc[3] │ │ (block_size=128) │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 2. 获取描述符锁 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 3. free_list 空? │ │ 是 → 分配新 Arena │ │ 否 → 跳到步骤 5 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 4. 初始化 Arena │ │ - 设置 magic │ │ - 关联描述符 │ │ - 添加所有块到 │ │ free_list │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 5. 从 free_list 取块 │ │ 更新 arena.free_cnt│ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 6. 释放描述符锁 │ └───────────┬───────────┘ ↓ 返回块地址 内存释放流程 页释放 palloc_free_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void palloc_free_multiple (void *pages, size_t page_cnt) { struct pool *pool; size_t page_idx; ASSERT (pg_ofs (pages) == 0); if (pages == NULL || page_cnt == 0) return; if (page_from_pool (&amp;kernel_pool, pages)) pool = &amp;kernel_pool; else if (page_from_pool (&amp;user_pool, pages)) pool = &amp;user_pool; else NOT_REACHED (); page_idx = pg_no (pages) - pg_no (pool-&gt;base); #ifndef NDEBUG memset (pages, 0xcc, PGSIZE * page_cnt); #endif ASSERT (bitmap_all (pool-&gt;used_map, page_idx, page_cnt)); bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, false); } 释放流程： 地址验证：检查地址是否页对齐 确定所属池：判断页属于内核池还是用户池 计算页索引：page_idx = 页号 - 池基址页号 调试填充：非 Release 版本填充 0xCC（帮助检测 use-after-free） 更新位图：将对应位设置为 0（空闲） 块释放 free() 1 void free (void *p) 释放流程： 找到块所属的 Arena 验证 Arena 魔数 获取描述符锁 将块加入空闲链表 如果 Arena 完全空闲： 从空闲链表移除所有块 归还页给页分配器 释放描述符锁 内存分配标志 1 2 3 4 5 6 enum palloc_flags { PAL_ASSERT = 001, /* 分配失败时 panic */ PAL_ZERO = 002, /* 将页清零 */ PAL_USER = 004 /* 从用户池分配 */ }; 使用示例： 1 2 3 4 5 6 7 8 /* 分配一个清零的内核页 */ void *kpage = palloc_get_page(PAL_ZERO); /* 分配一个用户页，失败时 panic */ void *upage = palloc_get_page(PAL_USER | PAL_ASSERT); /* 分配 4 个连续的内核页 */ void *pages = palloc_get_multiple(0, 4); Arena 内存布局 单个 Arena 的详细布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Arena (4096 字节 = 1 页) ┌─────────────────────────────────┐ offset 0 │ struct arena │ │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ desc (指向描述符) │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ free_cnt │ │ 4 bytes │ └─────────────────────────┘ │ ├─────────────────────────────────┤ offset ~12 │ Block 0 │ │ ┌─────────────────────────┐ │ │ │ free_elem (if free) │ │ │ │ 或 用户数据 (if used) │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ Block 1 │ ├─────────────────────────────────┤ │ ... │ ├─────────────────────────────────┤ │ Block (blocks_per_arena-1) │ └─────────────────────────────────┘ offset 4096 大块分配 对于超过 1KB 的分配请求： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (d == descs + desc_cnt) { /* SIZE is too big for any descriptor. Allocate enough pages to hold SIZE plus an arena. */ size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE); a = palloc_get_multiple (0, page_cnt); if (a == NULL) return NULL; /* Initialize the arena to indicate a big block of PAGE_CNT pages, and return it. */ a-&gt;magic = ARENA_MAGIC; a-&gt;desc = NULL; /* 标记为大块 */ a-&gt;free_cnt = page_cnt; /* 存储页数 */ return a + 1; } 大块布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ┌─────────────────────────────────┐ │ struct arena │ 第 0 页 │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ │ │ desc = NULL (大块标记) │ │ │ │ free_cnt = 页数 │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ │ │ 用户数据区 │ │ (page_cnt * 4KB │ │ - sizeof arena) │ │ │ └─────────────────────────────────┘ 调试支持 Use-After-Free 检测 1 2 3 4 #ifndef NDEBUG /* Clear the block to help detect use-after-free bugs. */ memset (b, 0xcc, d-&gt;block_size); #endif 释放的内存填充 0xCC 如果程序访问已释放的内存，会读到 0xCCCCCCCC 这个值作为指针是无效的，容易暴露 bug Arena 完整性检查 1 2 3 /* Check that the arena is valid. */ ASSERT (a != NULL); ASSERT (a-&gt;magic == ARENA_MAGIC); 魔数 0x9a548eed 检测内存损坏 如果 Arena 头部被覆写，魔数会变化 常见问题解答 Q1: 为什么需要两个内存池？ A: 分离内核和用户内存有多个好处： 安全性：用户程序无法直接访问内核内存 资源控制：可以限制用户程序的内存使用 简化回收：进程退出时只需回收用户池中的页 Q2: 为什么 malloc 使用 2 的幂次块大小？ A: 对齐友好：2 的幂次自然满足各种对齐要求 减少碎片：标准化的块大小减少外部碎片 快速匹配：可以用位操作快速找到合适的描述符 内部碎片可控：最多浪费 50% Q3: 如何处理内存碎片？ A: Pintos 的设计减少了碎片： 页分配器：只有外部碎片（无法找到连续空闲页） 块分配器： 内部碎片：请求 20 字节分配 32 字节 外部碎片：通过 Arena 归还机制缓解 Q4: palloc_init 为什么从 1MB 开始？ A: 低 1MB 内存布局复杂： 0-1KB：实模式中断向量表 1KB-640KB：常规内存（但已被内核占用） 640KB-1MB：VGA 和 BIOS ROM 从 1MB 开始可以获得干净的连续内存。 练习题 练习1：分析内存效率 假设系统有 8MB 物理内存，计算： 内核池和用户池各有多少可用页？ 内核池位图占用多少空间？ 提示： 可用内存 = 8MB - 1MB = 7MB 总页数 = 7MB / 4KB = 1792 页 练习2：理解 malloc 选择 对于以下分配请求，malloc 会使用哪个描述符？ malloc(1) malloc(17) malloc(1000) malloc(2000) malloc(5000) 练习3：实现内存统计 在 palloc.c 中添加函数，返回当前可用的空闲页数： 1 size_t palloc_free_pages(enum palloc_flags flags); 练习4：分析并发安全 分析以下场景是否线程安全： 线程 A 调用 malloc(32)，线程 B 调用 malloc(64) 线程 A 调用 malloc(32)，线程 B 调用 malloc(32) 线程 A 调用 palloc_get_page(PAL_USER)，线程 B 调用 palloc_get_page(0) 下一篇预告 在下一篇文档中，我们将详细解析 paging_init() 函数，了解 Pintos 如何建立永久的页表结构，替换 start.S 中创建的临时页表。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Memory Allocation The Slab Allocator: An Object-Caching Kernel Memory Allocator" />
<link rel="canonical" href="http://localhost:4000/posts/pintos-kernel-10-memory-init/" />
<meta property="og:url" content="http://localhost:4000/posts/pintos-kernel-10-memory-init/" />
<meta property="og:site_name" content="Zxsheather" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-01-22T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pintos Kernel 10 Memory Init" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-22T00:00:00+08:00","datePublished":"2026-01-22T00:00:00+08:00","description":"Pintos 内核启动（十）：内存系统初始化 概述 本文档详细解析 Pintos 内核的内存系统初始化过程，包括页分配器 palloc_init() 和动态内存分配器 malloc_init() 的初始化。内存系统是操作系统最核心的子系统之一，它为内核和用户程序提供内存分配服务。 Pintos 的内存管理采用两级分配策略： 页分配器（Page Allocator）：以页（4KB）为单位分配物理内存 块分配器（Block Allocator）：在页的基础上，提供任意大小的内存分配 原始代码 palloc.c 中的 palloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* Pool allocator data structure. */ struct pool { struct lock lock; /* Mutual exclusion. */ struct bitmap *used_map; /* Bitmap of free pages. */ uint8_t *base; /* Base of pool. */ }; /* Two pools: one for kernel data, one for user pages. */ static struct pool kernel_pool, user_pool; /* Initializes the page allocator. At most USER_PAGE_LIMIT pages are put into the user pool. */ void palloc_init (size_t user_page_limit) { /* Free memory starts at 1 MB and runs to the end of RAM. */ uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; /* Give half of memory to kernel, half to user. */ init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); } /* Initializes pool P as starting at START and ending at END, naming it NAME for debugging purposes. */ static void init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) { /* We&#39;ll put the pool&#39;s used_map at its base. Calculate the space needed for the bitmap and subtract it from the pool&#39;s size. */ size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; printf (&quot;%zu pages available in %s.\\n&quot;, page_cnt, name); /* Initialize the pool. */ lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; } malloc.c 中的 malloc_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Descriptor. */ struct desc { size_t block_size; /* Size of each element in bytes. */ size_t blocks_per_arena; /* Number of blocks in an arena. */ struct list free_list; /* List of free blocks. */ struct lock lock; /* Lock. */ }; /* Arena. */ struct arena { unsigned magic; /* Always set to ARENA_MAGIC. */ struct desc *desc; /* Owning descriptor, null for big block. */ size_t free_cnt; /* Free blocks; pages in big block. */ }; /* Our set of descriptors. */ static struct desc descs[10]; /* Descriptors. */ static size_t desc_cnt; /* Number of descriptors. */ /* Initializes the malloc() descriptors. */ void malloc_init (void) { size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } } 前置知识 1. 内存布局回顾 在 Pintos 启动时，内存布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 物理地址 内容 ┌─────────────────────┐ │ 0x00000 - 0x003FF │ 实模式中断向量表 ├─────────────────────┤ │ 0x00400 - 0x004FF │ BIOS 数据区 ├─────────────────────┤ │ 0x07C00 - 0x07DFF │ 引导扇区（loader） ├─────────────────────┤ │ 0x20000 - 0x????? │ 内核代码和数据 ├─────────────────────┤ │ 0xA0000 - 0xBFFFF │ VGA 显存 ├─────────────────────┤ │ 0xC0000 - 0xFFFFF │ BIOS ROM ├─────────────────────┤ │ 0x100000 (1 MB) │ 可用内存开始 │ ... │ 空闲内存 │ init_ram_pages*4KB │ 内存结束 └─────────────────────┘ 2. 虚拟地址与物理地址转换 Pintos 使用简单的地址映射： 物理地址 → 虚拟地址：ptov(phys) = phys + PHYS_BASE 虚拟地址 → 物理地址：vtop(virt) = virt - PHYS_BASE 其中 PHYS_BASE = 0xC0000000（3GB）。 3. 位图（Bitmap） 位图是一种高效的数据结构，用于追踪资源的使用状态： 每个比特代表一个页的状态（0=空闲，1=已使用） 空间效率高：管理 N 页只需要 N/8 字节 操作效率：O(1) 的单页操作，O(N) 的连续页搜索 4. Slab 分配器思想 malloc 实现采用了类似 Slab 分配器的思想： Arena：一个页大小的内存块 Block：Arena 中固定大小的分配单元 Descriptor：管理某种大小块的描述符 逐行代码解析 palloc_init() 函数解析 第1-2行：计算可用内存范围 1 2 uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE); 详细解析： free_start 的计算： 1024 * 1024 = 0x100000 是物理地址 1MB ptov(0x100000) 转换为虚拟地址 0xC0100000 为什么从 1MB 开始？因为低 1MB 包含： 实模式中断向量表和 BIOS 数据区 引导代码 内核代码（加载到 0x20000） VGA 显存（0xA0000-0xBFFFF） BIOS ROM（0xC0000-0xFFFFF） free_end 的计算： init_ram_pages 是在 start.S 中通过 BIOS 调用检测到的内存页数 init_ram_pages * PGSIZE 是物理内存的总大小（字节） ptov() 将其转换为对应的虚拟地址 第3-7行：计算内核和用户页数 1 2 3 4 5 6 size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit) user_pages = user_page_limit; kernel_pages = free_pages - user_pages; 详细解析： free_pages：总的可用页数 = (内存结束 - 1MB) / 页大小 内存分配策略： 默认将可用内存平分给内核和用户 user_page_limit 参数可以限制用户池的最大大小 内核池获得剩余的所有页 为什么需要 user_page_limit？ 在测试环境中，可能需要限制用户内存来测试内存不足的情况 默认值来自命令行参数 --ul= 数值示例： 假设物理内存为 4MB（init_ram_pages = 1024）： free_pages = (4MB - 1MB) / 4KB = 768 页 user_pages = 768 / 2 = 384 页 kernel_pages = 768 - 384 = 384 页 第8-10行：初始化内存池 1 2 3 init_pool (&amp;kernel_pool, free_start, kernel_pages, &quot;kernel pool&quot;); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE, user_pages, &quot;user pool&quot;); 详细解析： 内存池的布局： 1 2 3 4 5 6 7 8 9 10 虚拟地址 ┌─────────────────────────────┐ 0xC0100000 (1MB 物理地址) │ │ │ 内核池（kernel_pool） │ │ │ ├─────────────────────────────┤ 0xC0100000 + kernel_pages * 4KB │ │ │ 用户池（user_pool） │ │ │ └─────────────────────────────┘ 内存结束 init_pool() 函数解析 第1-4行：计算位图所需空间 1 2 3 4 size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt) PANIC (&quot;Not enough memory in %s for bitmap.&quot;, name); page_cnt -= bm_pages; 详细解析： 位图大小计算： bitmap_buf_size(page_cnt) 返回管理 page_cnt 页需要的位图字节数 公式：ceiling(page_cnt / 8) 字节 DIV_ROUND_UP 将字节数向上取整到页 空间检查： 如果位图本身需要的页数超过了总页数，说明内存太小 这是一个致命错误，触发内核 PANIC 调整可用页数： 位图占用的页不能再用于分配 实际可用页数 = 原始页数 - 位图页数 数值示例： 假设 page_cnt = 384： 位图需要 384 / 8 = 48 字节 向上取整到页：1 页 实际可用：384 - 1 = 383 页 第5-9行：初始化池结构 1 2 3 4 5 printf (&quot;%zu pages available in %s.\\n&quot;, page_cnt, name); lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE; 详细解析： 打印信息：启动时会看到类似输出： 1 2 383 pages available in kernel pool. 383 pages available in user pool. 锁初始化： 每个池有独立的锁 保证多线程访问时的互斥 位图创建： bitmap_create_in_buf 在预分配的缓冲区中创建位图 位图放在池的起始位置 所有位初始化为 0（表示空闲） 基址调整： p-&gt;base 是实际可分配内存的起始地址 跳过位图占用的空间 池结构布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pool 结构 ┌─────────────┐ │ lock │ 互斥锁 ├─────────────┤ │ used_map │───┐ 指向位图 ├─────────────┤ │ │ base │───┼──┐ 指向可分配内存 └─────────────┘ │ │ │ │ 池内存布局 │ │ ┌─────────────────────────────┐ │ │ │ 位图区（bm_pages） │◄──┘ │ │ [0|0|0|0|0|0|0|0|...] │ │ ├─────────────────────────────┤◄─────┘ │ 第 0 页 │ ├─────────────────────────────┤ │ 第 1 页 │ ├─────────────────────────────┤ │ ... │ ├─────────────────────────────┤ │ 第 page_cnt-1 页 │ └─────────────────────────────┘ malloc_init() 函数解析 第1-2行：循环初始化描述符 1 2 3 size_t block_size; for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2) 详细解析： 块大小范围： 最小块：16 字节 最大块：PGSIZE / 2 = 2048 字节（不含） 实际大小：16, 32, 64, 128, 256, 512, 1024 字节 为什么最小是 16 字节？ struct block 至少需要存储一个 list_elem（8 字节） 对齐要求和实用性考虑 为什么最大是 2KB？ Arena 头部占用空间 需要保证至少能放 2 个块 第3-9行：初始化每个描述符 1 2 3 4 5 6 7 8 { struct desc *d = &amp;descs[desc_cnt++]; ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs); d-&gt;block_size = block_size; d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size; list_init (&amp;d-&gt;free_list); lock_init (&amp;d-&gt;lock); } 详细解析： 描述符数组： descs[10] 预分配 10 个描述符槽位 实际使用 7 个（16 到 1024） 每 Arena 块数计算： PGSIZE = 4096 字节 sizeof(struct arena) 约 12 字节 公式：(4096 - 12) / block_size 各描述符配置： desc_cnt block_size blocks_per_arena 0 16 255 1 32 127 2 64 63 3 128 31 4 256 15 5 512 7 6 1024 3 空闲链表： 每个描述符维护一个空闲块链表 初始为空，按需分配 Arena 锁： 每个描述符有独立的锁 不同大小的分配可以并行进行 描述符与 Arena 关系图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 描述符数组 descs[] ┌─────────────┬─────────────┬─────────────┬─────────────┐ │ desc[0] │ desc[1] │ desc[2] │ ... │ │ size=16 │ size=32 │ size=64 │ │ │ blocks=255 │ blocks=127 │ blocks=63 │ │ │ free_list ──┼─→ │ free_list ──┼─→ │ └──────┼──────┴─────────────┴──────┼──────┴─────────────┘ │ │ ↓ ↓ ┌───────┐ ┌───────┐ │Arena A│ │Arena C│ │header │ │header │ ├───────┤ ├───────┤ │block 0│ │block 0│ │block 1│ │block 1│ │ ... │ │ ... │ │blk 254│ │blk 62 │ └───────┘ └───────┘ 内存分配流程 页分配 palloc_get_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void * palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) { struct pool *pool = flags &amp; PAL_USER ? &amp;user_pool : &amp;kernel_pool; void *pages; size_t page_idx; if (page_cnt == 0) return NULL; lock_acquire (&amp;pool-&gt;lock); page_idx = bitmap_scan_and_flip (pool-&gt;used_map, 0, page_cnt, false); lock_release (&amp;pool-&gt;lock); if (page_idx != BITMAP_ERROR) pages = pool-&gt;base + PGSIZE * page_idx; else pages = NULL; if (pages != NULL) { if (flags &amp; PAL_ZERO) memset (pages, 0, PGSIZE * page_cnt); } else { if (flags &amp; PAL_ASSERT) PANIC (&quot;palloc_get: out of pages&quot;); } return pages; } 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 palloc_get_multiple(PAL_USER | PAL_ZERO, 3) │ ↓ ┌─────────────────────┐ │ 1. 选择内存池 │ │ PAL_USER → user │ │ 否则 → kernel │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 2. 获取池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 3. 在位图中搜索 │ │ 连续3个空闲位 │ │ 并设置为已使用 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 4. 释放池锁 │ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 5. 计算页地址 │ │ addr = base + idx*4K│ └─────────┬───────────┘ ↓ ┌─────────────────────┐ │ 6. PAL_ZERO? │ │ 是 → memset(0) │ └─────────┬───────────┘ ↓ 返回地址 块分配 malloc() 1 void *malloc (size_t size) 分配流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 malloc(100) │ ↓ ┌───────────────────────┐ │ 1. 查找合适的描述符 │ │ 100 → desc[3] │ │ (block_size=128) │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 2. 获取描述符锁 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 3. free_list 空? │ │ 是 → 分配新 Arena │ │ 否 → 跳到步骤 5 │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 4. 初始化 Arena │ │ - 设置 magic │ │ - 关联描述符 │ │ - 添加所有块到 │ │ free_list │ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 5. 从 free_list 取块 │ │ 更新 arena.free_cnt│ └───────────┬───────────┘ ↓ ┌───────────────────────┐ │ 6. 释放描述符锁 │ └───────────┬───────────┘ ↓ 返回块地址 内存释放流程 页释放 palloc_free_multiple() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void palloc_free_multiple (void *pages, size_t page_cnt) { struct pool *pool; size_t page_idx; ASSERT (pg_ofs (pages) == 0); if (pages == NULL || page_cnt == 0) return; if (page_from_pool (&amp;kernel_pool, pages)) pool = &amp;kernel_pool; else if (page_from_pool (&amp;user_pool, pages)) pool = &amp;user_pool; else NOT_REACHED (); page_idx = pg_no (pages) - pg_no (pool-&gt;base); #ifndef NDEBUG memset (pages, 0xcc, PGSIZE * page_cnt); #endif ASSERT (bitmap_all (pool-&gt;used_map, page_idx, page_cnt)); bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, false); } 释放流程： 地址验证：检查地址是否页对齐 确定所属池：判断页属于内核池还是用户池 计算页索引：page_idx = 页号 - 池基址页号 调试填充：非 Release 版本填充 0xCC（帮助检测 use-after-free） 更新位图：将对应位设置为 0（空闲） 块释放 free() 1 void free (void *p) 释放流程： 找到块所属的 Arena 验证 Arena 魔数 获取描述符锁 将块加入空闲链表 如果 Arena 完全空闲： 从空闲链表移除所有块 归还页给页分配器 释放描述符锁 内存分配标志 1 2 3 4 5 6 enum palloc_flags { PAL_ASSERT = 001, /* 分配失败时 panic */ PAL_ZERO = 002, /* 将页清零 */ PAL_USER = 004 /* 从用户池分配 */ }; 使用示例： 1 2 3 4 5 6 7 8 /* 分配一个清零的内核页 */ void *kpage = palloc_get_page(PAL_ZERO); /* 分配一个用户页，失败时 panic */ void *upage = palloc_get_page(PAL_USER | PAL_ASSERT); /* 分配 4 个连续的内核页 */ void *pages = palloc_get_multiple(0, 4); Arena 内存布局 单个 Arena 的详细布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Arena (4096 字节 = 1 页) ┌─────────────────────────────────┐ offset 0 │ struct arena │ │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ desc (指向描述符) │ │ 4 bytes │ ├─────────────────────────┤ │ │ │ free_cnt │ │ 4 bytes │ └─────────────────────────┘ │ ├─────────────────────────────────┤ offset ~12 │ Block 0 │ │ ┌─────────────────────────┐ │ │ │ free_elem (if free) │ │ │ │ 或 用户数据 (if used) │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ Block 1 │ ├─────────────────────────────────┤ │ ... │ ├─────────────────────────────────┤ │ Block (blocks_per_arena-1) │ └─────────────────────────────────┘ offset 4096 大块分配 对于超过 1KB 的分配请求： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (d == descs + desc_cnt) { /* SIZE is too big for any descriptor. Allocate enough pages to hold SIZE plus an arena. */ size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE); a = palloc_get_multiple (0, page_cnt); if (a == NULL) return NULL; /* Initialize the arena to indicate a big block of PAGE_CNT pages, and return it. */ a-&gt;magic = ARENA_MAGIC; a-&gt;desc = NULL; /* 标记为大块 */ a-&gt;free_cnt = page_cnt; /* 存储页数 */ return a + 1; } 大块布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ┌─────────────────────────────────┐ │ struct arena │ 第 0 页 │ ┌─────────────────────────┐ │ │ │ magic = 0x9a548eed │ │ │ │ desc = NULL (大块标记) │ │ │ │ free_cnt = 页数 │ │ │ └─────────────────────────┘ │ ├─────────────────────────────────┤ │ │ │ 用户数据区 │ │ (page_cnt * 4KB │ │ - sizeof arena) │ │ │ └─────────────────────────────────┘ 调试支持 Use-After-Free 检测 1 2 3 4 #ifndef NDEBUG /* Clear the block to help detect use-after-free bugs. */ memset (b, 0xcc, d-&gt;block_size); #endif 释放的内存填充 0xCC 如果程序访问已释放的内存，会读到 0xCCCCCCCC 这个值作为指针是无效的，容易暴露 bug Arena 完整性检查 1 2 3 /* Check that the arena is valid. */ ASSERT (a != NULL); ASSERT (a-&gt;magic == ARENA_MAGIC); 魔数 0x9a548eed 检测内存损坏 如果 Arena 头部被覆写，魔数会变化 常见问题解答 Q1: 为什么需要两个内存池？ A: 分离内核和用户内存有多个好处： 安全性：用户程序无法直接访问内核内存 资源控制：可以限制用户程序的内存使用 简化回收：进程退出时只需回收用户池中的页 Q2: 为什么 malloc 使用 2 的幂次块大小？ A: 对齐友好：2 的幂次自然满足各种对齐要求 减少碎片：标准化的块大小减少外部碎片 快速匹配：可以用位操作快速找到合适的描述符 内部碎片可控：最多浪费 50% Q3: 如何处理内存碎片？ A: Pintos 的设计减少了碎片： 页分配器：只有外部碎片（无法找到连续空闲页） 块分配器： 内部碎片：请求 20 字节分配 32 字节 外部碎片：通过 Arena 归还机制缓解 Q4: palloc_init 为什么从 1MB 开始？ A: 低 1MB 内存布局复杂： 0-1KB：实模式中断向量表 1KB-640KB：常规内存（但已被内核占用） 640KB-1MB：VGA 和 BIOS ROM 从 1MB 开始可以获得干净的连续内存。 练习题 练习1：分析内存效率 假设系统有 8MB 物理内存，计算： 内核池和用户池各有多少可用页？ 内核池位图占用多少空间？ 提示： 可用内存 = 8MB - 1MB = 7MB 总页数 = 7MB / 4KB = 1792 页 练习2：理解 malloc 选择 对于以下分配请求，malloc 会使用哪个描述符？ malloc(1) malloc(17) malloc(1000) malloc(2000) malloc(5000) 练习3：实现内存统计 在 palloc.c 中添加函数，返回当前可用的空闲页数： 1 size_t palloc_free_pages(enum palloc_flags flags); 练习4：分析并发安全 分析以下场景是否线程安全： 线程 A 调用 malloc(32)，线程 B 调用 malloc(64) 线程 A 调用 malloc(32)，线程 B 调用 malloc(32) 线程 A 调用 palloc_get_page(PAL_USER)，线程 B 调用 palloc_get_page(0) 下一篇预告 在下一篇文档中，我们将详细解析 paging_init() 函数，了解 Pintos 如何建立永久的页表结构，替换 start.S 中创建的临时页表。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Memory Allocation The Slab Allocator: An Object-Caching Kernel Memory Allocator","headline":"Pintos Kernel 10 Memory Init","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/pintos-kernel-10-memory-init/"},"url":"http://localhost:4000/posts/pintos-kernel-10-memory-init/"}</script>
<!-- End Jekyll SEO tag -->


  <title>Pintos Kernel 10 Memory Init | Zxsheather
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">



  <!-- Resource Hints -->
  
    
      
        <link rel="preconnect" href="https://fonts.googleapis.com" >
      
        <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
      
    
      
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      
        <link rel="dns-prefetch" href="https://fonts.gstatic.com" >
      
    
      
        <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      
        <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
      
    
  

  <!-- Bootstrap -->
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css">
  

  <!-- Theme style -->
  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  <!-- Web Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css">

  <!-- 3rd-party Dependencies -->

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Image Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css">
  

  <!-- Scripts -->

  <script src="/assets/js/dist/theme.min.js"></script>

  <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/zh.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script>







<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  



  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/3.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <a class="site-title d-block" href="/">Zxsheather</a>
    <p class="site-subtitle fst-italic mb-0">A CS Undergraduate</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>首页</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>分类</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>标签</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>归档</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>关于</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle">
        <i class="fas fa-adjust"></i>
      </button>

      
    

    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">首页</a>
            </span>

          
        
          
        
          
            
              <span>Pintos Kernel 10 Memory Init</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      文章
    </div>

    <button type="button" id="search-trigger" class="btn btn-link" aria-label="Search">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search id="search" class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="搜索..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  




<!-- return -->










<article class="px-1" data-toc="true">
  <header>
    <h1 data-toc-skip>Pintos Kernel 10 Memory Init</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        发表于
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1769011200"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2026/01/22
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          作者

          <em>
            
              <a href="https://github.com/zxsheather">Zxsheather</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="4287 字"
>
  <em>23 分钟</em>阅读</span>

        </div>
      </div>
    </div>
  </header>

  
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">Pintos Kernel 10 Memory Init</span>
      <button type="button" class="toc-trigger btn me-1">
        <i class="fa-solid fa-list-ul fa-fw"></i>
      </button>
    </div>

    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">文章内容</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>

    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">Pintos Kernel 10 Memory Init</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75">
          <i class="fas fa-close"></i>
        </button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  

  <div class="content">
    <h1 id="pintos-内核启动十内存系统初始化">Pintos 内核启动（十）：内存系统初始化</h1>

<h2 id="概述"><span class="me-2">概述</span><a href="#概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>本文档详细解析 Pintos 内核的内存系统初始化过程，包括页分配器 <code class="language-plaintext highlighter-rouge">palloc_init()</code> 和动态内存分配器 <code class="language-plaintext highlighter-rouge">malloc_init()</code> 的初始化。内存系统是操作系统最核心的子系统之一，它为内核和用户程序提供内存分配服务。</p>

<p>Pintos 的内存管理采用<strong>两级分配</strong>策略：</p>
<ol>
  <li><strong>页分配器（Page Allocator）</strong>：以页（4KB）为单位分配物理内存</li>
  <li><strong>块分配器（Block Allocator）</strong>：在页的基础上，提供任意大小的内存分配</li>
</ol>

<h2 id="原始代码"><span class="me-2">原始代码</span><a href="#原始代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="pallocc-中的-palloc_init-函数"><span class="me-2">palloc.c 中的 palloc_init() 函数</span><a href="#pallocc-中的-palloc_init-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="rouge-code"><pre><span class="cm">/* Pool allocator data structure. */</span>
<span class="k">struct</span> <span class="n">pool</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">lock</span> <span class="n">lock</span><span class="p">;</span>           <span class="cm">/* Mutual exclusion. */</span>
    <span class="k">struct</span> <span class="n">bitmap</span> <span class="o">*</span><span class="n">used_map</span><span class="p">;</span>    <span class="cm">/* Bitmap of free pages. */</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>              <span class="cm">/* Base of pool. */</span>
  <span class="p">};</span>

<span class="cm">/* Two pools: one for kernel data, one for user pages. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pool</span> <span class="n">kernel_pool</span><span class="p">,</span> <span class="n">user_pool</span><span class="p">;</span>

<span class="cm">/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */</span>
<span class="kt">void</span>
<span class="nf">palloc_init</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">user_page_limit</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Free memory starts at 1 MB and runs to the end of RAM. */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">free_start</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">free_end</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="n">init_ram_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">free_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_end</span> <span class="o">-</span> <span class="n">free_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">user_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">kernel_pages</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">user_pages</span> <span class="o">&gt;</span> <span class="n">user_page_limit</span><span class="p">)</span>
    <span class="n">user_pages</span> <span class="o">=</span> <span class="n">user_page_limit</span><span class="p">;</span>
  <span class="n">kernel_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">-</span> <span class="n">user_pages</span><span class="p">;</span>

  <span class="cm">/* Give half of memory to kernel, half to user. */</span>
  <span class="n">init_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">kernel_pool</span><span class="p">,</span> <span class="n">free_start</span><span class="p">,</span> <span class="n">kernel_pages</span><span class="p">,</span> <span class="s">"kernel pool"</span><span class="p">);</span>
  <span class="n">init_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">user_pool</span><span class="p">,</span> <span class="n">free_start</span> <span class="o">+</span> <span class="n">kernel_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">,</span>
             <span class="n">user_pages</span><span class="p">,</span> <span class="s">"user pool"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_pool</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="cm">/* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */</span>
  <span class="kt">size_t</span> <span class="n">bm_pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span> <span class="p">(</span><span class="n">bitmap_buf_size</span> <span class="p">(</span><span class="n">page_cnt</span><span class="p">),</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bm_pages</span> <span class="o">&gt;</span> <span class="n">page_cnt</span><span class="p">)</span>
    <span class="n">PANIC</span> <span class="p">(</span><span class="s">"Not enough memory in %s for bitmap."</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="n">page_cnt</span> <span class="o">-=</span> <span class="n">bm_pages</span><span class="p">;</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"%zu pages available in %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

  <span class="cm">/* Initialize the pool. */</span>
  <span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">used_map</span> <span class="o">=</span> <span class="n">bitmap_create_in_buf</span> <span class="p">(</span><span class="n">page_cnt</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">bm_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">bm_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="mallocc-中的-malloc_init-函数"><span class="me-2">malloc.c 中的 malloc_init() 函数</span><a href="#mallocc-中的-malloc_init-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="cm">/* Descriptor. */</span>
<span class="k">struct</span> <span class="n">desc</span>
  <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span>          <span class="cm">/* Size of each element in bytes. */</span>
    <span class="kt">size_t</span> <span class="n">blocks_per_arena</span><span class="p">;</span>    <span class="cm">/* Number of blocks in an arena. */</span>
    <span class="k">struct</span> <span class="n">list</span> <span class="n">free_list</span><span class="p">;</span>      <span class="cm">/* List of free blocks. */</span>
    <span class="k">struct</span> <span class="n">lock</span> <span class="n">lock</span><span class="p">;</span>           <span class="cm">/* Lock. */</span>
  <span class="p">};</span>

<span class="cm">/* Arena. */</span>
<span class="k">struct</span> <span class="n">arena</span> 
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">magic</span><span class="p">;</span>             <span class="cm">/* Always set to ARENA_MAGIC. */</span>
    <span class="k">struct</span> <span class="n">desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>          <span class="cm">/* Owning descriptor, null for big block. */</span>
    <span class="kt">size_t</span> <span class="n">free_cnt</span><span class="p">;</span>            <span class="cm">/* Free blocks; pages in big block. */</span>
  <span class="p">};</span>

<span class="cm">/* Our set of descriptors. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">desc</span> <span class="n">descs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>   <span class="cm">/* Descriptors. */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">desc_cnt</span><span class="p">;</span>         <span class="cm">/* Number of descriptors. */</span>

<span class="cm">/* Initializes the malloc() descriptors. */</span>
<span class="kt">void</span>
<span class="nf">malloc_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">block_size</span> <span class="o">&lt;</span> <span class="n">PGSIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">block_size</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">struct</span> <span class="n">desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descs</span><span class="p">[</span><span class="n">desc_cnt</span><span class="o">++</span><span class="p">];</span>
      <span class="n">ASSERT</span> <span class="p">(</span><span class="n">desc_cnt</span> <span class="o">&lt;=</span> <span class="k">sizeof</span> <span class="n">descs</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">descs</span><span class="p">);</span>
      <span class="n">d</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
      <span class="n">d</span><span class="o">-&gt;</span><span class="n">blocks_per_arena</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGSIZE</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arena</span><span class="p">))</span> <span class="o">/</span> <span class="n">block_size</span><span class="p">;</span>
      <span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
      <span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="前置知识"><span class="me-2">前置知识</span><a href="#前置知识" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="1-内存布局回顾"><span class="me-2">1. 内存布局回顾</span><a href="#1-内存布局回顾" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>在 Pintos 启动时，内存布局如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>物理地址                   内容
┌─────────────────────┐
│  0x00000 - 0x003FF  │   实模式中断向量表
├─────────────────────┤
│  0x00400 - 0x004FF  │   BIOS 数据区
├─────────────────────┤
│  0x07C00 - 0x07DFF  │   引导扇区（loader）
├─────────────────────┤
│  0x20000 - 0x????? │   内核代码和数据
├─────────────────────┤
│  0xA0000 - 0xBFFFF  │   VGA 显存
├─────────────────────┤
│  0xC0000 - 0xFFFFF  │   BIOS ROM
├─────────────────────┤
│  0x100000 (1 MB)    │   可用内存开始
│         ...         │   空闲内存
│  init_ram_pages*4KB │   内存结束
└─────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="2-虚拟地址与物理地址转换"><span class="me-2">2. 虚拟地址与物理地址转换</span><a href="#2-虚拟地址与物理地址转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Pintos 使用简单的地址映射：</p>
<ul>
  <li><strong>物理地址 → 虚拟地址</strong>：<code class="language-plaintext highlighter-rouge">ptov(phys) = phys + PHYS_BASE</code></li>
  <li><strong>虚拟地址 → 物理地址</strong>：<code class="language-plaintext highlighter-rouge">vtop(virt) = virt - PHYS_BASE</code></li>
</ul>

<p>其中 <code class="language-plaintext highlighter-rouge">PHYS_BASE = 0xC0000000</code>（3GB）。</p>

<h3 id="3-位图bitmap"><span class="me-2">3. 位图（Bitmap）</span><a href="#3-位图bitmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>位图是一种高效的数据结构，用于追踪资源的使用状态：</p>
<ul>
  <li>每个比特代表一个页的状态（0=空闲，1=已使用）</li>
  <li>空间效率高：管理 N 页只需要 N/8 字节</li>
  <li>操作效率：O(1) 的单页操作，O(N) 的连续页搜索</li>
</ul>

<h3 id="4-slab-分配器思想"><span class="me-2">4. Slab 分配器思想</span><a href="#4-slab-分配器思想" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">malloc</code> 实现采用了类似 Slab 分配器的思想：</p>
<ul>
  <li><strong>Arena</strong>：一个页大小的内存块</li>
  <li><strong>Block</strong>：Arena 中固定大小的分配单元</li>
  <li><strong>Descriptor</strong>：管理某种大小块的描述符</li>
</ul>

<h2 id="逐行代码解析"><span class="me-2">逐行代码解析</span><a href="#逐行代码解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="palloc_init-函数解析"><span class="me-2">palloc_init() 函数解析</span><a href="#palloc_init-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="第1-2行计算可用内存范围"><span class="me-2">第1-2行：计算可用内存范围</span><a href="#第1-2行计算可用内存范围" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">free_start</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">free_end</span> <span class="o">=</span> <span class="n">ptov</span> <span class="p">(</span><span class="n">init_ram_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>free_start 的计算</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">1024 * 1024 = 0x100000</code> 是物理地址 1MB</li>
      <li><code class="language-plaintext highlighter-rouge">ptov(0x100000)</code> 转换为虚拟地址 <code class="language-plaintext highlighter-rouge">0xC0100000</code></li>
      <li>为什么从 1MB 开始？因为低 1MB 包含：
        <ul>
          <li>实模式中断向量表和 BIOS 数据区</li>
          <li>引导代码</li>
          <li>内核代码（加载到 0x20000）</li>
          <li>VGA 显存（0xA0000-0xBFFFF）</li>
          <li>BIOS ROM（0xC0000-0xFFFFF）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>free_end 的计算</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">init_ram_pages</code> 是在 <code class="language-plaintext highlighter-rouge">start.S</code> 中通过 BIOS 调用检测到的内存页数</li>
      <li><code class="language-plaintext highlighter-rouge">init_ram_pages * PGSIZE</code> 是物理内存的总大小（字节）</li>
      <li><code class="language-plaintext highlighter-rouge">ptov()</code> 将其转换为对应的虚拟地址</li>
    </ul>
  </li>
</ol>

<h4 id="第3-7行计算内核和用户页数"><span class="me-2">第3-7行：计算内核和用户页数</span><a href="#第3-7行计算内核和用户页数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">free_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_end</span> <span class="o">-</span> <span class="n">free_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">user_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">kernel_pages</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">user_pages</span> <span class="o">&gt;</span> <span class="n">user_page_limit</span><span class="p">)</span>
  <span class="n">user_pages</span> <span class="o">=</span> <span class="n">user_page_limit</span><span class="p">;</span>
<span class="n">kernel_pages</span> <span class="o">=</span> <span class="n">free_pages</span> <span class="o">-</span> <span class="n">user_pages</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li>
    <p><strong>free_pages</strong>：总的可用页数 = (内存结束 - 1MB) / 页大小</p>
  </li>
  <li><strong>内存分配策略</strong>：
    <ul>
      <li>默认将可用内存平分给内核和用户</li>
      <li><code class="language-plaintext highlighter-rouge">user_page_limit</code> 参数可以限制用户池的最大大小</li>
      <li>内核池获得剩余的所有页</li>
    </ul>
  </li>
  <li><strong>为什么需要 user_page_limit</strong>？
    <ul>
      <li>在测试环境中，可能需要限制用户内存来测试内存不足的情况</li>
      <li>默认值来自命令行参数 <code class="language-plaintext highlighter-rouge">--ul=</code></li>
    </ul>
  </li>
</ol>

<p><strong>数值示例</strong>：
假设物理内存为 4MB（<code class="language-plaintext highlighter-rouge">init_ram_pages = 1024</code>）：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">free_pages = (4MB - 1MB) / 4KB = 768</code> 页</li>
  <li><code class="language-plaintext highlighter-rouge">user_pages = 768 / 2 = 384</code> 页</li>
  <li><code class="language-plaintext highlighter-rouge">kernel_pages = 768 - 384 = 384</code> 页</li>
</ul>

<h4 id="第8-10行初始化内存池"><span class="me-2">第8-10行：初始化内存池</span><a href="#第8-10行初始化内存池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">init_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">kernel_pool</span><span class="p">,</span> <span class="n">free_start</span><span class="p">,</span> <span class="n">kernel_pages</span><span class="p">,</span> <span class="s">"kernel pool"</span><span class="p">);</span>
<span class="n">init_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">user_pool</span><span class="p">,</span> <span class="n">free_start</span> <span class="o">+</span> <span class="n">kernel_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">,</span>
           <span class="n">user_pages</span><span class="p">,</span> <span class="s">"user pool"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<p>内存池的布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>虚拟地址
┌─────────────────────────────┐ 0xC0100000 (1MB 物理地址)
│                             │
│       内核池（kernel_pool） │
│                             │
├─────────────────────────────┤ 0xC0100000 + kernel_pages * 4KB
│                             │
│       用户池（user_pool）   │
│                             │
└─────────────────────────────┘ 内存结束
</pre></td></tr></tbody></table></code></div></div>

<h3 id="init_pool-函数解析"><span class="me-2">init_pool() 函数解析</span><a href="#init_pool-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="第1-4行计算位图所需空间"><span class="me-2">第1-4行：计算位图所需空间</span><a href="#第1-4行计算位图所需空间" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">bm_pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span> <span class="p">(</span><span class="n">bitmap_buf_size</span> <span class="p">(</span><span class="n">page_cnt</span><span class="p">),</span> <span class="n">PGSIZE</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bm_pages</span> <span class="o">&gt;</span> <span class="n">page_cnt</span><span class="p">)</span>
  <span class="n">PANIC</span> <span class="p">(</span><span class="s">"Not enough memory in %s for bitmap."</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="n">page_cnt</span> <span class="o">-=</span> <span class="n">bm_pages</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>位图大小计算</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bitmap_buf_size(page_cnt)</code> 返回管理 <code class="language-plaintext highlighter-rouge">page_cnt</code> 页需要的位图字节数</li>
      <li>公式：<code class="language-plaintext highlighter-rouge">ceiling(page_cnt / 8)</code> 字节</li>
      <li><code class="language-plaintext highlighter-rouge">DIV_ROUND_UP</code> 将字节数向上取整到页</li>
    </ul>
  </li>
  <li><strong>空间检查</strong>：
    <ul>
      <li>如果位图本身需要的页数超过了总页数，说明内存太小</li>
      <li>这是一个致命错误，触发内核 PANIC</li>
    </ul>
  </li>
  <li><strong>调整可用页数</strong>：
    <ul>
      <li>位图占用的页不能再用于分配</li>
      <li>实际可用页数 = 原始页数 - 位图页数</li>
    </ul>
  </li>
</ol>

<p><strong>数值示例</strong>：
假设 <code class="language-plaintext highlighter-rouge">page_cnt = 384</code>：</p>
<ul>
  <li>位图需要 <code class="language-plaintext highlighter-rouge">384 / 8 = 48</code> 字节</li>
  <li>向上取整到页：1 页</li>
  <li>实际可用：<code class="language-plaintext highlighter-rouge">384 - 1 = 383</code> 页</li>
</ul>

<h4 id="第5-9行初始化池结构"><span class="me-2">第5-9行：初始化池结构</span><a href="#第5-9行初始化池结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">printf</span> <span class="p">(</span><span class="s">"%zu pages available in %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

<span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">used_map</span> <span class="o">=</span> <span class="n">bitmap_create_in_buf</span> <span class="p">(</span><span class="n">page_cnt</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">bm_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">bm_pages</span> <span class="o">*</span> <span class="n">PGSIZE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>打印信息</strong>：启动时会看到类似输出：
    <div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>383 pages available in kernel pool.
383 pages available in user pool.
</pre></td></tr></tbody></table></code></div>    </div>
  </li>
  <li><strong>锁初始化</strong>：
    <ul>
      <li>每个池有独立的锁</li>
      <li>保证多线程访问时的互斥</li>
    </ul>
  </li>
  <li><strong>位图创建</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bitmap_create_in_buf</code> 在预分配的缓冲区中创建位图</li>
      <li>位图放在池的起始位置</li>
      <li>所有位初始化为 0（表示空闲）</li>
    </ul>
  </li>
  <li><strong>基址调整</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">p-&gt;base</code> 是实际可分配内存的起始地址</li>
      <li>跳过位图占用的空间</li>
    </ul>
  </li>
</ol>

<p><strong>池结构布局</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>                    pool 结构
                 ┌─────────────┐
                 │    lock     │ 互斥锁
                 ├─────────────┤
                 │  used_map   │───┐ 指向位图
                 ├─────────────┤   │
                 │    base     │───┼──┐ 指向可分配内存
                 └─────────────┘   │  │
                                   │  │
池内存布局                          │  │
┌─────────────────────────────┐   │  │
│      位图区（bm_pages）      │◄──┘  │
│  [0|0|0|0|0|0|0|0|...]     │       │
├─────────────────────────────┤◄─────┘
│         第 0 页             │
├─────────────────────────────┤
│         第 1 页             │
├─────────────────────────────┤
│          ...                │
├─────────────────────────────┤
│      第 page_cnt-1 页       │
└─────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h3 id="malloc_init-函数解析"><span class="me-2">malloc_init() 函数解析</span><a href="#malloc_init-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="第1-2行循环初始化描述符"><span class="me-2">第1-2行：循环初始化描述符</span><a href="#第1-2行循环初始化描述符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">block_size</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">block_size</span> <span class="o">&lt;</span> <span class="n">PGSIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">block_size</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>块大小范围</strong>：
    <ul>
      <li>最小块：16 字节</li>
      <li>最大块：<code class="language-plaintext highlighter-rouge">PGSIZE / 2 = 2048</code> 字节（不含）</li>
      <li>实际大小：16, 32, 64, 128, 256, 512, 1024 字节</li>
    </ul>
  </li>
  <li><strong>为什么最小是 16 字节</strong>？
    <ul>
      <li><code class="language-plaintext highlighter-rouge">struct block</code> 至少需要存储一个 <code class="language-plaintext highlighter-rouge">list_elem</code>（8 字节）</li>
      <li>对齐要求和实用性考虑</li>
    </ul>
  </li>
  <li><strong>为什么最大是 2KB</strong>？
    <ul>
      <li>Arena 头部占用空间</li>
      <li>需要保证至少能放 2 个块</li>
    </ul>
  </li>
</ol>

<h4 id="第3-9行初始化每个描述符"><span class="me-2">第3-9行：初始化每个描述符</span><a href="#第3-9行初始化每个描述符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="p">{</span>
  <span class="k">struct</span> <span class="n">desc</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descs</span><span class="p">[</span><span class="n">desc_cnt</span><span class="o">++</span><span class="p">];</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">desc_cnt</span> <span class="o">&lt;=</span> <span class="k">sizeof</span> <span class="n">descs</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">descs</span><span class="p">);</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
  <span class="n">d</span><span class="o">-&gt;</span><span class="n">blocks_per_arena</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGSIZE</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arena</span><span class="p">))</span> <span class="o">/</span> <span class="n">block_size</span><span class="p">;</span>
  <span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
  <span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>描述符数组</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">descs[10]</code> 预分配 10 个描述符槽位</li>
      <li>实际使用 7 个（16 到 1024）</li>
    </ul>
  </li>
  <li><strong>每 Arena 块数计算</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">PGSIZE = 4096</code> 字节</li>
      <li><code class="language-plaintext highlighter-rouge">sizeof(struct arena)</code> 约 12 字节</li>
      <li>公式：<code class="language-plaintext highlighter-rouge">(4096 - 12) / block_size</code></li>
    </ul>
  </li>
  <li><strong>各描述符配置</strong>：</li>
</ol>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>desc_cnt</th>
      <th>block_size</th>
      <th>blocks_per_arena</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>16</td>
      <td>255</td>
    </tr>
    <tr>
      <td>1</td>
      <td>32</td>
      <td>127</td>
    </tr>
    <tr>
      <td>2</td>
      <td>64</td>
      <td>63</td>
    </tr>
    <tr>
      <td>3</td>
      <td>128</td>
      <td>31</td>
    </tr>
    <tr>
      <td>4</td>
      <td>256</td>
      <td>15</td>
    </tr>
    <tr>
      <td>5</td>
      <td>512</td>
      <td>7</td>
    </tr>
    <tr>
      <td>6</td>
      <td>1024</td>
      <td>3</td>
    </tr>
  </tbody>
</table></div>

<ol>
  <li><strong>空闲链表</strong>：
    <ul>
      <li>每个描述符维护一个空闲块链表</li>
      <li>初始为空，按需分配 Arena</li>
    </ul>
  </li>
  <li><strong>锁</strong>：
    <ul>
      <li>每个描述符有独立的锁</li>
      <li>不同大小的分配可以并行进行</li>
    </ul>
  </li>
</ol>

<p><strong>描述符与 Arena 关系图</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>描述符数组 descs[]
┌─────────────┬─────────────┬─────────────┬─────────────┐
│  desc[0]    │  desc[1]    │  desc[2]    │    ...      │
│ size=16     │ size=32     │ size=64     │             │
│ blocks=255  │ blocks=127  │ blocks=63   │             │
│ free_list ──┼─→           │ free_list ──┼─→           │
└──────┼──────┴─────────────┴──────┼──────┴─────────────┘
       │                           │
       ↓                           ↓
   ┌───────┐                   ┌───────┐
   │Arena A│                   │Arena C│
   │header │                   │header │
   ├───────┤                   ├───────┤
   │block 0│                   │block 0│
   │block 1│                   │block 1│
   │  ...  │                   │  ...  │
   │blk 254│                   │blk 62 │
   └───────┘                   └───────┘
</pre></td></tr></tbody></table></code></div></div>

<h2 id="内存分配流程"><span class="me-2">内存分配流程</span><a href="#内存分配流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="页分配-palloc_get_multiple"><span class="me-2">页分配 palloc_get_multiple()</span><a href="#页分配-palloc_get_multiple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span>
<span class="nf">palloc_get_multiple</span> <span class="p">(</span><span class="k">enum</span> <span class="n">palloc_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">page_cnt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PAL_USER</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">user_pool</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">kernel_pool</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">page_idx</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">page_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">lock_acquire</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">page_idx</span> <span class="o">=</span> <span class="n">bitmap_scan_and_flip</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">used_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">lock_release</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">!=</span> <span class="n">BITMAP_ERROR</span><span class="p">)</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">PGSIZE</span> <span class="o">*</span> <span class="n">page_idx</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PAL_ZERO</span><span class="p">)</span>
        <span class="n">memset</span> <span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span> <span class="o">*</span> <span class="n">page_cnt</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span> 
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PAL_ASSERT</span><span class="p">)</span>
        <span class="n">PANIC</span> <span class="p">(</span><span class="s">"palloc_get: out of pages"</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>分配流程</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>palloc_get_multiple(PAL_USER | PAL_ZERO, 3)
              │
              ↓
    ┌─────────────────────┐
    │ 1. 选择内存池       │
    │    PAL_USER → user  │
    │    否则 → kernel    │
    └─────────┬───────────┘
              ↓
    ┌─────────────────────┐
    │ 2. 获取池锁         │
    └─────────┬───────────┘
              ↓
    ┌─────────────────────┐
    │ 3. 在位图中搜索     │
    │    连续3个空闲位    │
    │    并设置为已使用   │
    └─────────┬───────────┘
              ↓
    ┌─────────────────────┐
    │ 4. 释放池锁         │
    └─────────┬───────────┘
              ↓
    ┌─────────────────────┐
    │ 5. 计算页地址       │
    │ addr = base + idx*4K│
    └─────────┬───────────┘
              ↓
    ┌─────────────────────┐
    │ 6. PAL_ZERO?        │
    │    是 → memset(0)   │
    └─────────┬───────────┘
              ↓
         返回地址
</pre></td></tr></tbody></table></code></div></div>

<h3 id="块分配-malloc"><span class="me-2">块分配 malloc()</span><a href="#块分配-malloc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">malloc</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>分配流程</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>malloc(100)
    │
    ↓
┌───────────────────────┐
│ 1. 查找合适的描述符   │
│    100 → desc[3]      │
│    (block_size=128)   │
└───────────┬───────────┘
            ↓
┌───────────────────────┐
│ 2. 获取描述符锁       │
└───────────┬───────────┘
            ↓
┌───────────────────────┐
│ 3. free_list 空?      │
│    是 → 分配新 Arena  │
│    否 → 跳到步骤 5    │
└───────────┬───────────┘
            ↓
┌───────────────────────┐
│ 4. 初始化 Arena       │
│    - 设置 magic       │
│    - 关联描述符       │
│    - 添加所有块到     │
│      free_list        │
└───────────┬───────────┘
            ↓
┌───────────────────────┐
│ 5. 从 free_list 取块  │
│    更新 arena.free_cnt│
└───────────┬───────────┘
            ↓
┌───────────────────────┐
│ 6. 释放描述符锁       │
└───────────┬───────────┘
            ↓
        返回块地址
</pre></td></tr></tbody></table></code></div></div>

<h2 id="内存释放流程"><span class="me-2">内存释放流程</span><a href="#内存释放流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="页释放-palloc_free_multiple"><span class="me-2">页释放 palloc_free_multiple()</span><a href="#页释放-palloc_free_multiple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">palloc_free_multiple</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">page_cnt</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">page_idx</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">pg_ofs</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">page_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">page_from_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">kernel_pool</span><span class="p">,</span> <span class="n">pages</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kernel_pool</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_from_pool</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">user_pool</span><span class="p">,</span> <span class="n">pages</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">user_pool</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">NOT_REACHED</span> <span class="p">();</span>

  <span class="n">page_idx</span> <span class="o">=</span> <span class="n">pg_no</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="o">-</span> <span class="n">pg_no</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>

<span class="cp">#ifndef NDEBUG
</span>  <span class="n">memset</span> <span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="mh">0xcc</span><span class="p">,</span> <span class="n">PGSIZE</span> <span class="o">*</span> <span class="n">page_cnt</span><span class="p">);</span>
<span class="cp">#endif
</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">bitmap_all</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">used_map</span><span class="p">,</span> <span class="n">page_idx</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">));</span>
  <span class="n">bitmap_set_multiple</span> <span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">used_map</span><span class="p">,</span> <span class="n">page_idx</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>释放流程</strong>：</p>

<ol>
  <li><strong>地址验证</strong>：检查地址是否页对齐</li>
  <li><strong>确定所属池</strong>：判断页属于内核池还是用户池</li>
  <li><strong>计算页索引</strong>：<code class="language-plaintext highlighter-rouge">page_idx = 页号 - 池基址页号</code></li>
  <li><strong>调试填充</strong>：非 Release 版本填充 <code class="language-plaintext highlighter-rouge">0xCC</code>（帮助检测 use-after-free）</li>
  <li><strong>更新位图</strong>：将对应位设置为 0（空闲）</li>
</ol>

<h3 id="块释放-free"><span class="me-2">块释放 free()</span><a href="#块释放-free" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">free</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>释放流程</strong>：</p>

<ol>
  <li>找到块所属的 Arena</li>
  <li>验证 Arena 魔数</li>
  <li>获取描述符锁</li>
  <li>将块加入空闲链表</li>
  <li>如果 Arena 完全空闲：
    <ul>
      <li>从空闲链表移除所有块</li>
      <li>归还页给页分配器</li>
    </ul>
  </li>
  <li>释放描述符锁</li>
</ol>

<h2 id="内存分配标志"><span class="me-2">内存分配标志</span><a href="#内存分配标志" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">palloc_flags</span>
  <span class="p">{</span>
    <span class="n">PAL_ASSERT</span> <span class="o">=</span> <span class="mo">001</span><span class="p">,</span>   <span class="cm">/* 分配失败时 panic */</span>
    <span class="n">PAL_ZERO</span> <span class="o">=</span> <span class="mo">002</span><span class="p">,</span>     <span class="cm">/* 将页清零 */</span>
    <span class="n">PAL_USER</span> <span class="o">=</span> <span class="mo">004</span>      <span class="cm">/* 从用户池分配 */</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>使用示例</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="cm">/* 分配一个清零的内核页 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">kpage</span> <span class="o">=</span> <span class="n">palloc_get_page</span><span class="p">(</span><span class="n">PAL_ZERO</span><span class="p">);</span>

<span class="cm">/* 分配一个用户页，失败时 panic */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">upage</span> <span class="o">=</span> <span class="n">palloc_get_page</span><span class="p">(</span><span class="n">PAL_USER</span> <span class="o">|</span> <span class="n">PAL_ASSERT</span><span class="p">);</span>

<span class="cm">/* 分配 4 个连续的内核页 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">pages</span> <span class="o">=</span> <span class="n">palloc_get_multiple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="arena-内存布局"><span class="me-2">Arena 内存布局</span><a href="#arena-内存布局" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>单个 Arena 的详细布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>Arena (4096 字节 = 1 页)
┌─────────────────────────────────┐ offset 0
│          struct arena           │
│  ┌─────────────────────────┐   │
│  │ magic = 0x9a548eed      │   │ 4 bytes
│  ├─────────────────────────┤   │
│  │ desc (指向描述符)       │   │ 4 bytes
│  ├─────────────────────────┤   │
│  │ free_cnt                │   │ 4 bytes
│  └─────────────────────────┘   │
├─────────────────────────────────┤ offset ~12
│           Block 0               │
│  ┌─────────────────────────┐   │
│  │ free_elem (if free)     │   │
│  │ 或 用户数据 (if used)   │   │
│  └─────────────────────────┘   │
├─────────────────────────────────┤
│           Block 1               │
├─────────────────────────────────┤
│            ...                  │
├─────────────────────────────────┤
│    Block (blocks_per_arena-1)   │
└─────────────────────────────────┘ offset 4096
</pre></td></tr></tbody></table></code></div></div>

<h2 id="大块分配"><span class="me-2">大块分配</span><a href="#大块分配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>对于超过 1KB 的分配请求：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">descs</span> <span class="o">+</span> <span class="n">desc_cnt</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="cm">/* SIZE is too big for any descriptor.
     Allocate enough pages to hold SIZE plus an arena. */</span>
  <span class="kt">size_t</span> <span class="n">page_cnt</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">palloc_get_multiple</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="cm">/* Initialize the arena to indicate a big block of PAGE_CNT
     pages, and return it. */</span>
  <span class="n">a</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">ARENA_MAGIC</span><span class="p">;</span>
  <span class="n">a</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>          <span class="cm">/* 标记为大块 */</span>
  <span class="n">a</span><span class="o">-&gt;</span><span class="n">free_cnt</span> <span class="o">=</span> <span class="n">page_cnt</span><span class="p">;</span>  <span class="cm">/* 存储页数 */</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>大块布局</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>┌─────────────────────────────────┐
│          struct arena           │  第 0 页
│  ┌─────────────────────────┐   │
│  │ magic = 0x9a548eed      │   │
│  │ desc = NULL (大块标记)   │   │
│  │ free_cnt = 页数         │   │
│  └─────────────────────────┘   │
├─────────────────────────────────┤
│                                 │
│         用户数据区              │
│       (page_cnt * 4KB          │
│        - sizeof arena)         │
│                                 │
└─────────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<h2 id="调试支持"><span class="me-2">调试支持</span><a href="#调试支持" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="use-after-free-检测"><span class="me-2">Use-After-Free 检测</span><a href="#use-after-free-检测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="cp">#ifndef NDEBUG
</span>  <span class="cm">/* Clear the block to help detect use-after-free bugs. */</span>
  <span class="n">memset</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mh">0xcc</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>释放的内存填充 <code class="language-plaintext highlighter-rouge">0xCC</code></li>
  <li>如果程序访问已释放的内存，会读到 <code class="language-plaintext highlighter-rouge">0xCCCCCCCC</code></li>
  <li>这个值作为指针是无效的，容易暴露 bug</li>
</ul>

<h3 id="arena-完整性检查"><span class="me-2">Arena 完整性检查</span><a href="#arena-完整性检查" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cm">/* Check that the arena is valid. */</span>
<span class="n">ASSERT</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">ASSERT</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">ARENA_MAGIC</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>魔数 <code class="language-plaintext highlighter-rouge">0x9a548eed</code> 检测内存损坏</li>
  <li>如果 Arena 头部被覆写，魔数会变化</li>
</ul>

<h2 id="常见问题解答"><span class="me-2">常见问题解答</span><a href="#常见问题解答" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="q1-为什么需要两个内存池"><span class="me-2">Q1: 为什么需要两个内存池？</span><a href="#q1-为什么需要两个内存池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: 分离内核和用户内存有多个好处：</p>
<ol>
  <li><strong>安全性</strong>：用户程序无法直接访问内核内存</li>
  <li><strong>资源控制</strong>：可以限制用户程序的内存使用</li>
  <li><strong>简化回收</strong>：进程退出时只需回收用户池中的页</li>
</ol>

<h3 id="q2-为什么-malloc-使用-2-的幂次块大小"><span class="me-2">Q2: 为什么 malloc 使用 2 的幂次块大小？</span><a href="#q2-为什么-malloc-使用-2-的幂次块大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ol>
  <li><strong>对齐友好</strong>：2 的幂次自然满足各种对齐要求</li>
  <li><strong>减少碎片</strong>：标准化的块大小减少外部碎片</li>
  <li><strong>快速匹配</strong>：可以用位操作快速找到合适的描述符</li>
  <li><strong>内部碎片可控</strong>：最多浪费 50%</li>
</ol>

<h3 id="q3-如何处理内存碎片"><span class="me-2">Q3: 如何处理内存碎片？</span><a href="#q3-如何处理内存碎片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: Pintos 的设计减少了碎片：</p>
<ol>
  <li><strong>页分配器</strong>：只有外部碎片（无法找到连续空闲页）</li>
  <li><strong>块分配器</strong>：
    <ul>
      <li>内部碎片：请求 20 字节分配 32 字节</li>
      <li>外部碎片：通过 Arena 归还机制缓解</li>
    </ul>
  </li>
</ol>

<h3 id="q4-palloc_init-为什么从-1mb-开始"><span class="me-2">Q4: palloc_init 为什么从 1MB 开始？</span><a href="#q4-palloc_init-为什么从-1mb-开始" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: 低 1MB 内存布局复杂：</p>
<ul>
  <li>0-1KB：实模式中断向量表</li>
  <li>1KB-640KB：常规内存（但已被内核占用）</li>
  <li>640KB-1MB：VGA 和 BIOS ROM</li>
</ul>

<p>从 1MB 开始可以获得干净的连续内存。</p>

<h2 id="练习题"><span class="me-2">练习题</span><a href="#练习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="练习1分析内存效率"><span class="me-2">练习1：分析内存效率</span><a href="#练习1分析内存效率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>假设系统有 8MB 物理内存，计算：</p>
<ol>
  <li>内核池和用户池各有多少可用页？</li>
  <li>内核池位图占用多少空间？</li>
</ol>

<p><strong>提示</strong>：</p>
<ul>
  <li>可用内存 = 8MB - 1MB = 7MB</li>
  <li>总页数 = 7MB / 4KB = 1792 页</li>
</ul>

<h3 id="练习2理解-malloc-选择"><span class="me-2">练习2：理解 malloc 选择</span><a href="#练习2理解-malloc-选择" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>对于以下分配请求，malloc 会使用哪个描述符？</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">malloc(1)</code></li>
  <li><code class="language-plaintext highlighter-rouge">malloc(17)</code></li>
  <li><code class="language-plaintext highlighter-rouge">malloc(1000)</code></li>
  <li><code class="language-plaintext highlighter-rouge">malloc(2000)</code></li>
  <li><code class="language-plaintext highlighter-rouge">malloc(5000)</code></li>
</ol>

<h3 id="练习3实现内存统计"><span class="me-2">练习3：实现内存统计</span><a href="#练习3实现内存统计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>在 <code class="language-plaintext highlighter-rouge">palloc.c</code> 中添加函数，返回当前可用的空闲页数：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="nf">palloc_free_pages</span><span class="p">(</span><span class="k">enum</span> <span class="n">palloc_flags</span> <span class="n">flags</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="练习4分析并发安全"><span class="me-2">练习4：分析并发安全</span><a href="#练习4分析并发安全" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>分析以下场景是否线程安全：</p>
<ol>
  <li>线程 A 调用 <code class="language-plaintext highlighter-rouge">malloc(32)</code>，线程 B 调用 <code class="language-plaintext highlighter-rouge">malloc(64)</code></li>
  <li>线程 A 调用 <code class="language-plaintext highlighter-rouge">malloc(32)</code>，线程 B 调用 <code class="language-plaintext highlighter-rouge">malloc(32)</code></li>
  <li>线程 A 调用 <code class="language-plaintext highlighter-rouge">palloc_get_page(PAL_USER)</code>，线程 B 调用 <code class="language-plaintext highlighter-rouge">palloc_get_page(0)</code></li>
</ol>

<h2 id="下一篇预告"><span class="me-2">下一篇预告</span><a href="#下一篇预告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>在下一篇文档中，我们将详细解析 <code class="language-plaintext highlighter-rouge">paging_init()</code> 函数，了解 Pintos 如何建立永久的页表结构，替换 <code class="language-plaintext highlighter-rouge">start.S</code> 中创建的临时页表。</p>

<h2 id="参考资料"><span class="me-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<ol>
  <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer’s Manual</a></li>
  <li><a href="https://web.stanford.edu/class/cs140/projects/pintos/pintos_6.html">Pintos Documentation - Memory Allocation</a></li>
  <li><a href="https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a">The Slab Allocator: An Object-Caching Kernel Memory Allocator</a></li>
</ol>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">分享</span>
  <span class="share-icons">
    
    
    

    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="分享链接"
      data-title-succeed="链接已复制！"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">最近更新</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-03-create/">Pintos 线程系统详解（三）：线程创建</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-04-schedule/">Pintos 线程系统详解（四）：线程调度</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-05-switch/">Pintos 线程系统详解（五）：上下文切换</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-06-block-unblock/">Pintos 线程系统详解（六）：阻塞与唤醒</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-07-semaphore/">Pintos 线程系统详解（七）：信号量</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


            </div>

            
              
              






  <div class="toc-border-cover z-3"></div>
  <section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4">
    <h2 class="panel-heading ps-3 pb-2 mb-0">文章内容</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->


























            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/pintos-kernel-09-command-line/"
      class="btn btn-outline-primary"
      aria-label="上一篇"
    >
      <p>Pintos Kernel 启动详解（九）：命令行解析</p>
    </a>
  

  
    <a
      href="/posts/pintos-kernel-11-paging-init/"
      class="btn btn-outline-primary"
      aria-label="下一篇"
    >
      <p>Pintos Kernel 11 Paging Init</p>
    </a>
  
</nav>

            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2026</time>

    
      <a href="https://github.com/zxsheather">Zxsheather</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"
      >保留部分权利。</span>
    
  </p>

  <p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v7.4.1"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center d-none">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">发现新版本的内容。</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      更新
    </button>
  </div>
</aside>

    

    <!-- Embedded scripts -->

    
      
      <!-- The comments switcher -->


    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  
  document.addEventListener('DOMContentLoaded', () => {
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('search-results'),
      json: '/assets/js/data/search.json',
      searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{content}</p>  </article>',
      noResultsText: '<p class="mt-5">搜索结果为空</p>',
      templateMiddleware: function(prop, value, template) {
        if (prop === 'categories') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
          }
        }

        if (prop === 'tags') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
          }
        }
      }
    });
  });
</script>

  </body>
</html>

