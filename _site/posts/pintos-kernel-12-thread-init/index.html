<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="zh-CN" >
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  ><!-- Setup Open Graph image -->

  

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Pintos Kernel 12 Thread Init" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Pintos 内核启动（十二）：线程系统初始化 概述 本文档详细解析 Pintos 内核的线程系统初始化过程，包括 thread_init() 和 thread_start() 两个关键函数。线程是操作系统调度的基本单位，线程系统的正确初始化是内核正常运行的基础。 Pintos 的线程系统具有以下特点： 每个线程占用一个页：线程结构体位于页底部，栈从页顶向下增长 简单的调度器：默认使用轮转调度（Round-Robin） 主线程转换：将当前执行流转换为正式的线程 原始代码 thread.c 中的 thread_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** Initializes the threading system by transforming the code that&#39;s currently running into a thread. This can&#39;t work in general and it is possible in this case only because loader.S was careful to put the bottom of the stack at a page boundary. Also initializes the run queue and the tid lock. After calling this function, be sure to initialize the page allocator before trying to create any threads with thread_create(). It is not safe to call thread_current() until this function finishes. */ void thread_init (void) { ASSERT (intr_get_level () == INTR_OFF); lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); /* Set up a thread structure for the running thread. */ initial_thread = running_thread (); init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); } thread.c 中的 thread_start() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** Starts preemptive thread scheduling by enabling interrupts. Also creates the idle thread. */ void thread_start (void) { /* Create the idle thread. */ struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); /* Start preemptive thread scheduling. */ intr_enable (); /* Wait for the idle thread to initialize idle_thread. */ sema_down (&amp;idle_started); } thread.h 中的 struct thread 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct thread { /* Owned by thread.c. */ tid_t tid; /* Thread identifier. */ enum thread_status status; /* Thread state. */ char name[16]; /* Name (for debugging purposes). */ uint8_t *stack; /* Saved stack pointer. */ int priority; /* Priority. */ struct list_elem allelem; /* List element for all threads list. */ /* Shared between thread.c and synch.c. */ struct list_elem elem; /* List element. */ #ifdef USERPROG /* Owned by userprog/process.c. */ uint32_t *pagedir; /* Page directory. */ #endif /* Owned by thread.c. */ unsigned magic; /* Detects stack overflow. */ }; 前置知识 1. 线程内存布局 Pintos 中每个线程占用一个完整的 4KB 页： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 4 kB +---------------------------------+ | kernel stack | | | | | | | | V | | grows downward | | | | | | | | | | | | | | | | | +---------------------------------+ | magic | | : | | : | | name | | status | 0 kB +---------------------------------+ 这种设计的优点： 快速定位线程结构：将栈指针向下取整到页边界即可找到线程结构 栈溢出检测：通过检查 magic 成员是否被覆写 简化内存管理：分配/释放线程只需操作一个页 2. 线程状态 1 2 3 4 5 6 7 enum thread_status { THREAD_RUNNING, /* Running thread. */ THREAD_READY, /* Not running but ready to run. */ THREAD_BLOCKED, /* Waiting for an event to trigger. */ THREAD_DYING /* About to be destroyed. */ }; 状态转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 创建 │ ↓ ┌─────────────┐ │ BLOCKED │◄──────────────┐ └─────────────┘ │ │ │ │ unblock │ block (等待事件) ↓ │ ┌─────────────┐ 调度 ┌─────────────┐ │ │ RUNNING │◄──────│ READY │ │ └─────────────┘ └─────────────┘ │ │ ↑ │ │ │ │ │ yield/抢占 │ │ └─────────────────────┘ │ │ │ │ exit │ ↓ │ ┌─────────────┐ │ │ DYING │ │ └─────────────┘ │ 3. 线程优先级 1 2 3 #define PRI_MIN 0 /* Lowest priority. */ #define PRI_DEFAULT 31 /* Default priority. */ #define PRI_MAX 63 /* Highest priority. */ 优先级范围：0-63（64 个级别） 数值越大优先级越高 默认优先级为 31 4. 关键数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 就绪队列：等待运行的线程 */ static struct list ready_list; /* 所有线程列表 */ static struct list all_list; /* 空闲线程 */ static struct thread *idle_thread; /* 主线程（运行 init.c:main() 的线程）*/ static struct thread *initial_thread; /* TID 分配锁 */ static struct lock tid_lock; 逐行代码解析 thread_init() 函数解析 第1行：检查中断状态 1 ASSERT (intr_get_level () == INTR_OFF); 详细解析： 为什么需要关中断？ 初始化过程中修改共享数据结构 需要防止中断处理程序访问未初始化的数据 确保初始化的原子性 此时中断为什么是关闭的？ 从系统启动开始中断就是关闭的 intr_enable() 在 thread_start() 中才会被调用 第2-4行：初始化全局数据结构 1 2 3 lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); 详细解析： tid_lock 初始化： 用于保护线程 ID 的分配 确保每个线程获得唯一的 TID ready_list 初始化： 就绪队列，存放等待运行的线程 使用双向链表实现 all_list 初始化： 所有线程的列表 用于调试和遍历所有线程 链表初始状态： 1 2 3 4 5 6 7 8 9 10 11 12 13 ready_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ all_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ 第5行：获取当前线程结构体 1 initial_thread = running_thread (); 详细解析： running_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 struct thread * running_thread (void) { uint32_t *esp; /* Copy the CPU&#39;s stack pointer into `esp&#39;, and then round that down to the start of a page. Because `struct thread&#39; is always at the beginning of a page and the stack pointer is somewhere in the middle, this locates the current thread. */ asm (&quot;mov %%esp, %0&quot; : &quot;=g&quot; (esp)); return pg_round_down (esp); } 工作原理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 当前内存布局： ESP 在这里 ↓ ┌───────────────────────────────────────────┐ 页顶 (页基址 + 4KB) │ 栈内容 │ │ (函数调用等) │ ├───────────────────────────────────────────┤ ESP 指向的位置 │ │ │ 未使用的栈空间 │ │ │ ├───────────────────────────────────────────┤ │ │ │ struct thread (未初始化) │ │ │ └───────────────────────────────────────────┘ 页底 (页基址) pg_round_down(ESP) = 页底地址 = struct thread 地址 为什么这能工作？ loader.S 精心设置了初始栈位置，使其底部对齐到页边界 初始栈在内核 BSS 段的末尾 这个页在 thread_init 之前就已经被当作”主线程”的页使用 第6行：初始化线程结构体 1 init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); 详细解析： init_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static void init_thread (struct thread *t, const char *name, int priority) { enum intr_level old_level; ASSERT (t != NULL); ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX); ASSERT (name != NULL); memset (t, 0, sizeof *t); t-&gt;status = THREAD_BLOCKED; strlcpy (t-&gt;name, name, sizeof t-&gt;name); t-&gt;stack = (uint8_t *) t + PGSIZE; t-&gt;priority = priority; t-&gt;magic = THREAD_MAGIC; old_level = intr_disable (); list_push_back (&amp;all_list, &amp;t-&gt;allelem); intr_set_level (old_level); } 逐步解析： memset 清零：将整个结构体清零 status = THREAD_BLOCKED：初始状态为阻塞（稍后会改为 RUNNING） strlcpy name：复制线程名称（最多 15 字符 + ‘\0’） stack = t + PGSIZE：栈指针初始化到页顶 priority：设置优先级 magic = THREAD_MAGIC：设置魔数（用于检测栈溢出） 加入 all_list：将线程添加到所有线程列表 初始化后的布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 4 KB ┌───────────────────────────────┐ t-&gt;stack 指向这里 │ │ │ (栈空间) │ │ │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b │ 栈溢出检测 ├───────────────────────────────┤ │ priority = 31 │ ├───────────────────────────────┤ │ stack (指向页顶) │ ├───────────────────────────────┤ │ name = &quot;main\0...&quot; │ ├───────────────────────────────┤ │ status = THREAD_BLOCKED │ ├───────────────────────────────┤ │ tid = 0 (未分配) │ 0 KB └───────────────────────────────┘ initial_thread 指向这里 第7-8行：设置运行状态和分配 TID 1 2 initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); 详细解析： 状态改为 RUNNING： 主线程当前正在运行 覆盖 init_thread 设置的 BLOCKED 状态 分配 TID： allocate_tid() 返回下一个可用的线程 ID 主线程的 TID 为 1 allocate_tid() 实现： 1 2 3 4 5 6 7 8 9 10 11 12 static tid_t allocate_tid (void) { static tid_t next_tid = 1; tid_t tid; lock_acquire (&amp;tid_lock); tid = next_tid++; lock_release (&amp;tid_lock); return tid; } 注意：虽然此时还没有其他线程，但使用锁是好习惯，确保代码的正确性。 thread_start() 函数解析 第1-3行：创建空闲线程同步信号量 1 2 3 struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); 详细解析： 信号量目的： 等待空闲线程完成初始化 确保 idle_thread 变量被正确设置 thread_create 参数： &quot;idle&quot;：线程名称 PRI_MIN：最低优先级（0） idle：线程函数 &amp;idle_started：传递给 idle 函数的参数 为什么需要空闲线程？ 当没有其他线程就绪时，CPU 需要运行某些东西 空闲线程执行 hlt 指令，使 CPU 进入低功耗状态 这比忙等待更节能 第4行：启用中断 1 intr_enable (); 详细解析： 从这一刻起，定时器中断开始触发 抢占式调度正式开始 空闲线程可能在这之后被调度运行 第5行：等待空闲线程初始化 1 sema_down (&amp;idle_started); 详细解析： 这里可能发生以下情况： 场景1：空闲线程先运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │────────────────────────→│ │ │ │ enable interrupts │ │ │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ │ │ sema_down() (直接成功) │ │ │ 场景2：主线程继续运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │ │ (在 ready_list 中) │ enable interrupts │ │ │ │ sema_down() │ │ (阻塞，信号量=0) │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ (唤醒) │ │ │ idle() 函数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static void idle (void *idle_started_ UNUSED) { struct semaphore *idle_started = idle_started_; idle_thread = thread_current (); sema_up (idle_started); for (;;) { /* Let someone else run. */ intr_disable (); thread_block (); /* Re-enable interrupts and wait for the next one. The `sti&#39; instruction disables interrupts until the completion of the next instruction, so these two instructions are executed atomically. This atomicity is important; otherwise, an interrupt could be handled between re-enabling interrupts and waiting for the next one to occur, wasting as much as one clock tick worth of time. */ asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } } 详细解析： 设置 idle_thread： 保存自己的线程指针到全局变量 供调度器在就绪队列为空时使用 通知主线程： sema_up() 释放信号量 允许主线程继续执行 无限循环： 1 2 3 4 5 6 7 for (;;) { intr_disable (); // 关中断 thread_block (); // 阻塞自己，调度其他线程 // 被唤醒后执行 asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } sti; hlt 原子性： sti：开中断 hlt：停止 CPU 直到下一个中断 x86 保证 sti 后的第一条指令不会被中断 这确保了 hlt 能够被执行 为什么需要这种原子性？ 1 2 3 4 5 6 7 如果不是原子的： 时刻 T: sti (开中断) 时刻 T+1: [中断到来] (处理中断，可能唤醒某个线程) 时刻 T+2: hlt (进入睡眠，但应该运行被唤醒的线程！) 结果：浪费了处理器时间 thread_create() 函数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 tid_t thread_create (const char *name, int priority, thread_func *function, void *aux) { struct thread *t; struct kernel_thread_frame *kf; struct switch_entry_frame *ef; struct switch_threads_frame *sf; tid_t tid; ASSERT (function != NULL); /* Allocate thread. */ t = palloc_get_page (PAL_ZERO); if (t == NULL) return TID_ERROR; /* Initialize thread. */ init_thread (t, name, priority); tid = t-&gt;tid = allocate_tid (); /* Stack frame for kernel_thread(). */ kf = alloc_frame (t, sizeof *kf); kf-&gt;eip = NULL; kf-&gt;function = function; kf-&gt;aux = aux; /* Stack frame for switch_entry(). */ ef = alloc_frame (t, sizeof *ef); ef-&gt;eip = (void (*) (void)) kernel_thread; /* Stack frame for switch_threads(). */ sf = alloc_frame (t, sizeof *sf); sf-&gt;eip = switch_entry; sf-&gt;ebp = 0; /* Add to run queue. */ thread_unblock (t); return tid; } 栈帧布局： 新线程创建后，其栈的布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 4 KB ┌───────────────────────────────┐ │ │ │ (未使用的栈空间) │ │ │ ├───────────────────────────────┤ │ kernel_thread_frame │ │ ┌─────────────────────────┐ │ │ │ eip = NULL (返回地址) │ │ │ │ function (线程函数) │ │ │ │ aux (辅助参数) │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_entry_frame │ │ ┌─────────────────────────┐ │ │ │ eip = kernel_thread │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_threads_frame │ │ ┌─────────────────────────┐ │ │ │ eip = switch_entry │ │ ← t-&gt;stack │ │ ebp = 0 │ │ │ │ ebx, esi, edi = 0 │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ struct thread │ │ (tid, name, priority, ...) │ 0 KB └───────────────────────────────┘ 首次调度时的执行流： 1 2 3 4 5 6 7 8 9 10 1. switch_threads() 恢复 sf 中的寄存器 └→ ret 执行，跳转到 switch_entry 2. switch_entry (in switch.S) └→ ret 执行，跳转到 kernel_thread 3. kernel_thread() intr_enable(); // 开中断 function(aux); // 执行用户提供的函数 thread_exit(); // 线程结束 调度器核心函数 schedule() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void schedule (void) { struct thread *cur = running_thread (); struct thread *next = next_thread_to_run (); struct thread *prev = NULL; ASSERT (intr_get_level () == INTR_OFF); ASSERT (cur-&gt;status != THREAD_RUNNING); ASSERT (is_thread (next)); if (cur != next) prev = switch_threads (cur, next); thread_schedule_tail (prev); } 调度流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 schedule() │ ├─→ cur = 当前线程 │ ├─→ next = next_thread_to_run() │ │ │ ├─→ ready_list 非空? 取出第一个线程 │ │ │ └─→ ready_list 为空? 返回 idle_thread │ ├─→ cur == next? ─→ 是 ─→ 跳过切换 │ │ │ └─→ 否 ─→ switch_threads(cur, next) │ │ │ └─→ 保存 cur 的寄存器 │ 恢复 next 的寄存器 │ 返回 prev (= cur) │ └─→ thread_schedule_tail(prev) │ ├─→ 标记新线程为 RUNNING │ ├─→ 重置时间片计数器 │ └─→ 如果 prev 正在死亡，释放其内存 switch_threads() 函数 (switch.S) .globl switch_threads .func switch_threads switch_threads: # Save caller&#39;s register state. pushl %ebx pushl %ebp pushl %esi pushl %edi # Get offsetof (struct thread, stack). mov thread_stack_ofs, %edx # Save current stack pointer to old thread&#39;s stack. movl SWITCH_CUR(%esp), %eax movl %esp, (%eax,%edx,1) # Restore stack pointer from new thread&#39;s stack. movl SWITCH_NEXT(%esp), %ecx movl (%ecx,%edx,1), %esp # Restore caller&#39;s register state. popl %edi popl %esi popl %ebp popl %ebx ret .endfunc 线程切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 切换前： 切换后： 线程 A (cur) 线程 B (next) ┌─────────────┐ ┌─────────────┐ │ 栈顶 │ │ 栈顶 │ │ │ │ │ │ │ │ ↓ │ │ ↓ │ │ │ │ │ │ [保存的寄存器]│◄── A-&gt;stack │ [保存的寄存器]│◄── B-&gt;stack └─────────────┘ └─────────────┘ ↑ │ │ │ ESP ESP switch_threads() ──────────────────────────────→ 保存 A 的 ESP 到 A-&gt;stack 从 B-&gt;stack 恢复 ESP 线程生命周期 完整生命周期示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1. 创建阶段 thread_create(&quot;worker&quot;, PRI_DEFAULT, worker_func, arg) │ ├─→ 分配一页内存 ├─→ 初始化 thread 结构体 ├─→ 设置栈帧 └─→ thread_unblock() → 加入 ready_list 状态: BLOCKED → READY 2. 首次运行 schedule() 选中新线程 │ ├─→ switch_threads() 切换栈 ├─→ switch_entry → kernel_thread └─→ function(aux) 开始执行 状态: READY → RUNNING 3. 正常运行 │ ├─→ 可能 yield → READY → RUNNING ├─→ 可能 block → BLOCKED → READY → RUNNING └─→ 继续执行 4. 退出阶段 thread_exit() │ ├─→ 从 all_list 移除 ├─→ 状态设为 DYING └─→ schedule() → 永不返回 5. 清理阶段 thread_schedule_tail() (由下一个线程执行) │ └─→ palloc_free_page(prev) 释放内存 魔数与栈溢出检测 THREAD_MAGIC 的作用 1 #define THREAD_MAGIC 0xcd6abf4b 检测机制： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static bool is_thread (struct thread *t) { return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; } struct thread * thread_current (void) { struct thread *t = running_thread (); /* Make sure T is really a thread. If either of these assertions fire, then your thread may have overflowed its stack. */ ASSERT (is_thread (t)); ASSERT (t-&gt;status == THREAD_RUNNING); return t; } 栈溢出示意： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 正常情况： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ ├───────────────────────────────┤ │ 空闲区 │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b ✓ │ │ ... 其他成员 ... │ └───────────────────────────────┘ 0 栈溢出后： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ │ ↓ │ │ ↓ │ ├───────────────────────────────┤ │ magic = ???????? ✗ (被覆盖) │ │ ... 被破坏的数据 ... │ └───────────────────────────────┘ 0 常见问题解答 Q1: 为什么主线程可以被”转换”而不是”创建”？ A: 系统启动时已经有代码在执行 这个执行流需要被纳入线程管理 loader.S 确保了栈底对齐到页边界 只需填充 thread 结构体即可 Q2: 为什么空闲线程优先级最低？ A: 空闲线程只在没有其他工作时运行 最低优先级确保它不会抢占任何实际工作 它的唯一目的是节省电力和等待中断 Q3: thread_create 中的多个栈帧有什么作用？ A: 模拟线程之前被调度过的状态： switch_threads_frame：模拟 switch_threads 调用点 switch_entry_frame：模拟返回到 kernel_thread 的入口 kernel_thread_frame：提供实际线程函数的参数 Q4: 为什么要等待空闲线程初始化？ A: 调度器需要 idle_thread 指针 当 ready_list 为空时返回 idle_thread 如果不等待，可能返回 NULL 导致崩溃 练习题 练习1：分析栈使用 给定以下递归函数，计算需要多少栈空间： 1 2 3 4 int factorial(int n) { if (n &lt;= 1) return 1; return n * factorial(n - 1); } 假设每次函数调用使用 32 字节栈空间，Pintos 线程最多能计算多大的阶乘？ 练习2：线程状态追踪 画出以下场景中两个线程的状态转换： 主线程创建线程 A 线程 A 运行并调用 sema_down() 阻塞 主线程调用 sema_up() 唤醒线程 A 线程 A 运行完毕退出 练习3：修改时间片 TIME_SLICE 定义为 4 个时钟周期。如果改为： TIME_SLICE = 1：会有什么影响？ TIME_SLICE = 100：会有什么影响？ 练习4：实现线程统计 添加一个函数 thread_count() 返回当前存活的线程数。 提示：使用 all_list 链表。 下一篇预告 在下一篇文档中，我们将详细解析中断系统的初始化 intr_init()，了解 Pintos 如何设置 IDT（中断描述符表）和处理各种中断。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Threads OSDev Wiki - Context Switching" />
<meta property="og:description" content="Pintos 内核启动（十二）：线程系统初始化 概述 本文档详细解析 Pintos 内核的线程系统初始化过程，包括 thread_init() 和 thread_start() 两个关键函数。线程是操作系统调度的基本单位，线程系统的正确初始化是内核正常运行的基础。 Pintos 的线程系统具有以下特点： 每个线程占用一个页：线程结构体位于页底部，栈从页顶向下增长 简单的调度器：默认使用轮转调度（Round-Robin） 主线程转换：将当前执行流转换为正式的线程 原始代码 thread.c 中的 thread_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** Initializes the threading system by transforming the code that&#39;s currently running into a thread. This can&#39;t work in general and it is possible in this case only because loader.S was careful to put the bottom of the stack at a page boundary. Also initializes the run queue and the tid lock. After calling this function, be sure to initialize the page allocator before trying to create any threads with thread_create(). It is not safe to call thread_current() until this function finishes. */ void thread_init (void) { ASSERT (intr_get_level () == INTR_OFF); lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); /* Set up a thread structure for the running thread. */ initial_thread = running_thread (); init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); } thread.c 中的 thread_start() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** Starts preemptive thread scheduling by enabling interrupts. Also creates the idle thread. */ void thread_start (void) { /* Create the idle thread. */ struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); /* Start preemptive thread scheduling. */ intr_enable (); /* Wait for the idle thread to initialize idle_thread. */ sema_down (&amp;idle_started); } thread.h 中的 struct thread 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct thread { /* Owned by thread.c. */ tid_t tid; /* Thread identifier. */ enum thread_status status; /* Thread state. */ char name[16]; /* Name (for debugging purposes). */ uint8_t *stack; /* Saved stack pointer. */ int priority; /* Priority. */ struct list_elem allelem; /* List element for all threads list. */ /* Shared between thread.c and synch.c. */ struct list_elem elem; /* List element. */ #ifdef USERPROG /* Owned by userprog/process.c. */ uint32_t *pagedir; /* Page directory. */ #endif /* Owned by thread.c. */ unsigned magic; /* Detects stack overflow. */ }; 前置知识 1. 线程内存布局 Pintos 中每个线程占用一个完整的 4KB 页： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 4 kB +---------------------------------+ | kernel stack | | | | | | | | V | | grows downward | | | | | | | | | | | | | | | | | +---------------------------------+ | magic | | : | | : | | name | | status | 0 kB +---------------------------------+ 这种设计的优点： 快速定位线程结构：将栈指针向下取整到页边界即可找到线程结构 栈溢出检测：通过检查 magic 成员是否被覆写 简化内存管理：分配/释放线程只需操作一个页 2. 线程状态 1 2 3 4 5 6 7 enum thread_status { THREAD_RUNNING, /* Running thread. */ THREAD_READY, /* Not running but ready to run. */ THREAD_BLOCKED, /* Waiting for an event to trigger. */ THREAD_DYING /* About to be destroyed. */ }; 状态转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 创建 │ ↓ ┌─────────────┐ │ BLOCKED │◄──────────────┐ └─────────────┘ │ │ │ │ unblock │ block (等待事件) ↓ │ ┌─────────────┐ 调度 ┌─────────────┐ │ │ RUNNING │◄──────│ READY │ │ └─────────────┘ └─────────────┘ │ │ ↑ │ │ │ │ │ yield/抢占 │ │ └─────────────────────┘ │ │ │ │ exit │ ↓ │ ┌─────────────┐ │ │ DYING │ │ └─────────────┘ │ 3. 线程优先级 1 2 3 #define PRI_MIN 0 /* Lowest priority. */ #define PRI_DEFAULT 31 /* Default priority. */ #define PRI_MAX 63 /* Highest priority. */ 优先级范围：0-63（64 个级别） 数值越大优先级越高 默认优先级为 31 4. 关键数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 就绪队列：等待运行的线程 */ static struct list ready_list; /* 所有线程列表 */ static struct list all_list; /* 空闲线程 */ static struct thread *idle_thread; /* 主线程（运行 init.c:main() 的线程）*/ static struct thread *initial_thread; /* TID 分配锁 */ static struct lock tid_lock; 逐行代码解析 thread_init() 函数解析 第1行：检查中断状态 1 ASSERT (intr_get_level () == INTR_OFF); 详细解析： 为什么需要关中断？ 初始化过程中修改共享数据结构 需要防止中断处理程序访问未初始化的数据 确保初始化的原子性 此时中断为什么是关闭的？ 从系统启动开始中断就是关闭的 intr_enable() 在 thread_start() 中才会被调用 第2-4行：初始化全局数据结构 1 2 3 lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); 详细解析： tid_lock 初始化： 用于保护线程 ID 的分配 确保每个线程获得唯一的 TID ready_list 初始化： 就绪队列，存放等待运行的线程 使用双向链表实现 all_list 初始化： 所有线程的列表 用于调试和遍历所有线程 链表初始状态： 1 2 3 4 5 6 7 8 9 10 11 12 13 ready_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ all_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ 第5行：获取当前线程结构体 1 initial_thread = running_thread (); 详细解析： running_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 struct thread * running_thread (void) { uint32_t *esp; /* Copy the CPU&#39;s stack pointer into `esp&#39;, and then round that down to the start of a page. Because `struct thread&#39; is always at the beginning of a page and the stack pointer is somewhere in the middle, this locates the current thread. */ asm (&quot;mov %%esp, %0&quot; : &quot;=g&quot; (esp)); return pg_round_down (esp); } 工作原理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 当前内存布局： ESP 在这里 ↓ ┌───────────────────────────────────────────┐ 页顶 (页基址 + 4KB) │ 栈内容 │ │ (函数调用等) │ ├───────────────────────────────────────────┤ ESP 指向的位置 │ │ │ 未使用的栈空间 │ │ │ ├───────────────────────────────────────────┤ │ │ │ struct thread (未初始化) │ │ │ └───────────────────────────────────────────┘ 页底 (页基址) pg_round_down(ESP) = 页底地址 = struct thread 地址 为什么这能工作？ loader.S 精心设置了初始栈位置，使其底部对齐到页边界 初始栈在内核 BSS 段的末尾 这个页在 thread_init 之前就已经被当作”主线程”的页使用 第6行：初始化线程结构体 1 init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); 详细解析： init_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static void init_thread (struct thread *t, const char *name, int priority) { enum intr_level old_level; ASSERT (t != NULL); ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX); ASSERT (name != NULL); memset (t, 0, sizeof *t); t-&gt;status = THREAD_BLOCKED; strlcpy (t-&gt;name, name, sizeof t-&gt;name); t-&gt;stack = (uint8_t *) t + PGSIZE; t-&gt;priority = priority; t-&gt;magic = THREAD_MAGIC; old_level = intr_disable (); list_push_back (&amp;all_list, &amp;t-&gt;allelem); intr_set_level (old_level); } 逐步解析： memset 清零：将整个结构体清零 status = THREAD_BLOCKED：初始状态为阻塞（稍后会改为 RUNNING） strlcpy name：复制线程名称（最多 15 字符 + ‘\0’） stack = t + PGSIZE：栈指针初始化到页顶 priority：设置优先级 magic = THREAD_MAGIC：设置魔数（用于检测栈溢出） 加入 all_list：将线程添加到所有线程列表 初始化后的布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 4 KB ┌───────────────────────────────┐ t-&gt;stack 指向这里 │ │ │ (栈空间) │ │ │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b │ 栈溢出检测 ├───────────────────────────────┤ │ priority = 31 │ ├───────────────────────────────┤ │ stack (指向页顶) │ ├───────────────────────────────┤ │ name = &quot;main\0...&quot; │ ├───────────────────────────────┤ │ status = THREAD_BLOCKED │ ├───────────────────────────────┤ │ tid = 0 (未分配) │ 0 KB └───────────────────────────────┘ initial_thread 指向这里 第7-8行：设置运行状态和分配 TID 1 2 initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); 详细解析： 状态改为 RUNNING： 主线程当前正在运行 覆盖 init_thread 设置的 BLOCKED 状态 分配 TID： allocate_tid() 返回下一个可用的线程 ID 主线程的 TID 为 1 allocate_tid() 实现： 1 2 3 4 5 6 7 8 9 10 11 12 static tid_t allocate_tid (void) { static tid_t next_tid = 1; tid_t tid; lock_acquire (&amp;tid_lock); tid = next_tid++; lock_release (&amp;tid_lock); return tid; } 注意：虽然此时还没有其他线程，但使用锁是好习惯，确保代码的正确性。 thread_start() 函数解析 第1-3行：创建空闲线程同步信号量 1 2 3 struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); 详细解析： 信号量目的： 等待空闲线程完成初始化 确保 idle_thread 变量被正确设置 thread_create 参数： &quot;idle&quot;：线程名称 PRI_MIN：最低优先级（0） idle：线程函数 &amp;idle_started：传递给 idle 函数的参数 为什么需要空闲线程？ 当没有其他线程就绪时，CPU 需要运行某些东西 空闲线程执行 hlt 指令，使 CPU 进入低功耗状态 这比忙等待更节能 第4行：启用中断 1 intr_enable (); 详细解析： 从这一刻起，定时器中断开始触发 抢占式调度正式开始 空闲线程可能在这之后被调度运行 第5行：等待空闲线程初始化 1 sema_down (&amp;idle_started); 详细解析： 这里可能发生以下情况： 场景1：空闲线程先运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │────────────────────────→│ │ │ │ enable interrupts │ │ │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ │ │ sema_down() (直接成功) │ │ │ 场景2：主线程继续运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │ │ (在 ready_list 中) │ enable interrupts │ │ │ │ sema_down() │ │ (阻塞，信号量=0) │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ (唤醒) │ │ │ idle() 函数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static void idle (void *idle_started_ UNUSED) { struct semaphore *idle_started = idle_started_; idle_thread = thread_current (); sema_up (idle_started); for (;;) { /* Let someone else run. */ intr_disable (); thread_block (); /* Re-enable interrupts and wait for the next one. The `sti&#39; instruction disables interrupts until the completion of the next instruction, so these two instructions are executed atomically. This atomicity is important; otherwise, an interrupt could be handled between re-enabling interrupts and waiting for the next one to occur, wasting as much as one clock tick worth of time. */ asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } } 详细解析： 设置 idle_thread： 保存自己的线程指针到全局变量 供调度器在就绪队列为空时使用 通知主线程： sema_up() 释放信号量 允许主线程继续执行 无限循环： 1 2 3 4 5 6 7 for (;;) { intr_disable (); // 关中断 thread_block (); // 阻塞自己，调度其他线程 // 被唤醒后执行 asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } sti; hlt 原子性： sti：开中断 hlt：停止 CPU 直到下一个中断 x86 保证 sti 后的第一条指令不会被中断 这确保了 hlt 能够被执行 为什么需要这种原子性？ 1 2 3 4 5 6 7 如果不是原子的： 时刻 T: sti (开中断) 时刻 T+1: [中断到来] (处理中断，可能唤醒某个线程) 时刻 T+2: hlt (进入睡眠，但应该运行被唤醒的线程！) 结果：浪费了处理器时间 thread_create() 函数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 tid_t thread_create (const char *name, int priority, thread_func *function, void *aux) { struct thread *t; struct kernel_thread_frame *kf; struct switch_entry_frame *ef; struct switch_threads_frame *sf; tid_t tid; ASSERT (function != NULL); /* Allocate thread. */ t = palloc_get_page (PAL_ZERO); if (t == NULL) return TID_ERROR; /* Initialize thread. */ init_thread (t, name, priority); tid = t-&gt;tid = allocate_tid (); /* Stack frame for kernel_thread(). */ kf = alloc_frame (t, sizeof *kf); kf-&gt;eip = NULL; kf-&gt;function = function; kf-&gt;aux = aux; /* Stack frame for switch_entry(). */ ef = alloc_frame (t, sizeof *ef); ef-&gt;eip = (void (*) (void)) kernel_thread; /* Stack frame for switch_threads(). */ sf = alloc_frame (t, sizeof *sf); sf-&gt;eip = switch_entry; sf-&gt;ebp = 0; /* Add to run queue. */ thread_unblock (t); return tid; } 栈帧布局： 新线程创建后，其栈的布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 4 KB ┌───────────────────────────────┐ │ │ │ (未使用的栈空间) │ │ │ ├───────────────────────────────┤ │ kernel_thread_frame │ │ ┌─────────────────────────┐ │ │ │ eip = NULL (返回地址) │ │ │ │ function (线程函数) │ │ │ │ aux (辅助参数) │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_entry_frame │ │ ┌─────────────────────────┐ │ │ │ eip = kernel_thread │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_threads_frame │ │ ┌─────────────────────────┐ │ │ │ eip = switch_entry │ │ ← t-&gt;stack │ │ ebp = 0 │ │ │ │ ebx, esi, edi = 0 │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ struct thread │ │ (tid, name, priority, ...) │ 0 KB └───────────────────────────────┘ 首次调度时的执行流： 1 2 3 4 5 6 7 8 9 10 1. switch_threads() 恢复 sf 中的寄存器 └→ ret 执行，跳转到 switch_entry 2. switch_entry (in switch.S) └→ ret 执行，跳转到 kernel_thread 3. kernel_thread() intr_enable(); // 开中断 function(aux); // 执行用户提供的函数 thread_exit(); // 线程结束 调度器核心函数 schedule() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void schedule (void) { struct thread *cur = running_thread (); struct thread *next = next_thread_to_run (); struct thread *prev = NULL; ASSERT (intr_get_level () == INTR_OFF); ASSERT (cur-&gt;status != THREAD_RUNNING); ASSERT (is_thread (next)); if (cur != next) prev = switch_threads (cur, next); thread_schedule_tail (prev); } 调度流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 schedule() │ ├─→ cur = 当前线程 │ ├─→ next = next_thread_to_run() │ │ │ ├─→ ready_list 非空? 取出第一个线程 │ │ │ └─→ ready_list 为空? 返回 idle_thread │ ├─→ cur == next? ─→ 是 ─→ 跳过切换 │ │ │ └─→ 否 ─→ switch_threads(cur, next) │ │ │ └─→ 保存 cur 的寄存器 │ 恢复 next 的寄存器 │ 返回 prev (= cur) │ └─→ thread_schedule_tail(prev) │ ├─→ 标记新线程为 RUNNING │ ├─→ 重置时间片计数器 │ └─→ 如果 prev 正在死亡，释放其内存 switch_threads() 函数 (switch.S) .globl switch_threads .func switch_threads switch_threads: # Save caller&#39;s register state. pushl %ebx pushl %ebp pushl %esi pushl %edi # Get offsetof (struct thread, stack). mov thread_stack_ofs, %edx # Save current stack pointer to old thread&#39;s stack. movl SWITCH_CUR(%esp), %eax movl %esp, (%eax,%edx,1) # Restore stack pointer from new thread&#39;s stack. movl SWITCH_NEXT(%esp), %ecx movl (%ecx,%edx,1), %esp # Restore caller&#39;s register state. popl %edi popl %esi popl %ebp popl %ebx ret .endfunc 线程切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 切换前： 切换后： 线程 A (cur) 线程 B (next) ┌─────────────┐ ┌─────────────┐ │ 栈顶 │ │ 栈顶 │ │ │ │ │ │ │ │ ↓ │ │ ↓ │ │ │ │ │ │ [保存的寄存器]│◄── A-&gt;stack │ [保存的寄存器]│◄── B-&gt;stack └─────────────┘ └─────────────┘ ↑ │ │ │ ESP ESP switch_threads() ──────────────────────────────→ 保存 A 的 ESP 到 A-&gt;stack 从 B-&gt;stack 恢复 ESP 线程生命周期 完整生命周期示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1. 创建阶段 thread_create(&quot;worker&quot;, PRI_DEFAULT, worker_func, arg) │ ├─→ 分配一页内存 ├─→ 初始化 thread 结构体 ├─→ 设置栈帧 └─→ thread_unblock() → 加入 ready_list 状态: BLOCKED → READY 2. 首次运行 schedule() 选中新线程 │ ├─→ switch_threads() 切换栈 ├─→ switch_entry → kernel_thread └─→ function(aux) 开始执行 状态: READY → RUNNING 3. 正常运行 │ ├─→ 可能 yield → READY → RUNNING ├─→ 可能 block → BLOCKED → READY → RUNNING └─→ 继续执行 4. 退出阶段 thread_exit() │ ├─→ 从 all_list 移除 ├─→ 状态设为 DYING └─→ schedule() → 永不返回 5. 清理阶段 thread_schedule_tail() (由下一个线程执行) │ └─→ palloc_free_page(prev) 释放内存 魔数与栈溢出检测 THREAD_MAGIC 的作用 1 #define THREAD_MAGIC 0xcd6abf4b 检测机制： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static bool is_thread (struct thread *t) { return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; } struct thread * thread_current (void) { struct thread *t = running_thread (); /* Make sure T is really a thread. If either of these assertions fire, then your thread may have overflowed its stack. */ ASSERT (is_thread (t)); ASSERT (t-&gt;status == THREAD_RUNNING); return t; } 栈溢出示意： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 正常情况： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ ├───────────────────────────────┤ │ 空闲区 │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b ✓ │ │ ... 其他成员 ... │ └───────────────────────────────┘ 0 栈溢出后： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ │ ↓ │ │ ↓ │ ├───────────────────────────────┤ │ magic = ???????? ✗ (被覆盖) │ │ ... 被破坏的数据 ... │ └───────────────────────────────┘ 0 常见问题解答 Q1: 为什么主线程可以被”转换”而不是”创建”？ A: 系统启动时已经有代码在执行 这个执行流需要被纳入线程管理 loader.S 确保了栈底对齐到页边界 只需填充 thread 结构体即可 Q2: 为什么空闲线程优先级最低？ A: 空闲线程只在没有其他工作时运行 最低优先级确保它不会抢占任何实际工作 它的唯一目的是节省电力和等待中断 Q3: thread_create 中的多个栈帧有什么作用？ A: 模拟线程之前被调度过的状态： switch_threads_frame：模拟 switch_threads 调用点 switch_entry_frame：模拟返回到 kernel_thread 的入口 kernel_thread_frame：提供实际线程函数的参数 Q4: 为什么要等待空闲线程初始化？ A: 调度器需要 idle_thread 指针 当 ready_list 为空时返回 idle_thread 如果不等待，可能返回 NULL 导致崩溃 练习题 练习1：分析栈使用 给定以下递归函数，计算需要多少栈空间： 1 2 3 4 int factorial(int n) { if (n &lt;= 1) return 1; return n * factorial(n - 1); } 假设每次函数调用使用 32 字节栈空间，Pintos 线程最多能计算多大的阶乘？ 练习2：线程状态追踪 画出以下场景中两个线程的状态转换： 主线程创建线程 A 线程 A 运行并调用 sema_down() 阻塞 主线程调用 sema_up() 唤醒线程 A 线程 A 运行完毕退出 练习3：修改时间片 TIME_SLICE 定义为 4 个时钟周期。如果改为： TIME_SLICE = 1：会有什么影响？ TIME_SLICE = 100：会有什么影响？ 练习4：实现线程统计 添加一个函数 thread_count() 返回当前存活的线程数。 提示：使用 all_list 链表。 下一篇预告 在下一篇文档中，我们将详细解析中断系统的初始化 intr_init()，了解 Pintos 如何设置 IDT（中断描述符表）和处理各种中断。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Threads OSDev Wiki - Context Switching" />
<link rel="canonical" href="http://localhost:4000/posts/pintos-kernel-12-thread-init/" />
<meta property="og:url" content="http://localhost:4000/posts/pintos-kernel-12-thread-init/" />
<meta property="og:site_name" content="Zxsheather" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-01-22T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pintos Kernel 12 Thread Init" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-22T00:00:00+08:00","datePublished":"2026-01-22T00:00:00+08:00","description":"Pintos 内核启动（十二）：线程系统初始化 概述 本文档详细解析 Pintos 内核的线程系统初始化过程，包括 thread_init() 和 thread_start() 两个关键函数。线程是操作系统调度的基本单位，线程系统的正确初始化是内核正常运行的基础。 Pintos 的线程系统具有以下特点： 每个线程占用一个页：线程结构体位于页底部，栈从页顶向下增长 简单的调度器：默认使用轮转调度（Round-Robin） 主线程转换：将当前执行流转换为正式的线程 原始代码 thread.c 中的 thread_init() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** Initializes the threading system by transforming the code that&#39;s currently running into a thread. This can&#39;t work in general and it is possible in this case only because loader.S was careful to put the bottom of the stack at a page boundary. Also initializes the run queue and the tid lock. After calling this function, be sure to initialize the page allocator before trying to create any threads with thread_create(). It is not safe to call thread_current() until this function finishes. */ void thread_init (void) { ASSERT (intr_get_level () == INTR_OFF); lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); /* Set up a thread structure for the running thread. */ initial_thread = running_thread (); init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); } thread.c 中的 thread_start() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** Starts preemptive thread scheduling by enabling interrupts. Also creates the idle thread. */ void thread_start (void) { /* Create the idle thread. */ struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); /* Start preemptive thread scheduling. */ intr_enable (); /* Wait for the idle thread to initialize idle_thread. */ sema_down (&amp;idle_started); } thread.h 中的 struct thread 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct thread { /* Owned by thread.c. */ tid_t tid; /* Thread identifier. */ enum thread_status status; /* Thread state. */ char name[16]; /* Name (for debugging purposes). */ uint8_t *stack; /* Saved stack pointer. */ int priority; /* Priority. */ struct list_elem allelem; /* List element for all threads list. */ /* Shared between thread.c and synch.c. */ struct list_elem elem; /* List element. */ #ifdef USERPROG /* Owned by userprog/process.c. */ uint32_t *pagedir; /* Page directory. */ #endif /* Owned by thread.c. */ unsigned magic; /* Detects stack overflow. */ }; 前置知识 1. 线程内存布局 Pintos 中每个线程占用一个完整的 4KB 页： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 4 kB +---------------------------------+ | kernel stack | | | | | | | | V | | grows downward | | | | | | | | | | | | | | | | | +---------------------------------+ | magic | | : | | : | | name | | status | 0 kB +---------------------------------+ 这种设计的优点： 快速定位线程结构：将栈指针向下取整到页边界即可找到线程结构 栈溢出检测：通过检查 magic 成员是否被覆写 简化内存管理：分配/释放线程只需操作一个页 2. 线程状态 1 2 3 4 5 6 7 enum thread_status { THREAD_RUNNING, /* Running thread. */ THREAD_READY, /* Not running but ready to run. */ THREAD_BLOCKED, /* Waiting for an event to trigger. */ THREAD_DYING /* About to be destroyed. */ }; 状态转换图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 创建 │ ↓ ┌─────────────┐ │ BLOCKED │◄──────────────┐ └─────────────┘ │ │ │ │ unblock │ block (等待事件) ↓ │ ┌─────────────┐ 调度 ┌─────────────┐ │ │ RUNNING │◄──────│ READY │ │ └─────────────┘ └─────────────┘ │ │ ↑ │ │ │ │ │ yield/抢占 │ │ └─────────────────────┘ │ │ │ │ exit │ ↓ │ ┌─────────────┐ │ │ DYING │ │ └─────────────┘ │ 3. 线程优先级 1 2 3 #define PRI_MIN 0 /* Lowest priority. */ #define PRI_DEFAULT 31 /* Default priority. */ #define PRI_MAX 63 /* Highest priority. */ 优先级范围：0-63（64 个级别） 数值越大优先级越高 默认优先级为 31 4. 关键数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 就绪队列：等待运行的线程 */ static struct list ready_list; /* 所有线程列表 */ static struct list all_list; /* 空闲线程 */ static struct thread *idle_thread; /* 主线程（运行 init.c:main() 的线程）*/ static struct thread *initial_thread; /* TID 分配锁 */ static struct lock tid_lock; 逐行代码解析 thread_init() 函数解析 第1行：检查中断状态 1 ASSERT (intr_get_level () == INTR_OFF); 详细解析： 为什么需要关中断？ 初始化过程中修改共享数据结构 需要防止中断处理程序访问未初始化的数据 确保初始化的原子性 此时中断为什么是关闭的？ 从系统启动开始中断就是关闭的 intr_enable() 在 thread_start() 中才会被调用 第2-4行：初始化全局数据结构 1 2 3 lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list); 详细解析： tid_lock 初始化： 用于保护线程 ID 的分配 确保每个线程获得唯一的 TID ready_list 初始化： 就绪队列，存放等待运行的线程 使用双向链表实现 all_list 初始化： 所有线程的列表 用于调试和遍历所有线程 链表初始状态： 1 2 3 4 5 6 7 8 9 10 11 12 13 ready_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ all_list (空) ┌──────────┐ │ head │◄──┐ ├──────────┤ │ │ tail │───┘ └──────────┘ 第5行：获取当前线程结构体 1 initial_thread = running_thread (); 详细解析： running_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 struct thread * running_thread (void) { uint32_t *esp; /* Copy the CPU&#39;s stack pointer into `esp&#39;, and then round that down to the start of a page. Because `struct thread&#39; is always at the beginning of a page and the stack pointer is somewhere in the middle, this locates the current thread. */ asm (&quot;mov %%esp, %0&quot; : &quot;=g&quot; (esp)); return pg_round_down (esp); } 工作原理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 当前内存布局： ESP 在这里 ↓ ┌───────────────────────────────────────────┐ 页顶 (页基址 + 4KB) │ 栈内容 │ │ (函数调用等) │ ├───────────────────────────────────────────┤ ESP 指向的位置 │ │ │ 未使用的栈空间 │ │ │ ├───────────────────────────────────────────┤ │ │ │ struct thread (未初始化) │ │ │ └───────────────────────────────────────────┘ 页底 (页基址) pg_round_down(ESP) = 页底地址 = struct thread 地址 为什么这能工作？ loader.S 精心设置了初始栈位置，使其底部对齐到页边界 初始栈在内核 BSS 段的末尾 这个页在 thread_init 之前就已经被当作”主线程”的页使用 第6行：初始化线程结构体 1 init_thread (initial_thread, &quot;main&quot;, PRI_DEFAULT); 详细解析： init_thread() 函数的实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static void init_thread (struct thread *t, const char *name, int priority) { enum intr_level old_level; ASSERT (t != NULL); ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX); ASSERT (name != NULL); memset (t, 0, sizeof *t); t-&gt;status = THREAD_BLOCKED; strlcpy (t-&gt;name, name, sizeof t-&gt;name); t-&gt;stack = (uint8_t *) t + PGSIZE; t-&gt;priority = priority; t-&gt;magic = THREAD_MAGIC; old_level = intr_disable (); list_push_back (&amp;all_list, &amp;t-&gt;allelem); intr_set_level (old_level); } 逐步解析： memset 清零：将整个结构体清零 status = THREAD_BLOCKED：初始状态为阻塞（稍后会改为 RUNNING） strlcpy name：复制线程名称（最多 15 字符 + ‘\\0’） stack = t + PGSIZE：栈指针初始化到页顶 priority：设置优先级 magic = THREAD_MAGIC：设置魔数（用于检测栈溢出） 加入 all_list：将线程添加到所有线程列表 初始化后的布局： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 4 KB ┌───────────────────────────────┐ t-&gt;stack 指向这里 │ │ │ (栈空间) │ │ │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b │ 栈溢出检测 ├───────────────────────────────┤ │ priority = 31 │ ├───────────────────────────────┤ │ stack (指向页顶) │ ├───────────────────────────────┤ │ name = &quot;main\\0...&quot; │ ├───────────────────────────────┤ │ status = THREAD_BLOCKED │ ├───────────────────────────────┤ │ tid = 0 (未分配) │ 0 KB └───────────────────────────────┘ initial_thread 指向这里 第7-8行：设置运行状态和分配 TID 1 2 initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid (); 详细解析： 状态改为 RUNNING： 主线程当前正在运行 覆盖 init_thread 设置的 BLOCKED 状态 分配 TID： allocate_tid() 返回下一个可用的线程 ID 主线程的 TID 为 1 allocate_tid() 实现： 1 2 3 4 5 6 7 8 9 10 11 12 static tid_t allocate_tid (void) { static tid_t next_tid = 1; tid_t tid; lock_acquire (&amp;tid_lock); tid = next_tid++; lock_release (&amp;tid_lock); return tid; } 注意：虽然此时还没有其他线程，但使用锁是好习惯，确保代码的正确性。 thread_start() 函数解析 第1-3行：创建空闲线程同步信号量 1 2 3 struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (&quot;idle&quot;, PRI_MIN, idle, &amp;idle_started); 详细解析： 信号量目的： 等待空闲线程完成初始化 确保 idle_thread 变量被正确设置 thread_create 参数： &quot;idle&quot;：线程名称 PRI_MIN：最低优先级（0） idle：线程函数 &amp;idle_started：传递给 idle 函数的参数 为什么需要空闲线程？ 当没有其他线程就绪时，CPU 需要运行某些东西 空闲线程执行 hlt 指令，使 CPU 进入低功耗状态 这比忙等待更节能 第4行：启用中断 1 intr_enable (); 详细解析： 从这一刻起，定时器中断开始触发 抢占式调度正式开始 空闲线程可能在这之后被调度运行 第5行：等待空闲线程初始化 1 sema_down (&amp;idle_started); 详细解析： 这里可能发生以下情况： 场景1：空闲线程先运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │────────────────────────→│ │ │ │ enable interrupts │ │ │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ │ │ sema_down() (直接成功) │ │ │ 场景2：主线程继续运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 主线程 空闲线程 │ │ │ create idle │ │ │ (在 ready_list 中) │ enable interrupts │ │ │ │ sema_down() │ │ (阻塞，信号量=0) │ │ ┌─────┤ 被调度 │ │ │ │ │ idle_thread = self │ │ │ │ │ sema_up() │◄───────────────────┘ │ │ (唤醒) │ │ │ idle() 函数解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static void idle (void *idle_started_ UNUSED) { struct semaphore *idle_started = idle_started_; idle_thread = thread_current (); sema_up (idle_started); for (;;) { /* Let someone else run. */ intr_disable (); thread_block (); /* Re-enable interrupts and wait for the next one. The `sti&#39; instruction disables interrupts until the completion of the next instruction, so these two instructions are executed atomically. This atomicity is important; otherwise, an interrupt could be handled between re-enabling interrupts and waiting for the next one to occur, wasting as much as one clock tick worth of time. */ asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } } 详细解析： 设置 idle_thread： 保存自己的线程指针到全局变量 供调度器在就绪队列为空时使用 通知主线程： sema_up() 释放信号量 允许主线程继续执行 无限循环： 1 2 3 4 5 6 7 for (;;) { intr_disable (); // 关中断 thread_block (); // 阻塞自己，调度其他线程 // 被唤醒后执行 asm volatile (&quot;sti; hlt&quot; : : : &quot;memory&quot;); } sti; hlt 原子性： sti：开中断 hlt：停止 CPU 直到下一个中断 x86 保证 sti 后的第一条指令不会被中断 这确保了 hlt 能够被执行 为什么需要这种原子性？ 1 2 3 4 5 6 7 如果不是原子的： 时刻 T: sti (开中断) 时刻 T+1: [中断到来] (处理中断，可能唤醒某个线程) 时刻 T+2: hlt (进入睡眠，但应该运行被唤醒的线程！) 结果：浪费了处理器时间 thread_create() 函数详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 tid_t thread_create (const char *name, int priority, thread_func *function, void *aux) { struct thread *t; struct kernel_thread_frame *kf; struct switch_entry_frame *ef; struct switch_threads_frame *sf; tid_t tid; ASSERT (function != NULL); /* Allocate thread. */ t = palloc_get_page (PAL_ZERO); if (t == NULL) return TID_ERROR; /* Initialize thread. */ init_thread (t, name, priority); tid = t-&gt;tid = allocate_tid (); /* Stack frame for kernel_thread(). */ kf = alloc_frame (t, sizeof *kf); kf-&gt;eip = NULL; kf-&gt;function = function; kf-&gt;aux = aux; /* Stack frame for switch_entry(). */ ef = alloc_frame (t, sizeof *ef); ef-&gt;eip = (void (*) (void)) kernel_thread; /* Stack frame for switch_threads(). */ sf = alloc_frame (t, sizeof *sf); sf-&gt;eip = switch_entry; sf-&gt;ebp = 0; /* Add to run queue. */ thread_unblock (t); return tid; } 栈帧布局： 新线程创建后，其栈的布局如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 4 KB ┌───────────────────────────────┐ │ │ │ (未使用的栈空间) │ │ │ ├───────────────────────────────┤ │ kernel_thread_frame │ │ ┌─────────────────────────┐ │ │ │ eip = NULL (返回地址) │ │ │ │ function (线程函数) │ │ │ │ aux (辅助参数) │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_entry_frame │ │ ┌─────────────────────────┐ │ │ │ eip = kernel_thread │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ switch_threads_frame │ │ ┌─────────────────────────┐ │ │ │ eip = switch_entry │ │ ← t-&gt;stack │ │ ebp = 0 │ │ │ │ ebx, esi, edi = 0 │ │ │ └─────────────────────────┘ │ ├───────────────────────────────┤ │ struct thread │ │ (tid, name, priority, ...) │ 0 KB └───────────────────────────────┘ 首次调度时的执行流： 1 2 3 4 5 6 7 8 9 10 1. switch_threads() 恢复 sf 中的寄存器 └→ ret 执行，跳转到 switch_entry 2. switch_entry (in switch.S) └→ ret 执行，跳转到 kernel_thread 3. kernel_thread() intr_enable(); // 开中断 function(aux); // 执行用户提供的函数 thread_exit(); // 线程结束 调度器核心函数 schedule() 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void schedule (void) { struct thread *cur = running_thread (); struct thread *next = next_thread_to_run (); struct thread *prev = NULL; ASSERT (intr_get_level () == INTR_OFF); ASSERT (cur-&gt;status != THREAD_RUNNING); ASSERT (is_thread (next)); if (cur != next) prev = switch_threads (cur, next); thread_schedule_tail (prev); } 调度流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 schedule() │ ├─→ cur = 当前线程 │ ├─→ next = next_thread_to_run() │ │ │ ├─→ ready_list 非空? 取出第一个线程 │ │ │ └─→ ready_list 为空? 返回 idle_thread │ ├─→ cur == next? ─→ 是 ─→ 跳过切换 │ │ │ └─→ 否 ─→ switch_threads(cur, next) │ │ │ └─→ 保存 cur 的寄存器 │ 恢复 next 的寄存器 │ 返回 prev (= cur) │ └─→ thread_schedule_tail(prev) │ ├─→ 标记新线程为 RUNNING │ ├─→ 重置时间片计数器 │ └─→ 如果 prev 正在死亡，释放其内存 switch_threads() 函数 (switch.S) .globl switch_threads .func switch_threads switch_threads: # Save caller&#39;s register state. pushl %ebx pushl %ebp pushl %esi pushl %edi # Get offsetof (struct thread, stack). mov thread_stack_ofs, %edx # Save current stack pointer to old thread&#39;s stack. movl SWITCH_CUR(%esp), %eax movl %esp, (%eax,%edx,1) # Restore stack pointer from new thread&#39;s stack. movl SWITCH_NEXT(%esp), %ecx movl (%ecx,%edx,1), %esp # Restore caller&#39;s register state. popl %edi popl %esi popl %ebp popl %ebx ret .endfunc 线程切换图示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 切换前： 切换后： 线程 A (cur) 线程 B (next) ┌─────────────┐ ┌─────────────┐ │ 栈顶 │ │ 栈顶 │ │ │ │ │ │ │ │ ↓ │ │ ↓ │ │ │ │ │ │ [保存的寄存器]│◄── A-&gt;stack │ [保存的寄存器]│◄── B-&gt;stack └─────────────┘ └─────────────┘ ↑ │ │ │ ESP ESP switch_threads() ──────────────────────────────→ 保存 A 的 ESP 到 A-&gt;stack 从 B-&gt;stack 恢复 ESP 线程生命周期 完整生命周期示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1. 创建阶段 thread_create(&quot;worker&quot;, PRI_DEFAULT, worker_func, arg) │ ├─→ 分配一页内存 ├─→ 初始化 thread 结构体 ├─→ 设置栈帧 └─→ thread_unblock() → 加入 ready_list 状态: BLOCKED → READY 2. 首次运行 schedule() 选中新线程 │ ├─→ switch_threads() 切换栈 ├─→ switch_entry → kernel_thread └─→ function(aux) 开始执行 状态: READY → RUNNING 3. 正常运行 │ ├─→ 可能 yield → READY → RUNNING ├─→ 可能 block → BLOCKED → READY → RUNNING └─→ 继续执行 4. 退出阶段 thread_exit() │ ├─→ 从 all_list 移除 ├─→ 状态设为 DYING └─→ schedule() → 永不返回 5. 清理阶段 thread_schedule_tail() (由下一个线程执行) │ └─→ palloc_free_page(prev) 释放内存 魔数与栈溢出检测 THREAD_MAGIC 的作用 1 #define THREAD_MAGIC 0xcd6abf4b 检测机制： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static bool is_thread (struct thread *t) { return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; } struct thread * thread_current (void) { struct thread *t = running_thread (); /* Make sure T is really a thread. If either of these assertions fire, then your thread may have overflowed its stack. */ ASSERT (is_thread (t)); ASSERT (t-&gt;status == THREAD_RUNNING); return t; } 栈溢出示意： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 正常情况： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ ├───────────────────────────────┤ │ 空闲区 │ ├───────────────────────────────┤ │ magic = 0xcd6abf4b ✓ │ │ ... 其他成员 ... │ └───────────────────────────────┘ 0 栈溢出后： ┌───────────────────────────────┐ 4KB │ 栈使用区 │ │ ↓ │ │ ↓ │ │ ↓ │ ├───────────────────────────────┤ │ magic = ???????? ✗ (被覆盖) │ │ ... 被破坏的数据 ... │ └───────────────────────────────┘ 0 常见问题解答 Q1: 为什么主线程可以被”转换”而不是”创建”？ A: 系统启动时已经有代码在执行 这个执行流需要被纳入线程管理 loader.S 确保了栈底对齐到页边界 只需填充 thread 结构体即可 Q2: 为什么空闲线程优先级最低？ A: 空闲线程只在没有其他工作时运行 最低优先级确保它不会抢占任何实际工作 它的唯一目的是节省电力和等待中断 Q3: thread_create 中的多个栈帧有什么作用？ A: 模拟线程之前被调度过的状态： switch_threads_frame：模拟 switch_threads 调用点 switch_entry_frame：模拟返回到 kernel_thread 的入口 kernel_thread_frame：提供实际线程函数的参数 Q4: 为什么要等待空闲线程初始化？ A: 调度器需要 idle_thread 指针 当 ready_list 为空时返回 idle_thread 如果不等待，可能返回 NULL 导致崩溃 练习题 练习1：分析栈使用 给定以下递归函数，计算需要多少栈空间： 1 2 3 4 int factorial(int n) { if (n &lt;= 1) return 1; return n * factorial(n - 1); } 假设每次函数调用使用 32 字节栈空间，Pintos 线程最多能计算多大的阶乘？ 练习2：线程状态追踪 画出以下场景中两个线程的状态转换： 主线程创建线程 A 线程 A 运行并调用 sema_down() 阻塞 主线程调用 sema_up() 唤醒线程 A 线程 A 运行完毕退出 练习3：修改时间片 TIME_SLICE 定义为 4 个时钟周期。如果改为： TIME_SLICE = 1：会有什么影响？ TIME_SLICE = 100：会有什么影响？ 练习4：实现线程统计 添加一个函数 thread_count() 返回当前存活的线程数。 提示：使用 all_list 链表。 下一篇预告 在下一篇文档中，我们将详细解析中断系统的初始化 intr_init()，了解 Pintos 如何设置 IDT（中断描述符表）和处理各种中断。 参考资料 Intel 64 and IA-32 Architectures Software Developer’s Manual Pintos Documentation - Threads OSDev Wiki - Context Switching","headline":"Pintos Kernel 12 Thread Init","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/pintos-kernel-12-thread-init/"},"url":"http://localhost:4000/posts/pintos-kernel-12-thread-init/"}</script>
<!-- End Jekyll SEO tag -->


  <title>Pintos Kernel 12 Thread Init | Zxsheather
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="icon" type="image/png" href="/assets/img/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="/assets/img/favicons/favicon.svg">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">

  <link rel="manifest" href="/assets/img/favicons/site.webmanifest">



  <!-- Resource Hints -->
  
    
      
        <link rel="preconnect" href="https://fonts.googleapis.com" >
      
        <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
      
    
      
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      
        <link rel="dns-prefetch" href="https://fonts.gstatic.com" >
      
    
      
        <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      
        <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
      
    
  

  <!-- Bootstrap -->
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css">
  

  <!-- Theme style -->
  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  <!-- Web Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css">

  <!-- 3rd-party Dependencies -->

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.36.4/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Image Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css">
  

  <!-- Scripts -->

  <script src="/assets/js/dist/theme.min.js"></script>

  <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.18/dayjs.min.js,npm/dayjs@1.11.18/locale/zh.js,npm/dayjs@1.11.18/plugin/relativeTime.js,npm/dayjs@1.11.18/plugin/localizedFormat.js,npm/tocbot@4.36.4/dist/tocbot.min.js"></script>







<script defer src="/assets/js/dist/post.min.js"></script>



<!-- Pageviews -->

  

  



  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/3.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a>

    <a class="site-title d-block" href="/">Zxsheather</a>
    <p class="site-subtitle fst-italic mb-0">A CS Undergraduate</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- home -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-home"></i>
          <span>首页</span>
        </a>
      </li>
      <!-- the real tabs -->
      
        <li class="nav-item">
          <a href="/categories/" class="nav-link">
            <i class="fa-fw fas fa-stream"></i>
            

            <span>分类</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/tags/" class="nav-link">
            <i class="fa-fw fas fa-tags"></i>
            

            <span>标签</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/archives/" class="nav-link">
            <i class="fa-fw fas fa-archive"></i>
            

            <span>归档</span>
          </a>
        </li>
        <!-- .nav-item -->
      
        <li class="nav-item">
          <a href="/about/" class="nav-link">
            <i class="fa-fw fas fa-info-circle"></i>
            

            <span>关于</span>
          </a>
        </li>
        <!-- .nav-item -->
      
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle">
        <i class="fas fa-adjust"></i>
      </button>

      
    

    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div class="container d-flex flex-column px-xxl-5">
        <!-- The Top Bar -->

<header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar">
  <div
    id="topbar"
    class="d-flex align-items-center justify-content-between px-lg-3 h-100"
  >
    <nav id="breadcrumb" aria-label="Breadcrumb">
      

      
        
          
            <span>
              <a href="/">首页</a>
            </span>

          
        
          
        
          
            
              <span>Pintos Kernel 12 Thread Init</span>
            

          
        
      
    </nav>
    <!-- endof #breadcrumb -->

    <button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar">
      <i class="fas fa-bars fa-fw"></i>
    </button>

    <div id="topbar-title">
      文章
    </div>

    <button type="button" id="search-trigger" class="btn btn-link" aria-label="Search">
      <i class="fas fa-search fa-fw"></i>
    </button>

    <search id="search" class="align-items-center ms-3 ms-lg-0">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="搜索..."
      >
    </search>
    <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button>
  </div>
</header>


        <div class="row flex-grow-1">
          <main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->



<!-- Handle images -->





<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    
      

      
      

      
      
      

      
    

    
  

  
  

  




<!-- return -->










<article class="px-1" data-toc="true">
  <header>
    <h1 data-toc-skip>Pintos Kernel 12 Thread Init</h1>
    

    <div class="post-meta text-muted">
      <!-- published date -->
      <span>
        发表于
        <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->




<time
  
  data-ts="1769011200"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2026/01/22
</time>

      </span>

      <!-- lastmod date -->
      

      

      <div class="d-flex justify-content-between">
        <!-- author(s) -->
        <span>
          

          作者

          <em>
            
              <a href="https://github.com/zxsheather">Zxsheather</a>
            
          </em>
        </span>

        <div>
          <!-- pageviews -->
          

          <!-- read time -->
          <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="4585 字"
>
  <em>25 分钟</em>阅读</span>

        </div>
      </div>
    </div>
  </header>

  
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">Pintos Kernel 12 Thread Init</span>
      <button type="button" class="toc-trigger btn me-1">
        <i class="fa-solid fa-list-ul fa-fw"></i>
      </button>
    </div>

    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">文章内容</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>

    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">Pintos Kernel 12 Thread Init</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75">
          <i class="fas fa-close"></i>
        </button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  

  <div class="content">
    <h1 id="pintos-内核启动十二线程系统初始化">Pintos 内核启动（十二）：线程系统初始化</h1>

<h2 id="概述"><span class="me-2">概述</span><a href="#概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>本文档详细解析 Pintos 内核的线程系统初始化过程，包括 <code class="language-plaintext highlighter-rouge">thread_init()</code> 和 <code class="language-plaintext highlighter-rouge">thread_start()</code> 两个关键函数。线程是操作系统调度的基本单位，线程系统的正确初始化是内核正常运行的基础。</p>

<p>Pintos 的线程系统具有以下特点：</p>
<ol>
  <li><strong>每个线程占用一个页</strong>：线程结构体位于页底部，栈从页顶向下增长</li>
  <li><strong>简单的调度器</strong>：默认使用轮转调度（Round-Robin）</li>
  <li><strong>主线程转换</strong>：将当前执行流转换为正式的线程</li>
</ol>

<h2 id="原始代码"><span class="me-2">原始代码</span><a href="#原始代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="threadc-中的-thread_init-函数"><span class="me-2">thread.c 中的 thread_init() 函数</span><a href="#threadc-中的-thread_init-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cm">/** Initializes the threading system by transforming the code
   that's currently running into a thread.  This can't work in
   general and it is possible in this case only because loader.S
   was careful to put the bottom of the stack at a page boundary.

   Also initializes the run queue and the tid lock.

   After calling this function, be sure to initialize the page
   allocator before trying to create any threads with
   thread_create().

   It is not safe to call thread_current() until this function
   finishes. */</span>
<span class="kt">void</span>
<span class="nf">thread_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>

  <span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span>
  <span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">);</span>
  <span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">all_list</span><span class="p">);</span>

  <span class="cm">/* Set up a thread structure for the running thread. */</span>
  <span class="n">initial_thread</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
  <span class="n">init_thread</span> <span class="p">(</span><span class="n">initial_thread</span><span class="p">,</span> <span class="s">"main"</span><span class="p">,</span> <span class="n">PRI_DEFAULT</span><span class="p">);</span>
  <span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_RUNNING</span><span class="p">;</span>
  <span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="threadc-中的-thread_start-函数"><span class="me-2">thread.c 中的 thread_start() 函数</span><a href="#threadc-中的-thread_start-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="cm">/** Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */</span>
<span class="kt">void</span>
<span class="nf">thread_start</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="cm">/* Create the idle thread. */</span>
  <span class="k">struct</span> <span class="n">semaphore</span> <span class="n">idle_started</span><span class="p">;</span>
  <span class="n">sema_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">idle_started</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">thread_create</span> <span class="p">(</span><span class="s">"idle"</span><span class="p">,</span> <span class="n">PRI_MIN</span><span class="p">,</span> <span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idle_started</span><span class="p">);</span>

  <span class="cm">/* Start preemptive thread scheduling. */</span>
  <span class="n">intr_enable</span> <span class="p">();</span>

  <span class="cm">/* Wait for the idle thread to initialize idle_thread. */</span>
  <span class="n">sema_down</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">idle_started</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="threadh-中的-struct-thread-定义"><span class="me-2">thread.h 中的 struct thread 定义</span><a href="#threadh-中的-struct-thread-定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="kr">thread</span>
  <span class="p">{</span>
    <span class="cm">/* Owned by thread.c. */</span>
    <span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>                          <span class="cm">/* Thread identifier. */</span>
    <span class="k">enum</span> <span class="n">thread_status</span> <span class="n">status</span><span class="p">;</span>          <span class="cm">/* Thread state. */</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>                      <span class="cm">/* Name (for debugging purposes). */</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>                     <span class="cm">/* Saved stack pointer. */</span>
    <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>                       <span class="cm">/* Priority. */</span>
    <span class="k">struct</span> <span class="n">list_elem</span> <span class="n">allelem</span><span class="p">;</span>           <span class="cm">/* List element for all threads list. */</span>

    <span class="cm">/* Shared between thread.c and synch.c. */</span>
    <span class="k">struct</span> <span class="n">list_elem</span> <span class="n">elem</span><span class="p">;</span>              <span class="cm">/* List element. */</span>

<span class="cp">#ifdef USERPROG
</span>    <span class="cm">/* Owned by userprog/process.c. */</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pagedir</span><span class="p">;</span>                  <span class="cm">/* Page directory. */</span>
<span class="cp">#endif
</span>
    <span class="cm">/* Owned by thread.c. */</span>
    <span class="kt">unsigned</span> <span class="n">magic</span><span class="p">;</span>                     <span class="cm">/* Detects stack overflow. */</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="前置知识"><span class="me-2">前置知识</span><a href="#前置知识" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="1-线程内存布局"><span class="me-2">1. 线程内存布局</span><a href="#1-线程内存布局" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>Pintos 中每个线程占用一个完整的 4KB 页：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>        4 kB +---------------------------------+
             |          kernel stack           |
             |                |                |
             |                |                |
             |                V                |
             |         grows downward          |
             |                                 |
             |                                 |
             |                                 |
             |                                 |
             |                                 |
             |                                 |
             |                                 |
             |                                 |
             +---------------------------------+
             |              magic              |
             |                :                |
             |                :                |
             |               name              |
             |              status             |
        0 kB +---------------------------------+
</pre></td></tr></tbody></table></code></div></div>

<p>这种设计的优点：</p>
<ol>
  <li><strong>快速定位线程结构</strong>：将栈指针向下取整到页边界即可找到线程结构</li>
  <li><strong>栈溢出检测</strong>：通过检查 magic 成员是否被覆写</li>
  <li><strong>简化内存管理</strong>：分配/释放线程只需操作一个页</li>
</ol>

<h3 id="2-线程状态"><span class="me-2">2. 线程状态</span><a href="#2-线程状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">thread_status</span>
  <span class="p">{</span>
    <span class="n">THREAD_RUNNING</span><span class="p">,</span>     <span class="cm">/* Running thread. */</span>
    <span class="n">THREAD_READY</span><span class="p">,</span>       <span class="cm">/* Not running but ready to run. */</span>
    <span class="n">THREAD_BLOCKED</span><span class="p">,</span>     <span class="cm">/* Waiting for an event to trigger. */</span>
    <span class="n">THREAD_DYING</span>        <span class="cm">/* About to be destroyed. */</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></div></div>

<p>状态转换图：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>                          创建
                           │
                           ↓
                    ┌─────────────┐
                    │  BLOCKED    │◄──────────────┐
                    └─────────────┘               │
                           │                      │
                           │ unblock              │ block (等待事件)
                           ↓                      │
    ┌─────────────┐  调度  ┌─────────────┐       │
    │  RUNNING    │◄──────│   READY     │       │
    └─────────────┘       └─────────────┘       │
           │                     ↑               │
           │                     │               │
           │     yield/抢占      │               │
           └─────────────────────┘               │
           │                                     │
           │ exit                                │
           ↓                                     │
    ┌─────────────┐                              │
    │   DYING     │                              │
    └─────────────┘                              │
</pre></td></tr></tbody></table></code></div></div>

<h3 id="3-线程优先级"><span class="me-2">3. 线程优先级</span><a href="#3-线程优先级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cp">#define PRI_MIN 0       </span><span class="cm">/* Lowest priority. */</span><span class="cp">
#define PRI_DEFAULT 31  </span><span class="cm">/* Default priority. */</span><span class="cp">
#define PRI_MAX 63      </span><span class="cm">/* Highest priority. */</span><span class="cp">
</span></pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>优先级范围：0-63（64 个级别）</li>
  <li>数值越大优先级越高</li>
  <li>默认优先级为 31</li>
</ul>

<h3 id="4-关键数据结构"><span class="me-2">4. 关键数据结构</span><a href="#4-关键数据结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="cm">/* 就绪队列：等待运行的线程 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">ready_list</span><span class="p">;</span>

<span class="cm">/* 所有线程列表 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">all_list</span><span class="p">;</span>

<span class="cm">/* 空闲线程 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">idle_thread</span><span class="p">;</span>

<span class="cm">/* 主线程（运行 init.c:main() 的线程）*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">initial_thread</span><span class="p">;</span>

<span class="cm">/* TID 分配锁 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock</span> <span class="n">tid_lock</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h2 id="逐行代码解析"><span class="me-2">逐行代码解析</span><a href="#逐行代码解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="thread_init-函数解析"><span class="me-2">thread_init() 函数解析</span><a href="#thread_init-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="第1行检查中断状态"><span class="me-2">第1行：检查中断状态</span><a href="#第1行检查中断状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>为什么需要关中断</strong>？
    <ul>
      <li>初始化过程中修改共享数据结构</li>
      <li>需要防止中断处理程序访问未初始化的数据</li>
      <li>确保初始化的原子性</li>
    </ul>
  </li>
  <li><strong>此时中断为什么是关闭的</strong>？
    <ul>
      <li>从系统启动开始中断就是关闭的</li>
      <li><code class="language-plaintext highlighter-rouge">intr_enable()</code> 在 <code class="language-plaintext highlighter-rouge">thread_start()</code> 中才会被调用</li>
    </ul>
  </li>
</ol>

<h4 id="第2-4行初始化全局数据结构"><span class="me-2">第2-4行：初始化全局数据结构</span><a href="#第2-4行初始化全局数据结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span>
<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">);</span>
<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">all_list</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>tid_lock 初始化</strong>：
    <ul>
      <li>用于保护线程 ID 的分配</li>
      <li>确保每个线程获得唯一的 TID</li>
    </ul>
  </li>
  <li><strong>ready_list 初始化</strong>：
    <ul>
      <li>就绪队列，存放等待运行的线程</li>
      <li>使用双向链表实现</li>
    </ul>
  </li>
  <li><strong>all_list 初始化</strong>：
    <ul>
      <li>所有线程的列表</li>
      <li>用于调试和遍历所有线程</li>
    </ul>
  </li>
</ol>

<p><strong>链表初始状态</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>ready_list (空)
┌──────────┐
│   head   │◄──┐
├──────────┤   │
│   tail   │───┘
└──────────┘

all_list (空)
┌──────────┐
│   head   │◄──┐
├──────────┤   │
│   tail   │───┘
└──────────┘
</pre></td></tr></tbody></table></code></div></div>

<h4 id="第5行获取当前线程结构体"><span class="me-2">第5行：获取当前线程结构体</span><a href="#第5行获取当前线程结构体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">initial_thread</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">running_thread()</code> 函数的实现：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span>
<span class="nf">running_thread</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">esp</span><span class="p">;</span>

  <span class="cm">/* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the current thread. */</span>
  <span class="n">asm</span> <span class="p">(</span><span class="s">"mov %%esp, %0"</span> <span class="o">:</span> <span class="s">"=g"</span> <span class="p">(</span><span class="n">esp</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">pg_round_down</span> <span class="p">(</span><span class="n">esp</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>工作原理</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>当前内存布局：

                                ESP 在这里 ↓
┌───────────────────────────────────────────┐ 页顶 (页基址 + 4KB)
│                栈内容                      │
│            (函数调用等)                    │
├───────────────────────────────────────────┤ ESP 指向的位置
│                                           │
│             未使用的栈空间                 │
│                                           │
├───────────────────────────────────────────┤
│                                           │
│          struct thread (未初始化)         │
│                                           │
└───────────────────────────────────────────┘ 页底 (页基址)

pg_round_down(ESP) = 页底地址 = struct thread 地址
</pre></td></tr></tbody></table></code></div></div>

<p><strong>为什么这能工作</strong>？</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">loader.S</code> 精心设置了初始栈位置，使其底部对齐到页边界</li>
  <li>初始栈在内核 BSS 段的末尾</li>
  <li>这个页在 <code class="language-plaintext highlighter-rouge">thread_init</code> 之前就已经被当作”主线程”的页使用</li>
</ul>

<h4 id="第6行初始化线程结构体"><span class="me-2">第6行：初始化线程结构体</span><a href="#第6行初始化线程结构体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">init_thread</span> <span class="p">(</span><span class="n">initial_thread</span><span class="p">,</span> <span class="s">"main"</span><span class="p">,</span> <span class="n">PRI_DEFAULT</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">init_thread()</code> 函数的实现：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_thread</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">PRI_MIN</span> <span class="o">&lt;=</span> <span class="n">priority</span> <span class="o">&amp;&amp;</span> <span class="n">priority</span> <span class="o">&lt;=</span> <span class="n">PRI_MAX</span><span class="p">);</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">memset</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_BLOCKED</span><span class="p">;</span>
  <span class="n">strlcpy</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">t</span> <span class="o">+</span> <span class="n">PGSIZE</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">THREAD_MAGIC</span><span class="p">;</span>

  <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
  <span class="n">list_push_back</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">all_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">allelem</span><span class="p">);</span>
  <span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>逐步解析</strong>：</p>

<ol>
  <li><strong>memset 清零</strong>：将整个结构体清零</li>
  <li><strong>status = THREAD_BLOCKED</strong>：初始状态为阻塞（稍后会改为 RUNNING）</li>
  <li><strong>strlcpy name</strong>：复制线程名称（最多 15 字符 + ‘\0’）</li>
  <li><strong>stack = t + PGSIZE</strong>：栈指针初始化到页顶</li>
  <li><strong>priority</strong>：设置优先级</li>
  <li><strong>magic = THREAD_MAGIC</strong>：设置魔数（用于检测栈溢出）</li>
  <li><strong>加入 all_list</strong>：将线程添加到所有线程列表</li>
</ol>

<p><strong>初始化后的布局</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>4 KB  ┌───────────────────────────────┐ t-&gt;stack 指向这里
      │                               │
      │        (栈空间)               │
      │                               │
      ├───────────────────────────────┤
      │   magic = 0xcd6abf4b          │ 栈溢出检测
      ├───────────────────────────────┤
      │   priority = 31               │
      ├───────────────────────────────┤
      │   stack (指向页顶)            │
      ├───────────────────────────────┤
      │   name = "main\0..."          │
      ├───────────────────────────────┤
      │   status = THREAD_BLOCKED     │
      ├───────────────────────────────┤
      │   tid = 0 (未分配)            │
0 KB  └───────────────────────────────┘ initial_thread 指向这里
</pre></td></tr></tbody></table></code></div></div>

<h4 id="第7-8行设置运行状态和分配-tid"><span class="me-2">第7-8行：设置运行状态和分配 TID</span><a href="#第7-8行设置运行状态和分配-tid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_RUNNING</span><span class="p">;</span>
<span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>状态改为 RUNNING</strong>：
    <ul>
      <li>主线程当前正在运行</li>
      <li>覆盖 init_thread 设置的 BLOCKED 状态</li>
    </ul>
  </li>
  <li><strong>分配 TID</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">allocate_tid()</code> 返回下一个可用的线程 ID</li>
      <li>主线程的 TID 为 1</li>
    </ul>
  </li>
</ol>

<p><strong>allocate_tid() 实现</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">tid_t</span>
<span class="nf">allocate_tid</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">static</span> <span class="n">tid_t</span> <span class="n">next_tid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

  <span class="n">lock_acquire</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span>
  <span class="n">tid</span> <span class="o">=</span> <span class="n">next_tid</span><span class="o">++</span><span class="p">;</span>
  <span class="n">lock_release</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">tid</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>注意</strong>：虽然此时还没有其他线程，但使用锁是好习惯，确保代码的正确性。</p>

<h3 id="thread_start-函数解析"><span class="me-2">thread_start() 函数解析</span><a href="#thread_start-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="第1-3行创建空闲线程同步信号量"><span class="me-2">第1-3行：创建空闲线程同步信号量</span><a href="#第1-3行创建空闲线程同步信号量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">semaphore</span> <span class="n">idle_started</span><span class="p">;</span>
<span class="n">sema_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">idle_started</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">thread_create</span> <span class="p">(</span><span class="s">"idle"</span><span class="p">,</span> <span class="n">PRI_MIN</span><span class="p">,</span> <span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idle_started</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>信号量目的</strong>：
    <ul>
      <li>等待空闲线程完成初始化</li>
      <li>确保 <code class="language-plaintext highlighter-rouge">idle_thread</code> 变量被正确设置</li>
    </ul>
  </li>
  <li><strong>thread_create 参数</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">"idle"</code>：线程名称</li>
      <li><code class="language-plaintext highlighter-rouge">PRI_MIN</code>：最低优先级（0）</li>
      <li><code class="language-plaintext highlighter-rouge">idle</code>：线程函数</li>
      <li><code class="language-plaintext highlighter-rouge">&amp;idle_started</code>：传递给 idle 函数的参数</li>
    </ul>
  </li>
</ol>

<p><strong>为什么需要空闲线程</strong>？</p>

<ul>
  <li>当没有其他线程就绪时，CPU 需要运行某些东西</li>
  <li>空闲线程执行 <code class="language-plaintext highlighter-rouge">hlt</code> 指令，使 CPU 进入低功耗状态</li>
  <li>这比忙等待更节能</li>
</ul>

<h4 id="第4行启用中断"><span class="me-2">第4行：启用中断</span><a href="#第4行启用中断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">intr_enable</span> <span class="p">();</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ul>
  <li>从这一刻起，定时器中断开始触发</li>
  <li>抢占式调度正式开始</li>
  <li>空闲线程可能在这之后被调度运行</li>
</ul>

<h4 id="第5行等待空闲线程初始化"><span class="me-2">第5行：等待空闲线程初始化</span><a href="#第5行等待空闲线程初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">sema_down</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">idle_started</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<p>这里可能发生以下情况：</p>

<p><strong>场景1：空闲线程先运行</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>主线程                     空闲线程
   │                          │
   │ create idle              │
   │────────────────────────→│
   │                          │
   │ enable interrupts        │
   │                          │
   │                    ┌─────┤ 被调度
   │                    │     │
   │                    │  idle_thread = self
   │                    │     │
   │                    │  sema_up()
   │◄───────────────────┘     │
   │                          │
   │ sema_down() (直接成功)   │
   │                          │
</pre></td></tr></tbody></table></code></div></div>

<p><strong>场景2：主线程继续运行</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>主线程                     空闲线程
   │                          │
   │ create idle              │
   │                          │ (在 ready_list 中)
   │ enable interrupts        │
   │                          │
   │ sema_down()              │
   │     (阻塞，信号量=0)     │
   │                    ┌─────┤ 被调度
   │                    │     │
   │                    │  idle_thread = self
   │                    │     │
   │                    │  sema_up()
   │◄───────────────────┘     │
   │ (唤醒)                   │
   │                          │
</pre></td></tr></tbody></table></code></div></div>

<h3 id="idle-函数解析"><span class="me-2">idle() 函数解析</span><a href="#idle-函数解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">idle</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">idle_started_</span> <span class="n">UNUSED</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">idle_started</span> <span class="o">=</span> <span class="n">idle_started_</span><span class="p">;</span>
  <span class="n">idle_thread</span> <span class="o">=</span> <span class="n">thread_current</span> <span class="p">();</span>
  <span class="n">sema_up</span> <span class="p">(</span><span class="n">idle_started</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> 
    <span class="p">{</span>
      <span class="cm">/* Let someone else run. */</span>
      <span class="n">intr_disable</span> <span class="p">();</span>
      <span class="n">thread_block</span> <span class="p">();</span>

      <span class="cm">/* Re-enable interrupts and wait for the next one.
         The `sti' instruction disables interrupts until the
         completion of the next instruction, so these two
         instructions are executed atomically.  This atomicity is
         important; otherwise, an interrupt could be handled
         between re-enabling interrupts and waiting for the next
         one to occur, wasting as much as one clock tick worth of
         time. */</span>
      <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"sti; hlt"</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"memory"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>详细解析</strong>：</p>

<ol>
  <li><strong>设置 idle_thread</strong>：
    <ul>
      <li>保存自己的线程指针到全局变量</li>
      <li>供调度器在就绪队列为空时使用</li>
    </ul>
  </li>
  <li><strong>通知主线程</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sema_up()</code> 释放信号量</li>
      <li>允许主线程继续执行</li>
    </ul>
  </li>
  <li><strong>无限循环</strong>：
    <div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  <span class="n">intr_disable</span> <span class="p">();</span>   <span class="c1">// 关中断</span>
  <span class="n">thread_block</span> <span class="p">();</span>   <span class="c1">// 阻塞自己，调度其他线程</span>
     
  <span class="c1">// 被唤醒后执行</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"sti; hlt"</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"memory"</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div>    </div>
  </li>
  <li><strong>sti; hlt 原子性</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sti</code>：开中断</li>
      <li><code class="language-plaintext highlighter-rouge">hlt</code>：停止 CPU 直到下一个中断</li>
      <li>x86 保证 <code class="language-plaintext highlighter-rouge">sti</code> 后的第一条指令不会被中断</li>
      <li>这确保了 <code class="language-plaintext highlighter-rouge">hlt</code> 能够被执行</li>
    </ul>
  </li>
</ol>

<p><strong>为什么需要这种原子性</strong>？</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>如果不是原子的：

时刻 T:   sti          (开中断)
时刻 T+1: [中断到来]   (处理中断，可能唤醒某个线程)
时刻 T+2: hlt          (进入睡眠，但应该运行被唤醒的线程！)

结果：浪费了处理器时间
</pre></td></tr></tbody></table></code></div></div>

<h3 id="thread_create-函数详解"><span class="me-2">thread_create() 函数详解</span><a href="#thread_create-函数详解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="n">tid_t</span>
<span class="nf">thread_create</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
               <span class="n">thread_func</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">kernel_thread_frame</span> <span class="o">*</span><span class="n">kf</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">switch_entry_frame</span> <span class="o">*</span><span class="n">ef</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">switch_threads_frame</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
  <span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">function</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="cm">/* Allocate thread. */</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ZERO</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TID_ERROR</span><span class="p">;</span>

  <span class="cm">/* Initialize thread. */</span>
  <span class="n">init_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
  <span class="n">tid</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>

  <span class="cm">/* Stack frame for kernel_thread(). */</span>
  <span class="n">kf</span> <span class="o">=</span> <span class="n">alloc_frame</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">kf</span><span class="p">);</span>
  <span class="n">kf</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">kf</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
  <span class="n">kf</span><span class="o">-&gt;</span><span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>

  <span class="cm">/* Stack frame for switch_entry(). */</span>
  <span class="n">ef</span> <span class="o">=</span> <span class="n">alloc_frame</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">ef</span><span class="p">);</span>
  <span class="n">ef</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">))</span> <span class="n">kernel_thread</span><span class="p">;</span>

  <span class="cm">/* Stack frame for switch_threads(). */</span>
  <span class="n">sf</span> <span class="o">=</span> <span class="n">alloc_frame</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">sf</span><span class="p">);</span>
  <span class="n">sf</span><span class="o">-&gt;</span><span class="n">eip</span> <span class="o">=</span> <span class="n">switch_entry</span><span class="p">;</span>
  <span class="n">sf</span><span class="o">-&gt;</span><span class="n">ebp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* Add to run queue. */</span>
  <span class="n">thread_unblock</span> <span class="p">(</span><span class="n">t</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">tid</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>栈帧布局</strong>：</p>

<p>新线程创建后，其栈的布局如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>4 KB  ┌───────────────────────────────┐
      │                               │
      │        (未使用的栈空间)        │
      │                               │
      ├───────────────────────────────┤
      │   kernel_thread_frame         │
      │  ┌─────────────────────────┐  │
      │  │ eip = NULL (返回地址)   │  │
      │  │ function (线程函数)     │  │
      │  │ aux (辅助参数)          │  │
      │  └─────────────────────────┘  │
      ├───────────────────────────────┤
      │   switch_entry_frame          │
      │  ┌─────────────────────────┐  │
      │  │ eip = kernel_thread     │  │
      │  └─────────────────────────┘  │
      ├───────────────────────────────┤
      │   switch_threads_frame        │
      │  ┌─────────────────────────┐  │
      │  │ eip = switch_entry      │  │ ← t-&gt;stack
      │  │ ebp = 0                 │  │
      │  │ ebx, esi, edi = 0       │  │
      │  └─────────────────────────┘  │
      ├───────────────────────────────┤
      │   struct thread               │
      │   (tid, name, priority, ...)  │
0 KB  └───────────────────────────────┘
</pre></td></tr></tbody></table></code></div></div>

<p><strong>首次调度时的执行流</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>1. switch_threads() 恢复 sf 中的寄存器
   └→ ret 执行，跳转到 switch_entry

2. switch_entry (in switch.S)
   └→ ret 执行，跳转到 kernel_thread

3. kernel_thread()
   intr_enable();        // 开中断
   function(aux);        // 执行用户提供的函数
   thread_exit();        // 线程结束
</pre></td></tr></tbody></table></code></div></div>

<h2 id="调度器核心函数"><span class="me-2">调度器核心函数</span><a href="#调度器核心函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="schedule-函数"><span class="me-2">schedule() 函数</span><a href="#schedule-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span>
<span class="nf">schedule</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_thread_to_run</span> <span class="p">();</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">THREAD_RUNNING</span><span class="p">);</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">is_thread</span> <span class="p">(</span><span class="n">next</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">next</span><span class="p">)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">switch_threads</span> <span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
  <span class="n">thread_schedule_tail</span> <span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>调度流程</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>schedule()
    │
    ├─→ cur = 当前线程
    │
    ├─→ next = next_thread_to_run()
    │         │
    │         ├─→ ready_list 非空? 取出第一个线程
    │         │
    │         └─→ ready_list 为空? 返回 idle_thread
    │
    ├─→ cur == next? ─→ 是 ─→ 跳过切换
    │         │
    │         └─→ 否 ─→ switch_threads(cur, next)
    │                     │
    │                     └─→ 保存 cur 的寄存器
    │                         恢复 next 的寄存器
    │                         返回 prev (= cur)
    │
    └─→ thread_schedule_tail(prev)
              │
              ├─→ 标记新线程为 RUNNING
              │
              ├─→ 重置时间片计数器
              │
              └─→ 如果 prev 正在死亡，释放其内存
</pre></td></tr></tbody></table></code></div></div>

<h3 id="switch_threads-函数-switchs"><span class="me-2">switch_threads() 函数 (switch.S)</span><a href="#switch_threads-函数-switchs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<pre><code class="language-assembly">.globl switch_threads
.func switch_threads
switch_threads:
    # Save caller's register state.
    pushl %ebx
    pushl %ebp
    pushl %esi
    pushl %edi

    # Get offsetof (struct thread, stack).
    mov thread_stack_ofs, %edx

    # Save current stack pointer to old thread's stack.
    movl SWITCH_CUR(%esp), %eax
    movl %esp, (%eax,%edx,1)

    # Restore stack pointer from new thread's stack.
    movl SWITCH_NEXT(%esp), %ecx
    movl (%ecx,%edx,1), %esp

    # Restore caller's register state.
    popl %edi
    popl %esi
    popl %ebp
    popl %ebx
    ret
.endfunc
</code></pre>

<p><strong>线程切换图示</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>切换前：                                  切换后：

线程 A (cur)                             线程 B (next)
┌─────────────┐                          ┌─────────────┐
│   栈顶      │                          │   栈顶      │
│     │       │                          │     │       │
│     ↓       │                          │     ↓       │
│             │                          │             │
│ [保存的寄存器]│◄── A-&gt;stack            │ [保存的寄存器]│◄── B-&gt;stack
└─────────────┘                          └─────────────┘
      ↑                                        │
      │                                        │
    ESP                                      ESP
      
                    switch_threads()
            ──────────────────────────────→
            保存 A 的 ESP 到 A-&gt;stack
            从 B-&gt;stack 恢复 ESP
</pre></td></tr></tbody></table></code></div></div>

<h2 id="线程生命周期"><span class="me-2">线程生命周期</span><a href="#线程生命周期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="完整生命周期示例"><span class="me-2">完整生命周期示例</span><a href="#完整生命周期示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>1. 创建阶段
   thread_create("worker", PRI_DEFAULT, worker_func, arg)
   │
   ├─→ 分配一页内存
   ├─→ 初始化 thread 结构体
   ├─→ 设置栈帧
   └─→ thread_unblock() → 加入 ready_list
       状态: BLOCKED → READY

2. 首次运行
   schedule() 选中新线程
   │
   ├─→ switch_threads() 切换栈
   ├─→ switch_entry → kernel_thread
   └─→ function(aux) 开始执行
       状态: READY → RUNNING

3. 正常运行
   │
   ├─→ 可能 yield → READY → RUNNING
   ├─→ 可能 block → BLOCKED → READY → RUNNING
   └─→ 继续执行

4. 退出阶段
   thread_exit()
   │
   ├─→ 从 all_list 移除
   ├─→ 状态设为 DYING
   └─→ schedule() → 永不返回
       
5. 清理阶段
   thread_schedule_tail() (由下一个线程执行)
   │
   └─→ palloc_free_page(prev) 释放内存
</pre></td></tr></tbody></table></code></div></div>

<h2 id="魔数与栈溢出检测"><span class="me-2">魔数与栈溢出检测</span><a href="#魔数与栈溢出检测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="thread_magic-的作用"><span class="me-2">THREAD_MAGIC 的作用</span><a href="#thread_magic-的作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="cp">#define THREAD_MAGIC 0xcd6abf4b
</span></pre></td></tr></tbody></table></code></div></div>

<p><strong>检测机制</strong>：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="k">static</span> <span class="n">bool</span>
<span class="nf">is_thread</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">THREAD_MAGIC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span>
<span class="nf">thread_current</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
  
  <span class="cm">/* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack. */</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">is_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">));</span>
  <span class="n">ASSERT</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">THREAD_RUNNING</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>栈溢出示意</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="code-header">
        <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>正常情况：
┌───────────────────────────────┐ 4KB
│           栈使用区             │
│             ↓                 │
├───────────────────────────────┤
│           空闲区               │
├───────────────────────────────┤
│  magic = 0xcd6abf4b ✓         │
│  ... 其他成员 ...             │
└───────────────────────────────┘ 0

栈溢出后：
┌───────────────────────────────┐ 4KB
│           栈使用区             │
│             ↓                 │
│             ↓                 │
│             ↓                 │
├───────────────────────────────┤
│  magic = ???????? ✗ (被覆盖)   │
│  ... 被破坏的数据 ...          │
└───────────────────────────────┘ 0
</pre></td></tr></tbody></table></code></div></div>

<h2 id="常见问题解答"><span class="me-2">常见问题解答</span><a href="#常见问题解答" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="q1-为什么主线程可以被转换而不是创建"><span class="me-2">Q1: 为什么主线程可以被”转换”而不是”创建”？</span><a href="#q1-为什么主线程可以被转换而不是创建" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ol>
  <li>系统启动时已经有代码在执行</li>
  <li>这个执行流需要被纳入线程管理</li>
  <li><code class="language-plaintext highlighter-rouge">loader.S</code> 确保了栈底对齐到页边界</li>
  <li>只需填充 thread 结构体即可</li>
</ol>

<h3 id="q2-为什么空闲线程优先级最低"><span class="me-2">Q2: 为什么空闲线程优先级最低？</span><a href="#q2-为什么空闲线程优先级最低" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ol>
  <li>空闲线程只在没有其他工作时运行</li>
  <li>最低优先级确保它不会抢占任何实际工作</li>
  <li>它的唯一目的是节省电力和等待中断</li>
</ol>

<h3 id="q3-thread_create-中的多个栈帧有什么作用"><span class="me-2">Q3: thread_create 中的多个栈帧有什么作用？</span><a href="#q3-thread_create-中的多个栈帧有什么作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>: 模拟线程之前被调度过的状态：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">switch_threads_frame</code>：模拟 <code class="language-plaintext highlighter-rouge">switch_threads</code> 调用点</li>
  <li><code class="language-plaintext highlighter-rouge">switch_entry_frame</code>：模拟返回到 <code class="language-plaintext highlighter-rouge">kernel_thread</code> 的入口</li>
  <li><code class="language-plaintext highlighter-rouge">kernel_thread_frame</code>：提供实际线程函数的参数</li>
</ol>

<h3 id="q4-为什么要等待空闲线程初始化"><span class="me-2">Q4: 为什么要等待空闲线程初始化？</span><a href="#q4-为什么要等待空闲线程初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><strong>A</strong>:</p>
<ol>
  <li>调度器需要 <code class="language-plaintext highlighter-rouge">idle_thread</code> 指针</li>
  <li>当 <code class="language-plaintext highlighter-rouge">ready_list</code> 为空时返回 <code class="language-plaintext highlighter-rouge">idle_thread</code></li>
  <li>如果不等待，可能返回 NULL 导致崩溃</li>
</ol>

<h2 id="练习题"><span class="me-2">练习题</span><a href="#练习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="练习1分析栈使用"><span class="me-2">练习1：分析栈使用</span><a href="#练习1分析栈使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>给定以下递归函数，计算需要多少栈空间：</p>

<div class="language-c highlighter-rouge"><div class="code-header">
        <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>假设每次函数调用使用 32 字节栈空间，Pintos 线程最多能计算多大的阶乘？</p>

<h3 id="练习2线程状态追踪"><span class="me-2">练习2：线程状态追踪</span><a href="#练习2线程状态追踪" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>画出以下场景中两个线程的状态转换：</p>
<ol>
  <li>主线程创建线程 A</li>
  <li>线程 A 运行并调用 <code class="language-plaintext highlighter-rouge">sema_down()</code> 阻塞</li>
  <li>主线程调用 <code class="language-plaintext highlighter-rouge">sema_up()</code> 唤醒线程 A</li>
  <li>线程 A 运行完毕退出</li>
</ol>

<h3 id="练习3修改时间片"><span class="me-2">练习3：修改时间片</span><a href="#练习3修改时间片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p><code class="language-plaintext highlighter-rouge">TIME_SLICE</code> 定义为 4 个时钟周期。如果改为：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">TIME_SLICE = 1</code>：会有什么影响？</li>
  <li><code class="language-plaintext highlighter-rouge">TIME_SLICE = 100</code>：会有什么影响？</li>
</ol>

<h3 id="练习4实现线程统计"><span class="me-2">练习4：实现线程统计</span><a href="#练习4实现线程统计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>添加一个函数 <code class="language-plaintext highlighter-rouge">thread_count()</code> 返回当前存活的线程数。</p>

<p><strong>提示</strong>：使用 <code class="language-plaintext highlighter-rouge">all_list</code> 链表。</p>

<h2 id="下一篇预告"><span class="me-2">下一篇预告</span><a href="#下一篇预告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>在下一篇文档中，我们将详细解析中断系统的初始化 <code class="language-plaintext highlighter-rouge">intr_init()</code>，了解 Pintos 如何设置 IDT（中断描述符表）和处理各种中断。</p>

<h2 id="参考资料"><span class="me-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<ol>
  <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer’s Manual</a></li>
  <li><a href="https://web.stanford.edu/class/cs140/projects/pintos/pintos_2.html">Pintos Documentation - Threads</a></li>
  <li><a href="https://wiki.osdev.org/Context_Switching">OSDev Wiki - Context Switching</a></li>
</ol>

  </div>

  <div class="post-tail-wrapper text-muted">
    <!-- categories -->
    

    <!-- tags -->
    

    <div
      class="
        post-tail-bottom
        d-flex justify-content-between align-items-center mt-5 pb-2
      "
    >
      <div class="license-wrapper">
        
          

          本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权
        
      </div>

      <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted">分享</span>
  <span class="share-icons">
    
    
    

    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="分享链接"
      data-title-succeed="链接已复制！"
    >
      <i class="fa-fw fas fa-link pe-none fs-6"></i>
    </button>
  </span>
</div>

    </div>
    <!-- .post-tail-bottom -->
  </div>
  <!-- div.post-tail-wrapper -->
</article>


            
          </main>

          <!-- panel -->
          <aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
            <div class="access">
              <!-- Get 5 last posted/updated posts -->














  <section id="access-lastmod">
    <h2 class="panel-heading">最近更新</h2>
    <ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-03-create/">Pintos 线程系统详解（三）：线程创建</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-04-schedule/">Pintos 线程系统详解（四）：线程调度</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-05-switch/">Pintos 线程系统详解（五）：上下文切换</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-06-block-unblock/">Pintos 线程系统详解（六）：阻塞与唤醒</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/pintos-thread-07-semaphore/">Pintos 线程系统详解（七）：信号量</a>
        </li>
      
    </ul>
  </section>
  <!-- #access-lastmod -->


              <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


            </div>

            
              
              






  <div class="toc-border-cover z-3"></div>
  <section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4">
    <h2 class="panel-heading ps-3 pb-2 mb-0">文章内容</h2>
    <nav id="toc"></nav>
  </section>


            
          </aside>
        </div>

        <div class="row">
          <!-- tail -->
          <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4">
            
              
              <!-- Recommend the other 3 posts according to the tags and categories of the current post. -->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->


























            
              
              <!-- Navigation buttons at the bottom of the post. -->

<nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation">
  
  

  
    <a
      href="/posts/pintos-kernel-11-paging-init/"
      class="btn btn-outline-primary"
      aria-label="上一篇"
    >
      <p>Pintos Kernel 11 Paging Init</p>
    </a>
  

  
    <a
      href="/posts/pintos-kernel-13-interrupt-init/"
      class="btn btn-outline-primary"
      aria-label="下一篇"
    >
      <p>Pintos Kernel 13 Interrupt Init</p>
    </a>
  
</nav>

            

            <!-- The Footer -->

<footer
  aria-label="Site Info"
  class="
    d-flex flex-column justify-content-center text-muted
    flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3
  "
>
  <p>©
    <time>2026</time>

    
      <a href="https://github.com/zxsheather">Zxsheather</a>.
    

    
      <span
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"
      >保留部分权利。</span>
    
  </p>

  <p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="v7.4.1"
        href="https://github.com/cotes2020/jekyll-theme-chirpy"
        target="_blank"
        rel="noopener"
      >Chirpy</a>
  </p>
</footer>

          </div>
        </div>

        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center d-none">
  <div class="col-11 content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <section>
    <h2 class="panel-heading">热门标签</h2>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/os/">OS</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pintos/">Pintos</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/">引导加载程序</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%86%85%E6%A0%B8/">内核</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/gdt/">GDT</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/x86/">x86</a>
      
    </div>
  </section>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>

      <aside aria-label="Scroll to Top">
        <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow">
          <i class="fas fa-angle-up"></i>
        </button>
      </aside>
    </div>

    <div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>

    
      <aside
  id="notification"
  class="toast"
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
  data-bs-animation="true"
  data-bs-autohide="false"
>
  <div class="toast-header">
    <button
      type="button"
      class="btn-close ms-auto"
      data-bs-dismiss="toast"
      aria-label="Close"
    ></button>
  </div>
  <div class="toast-body text-center pt-0">
    <p class="px-2 mb-3">发现新版本的内容。</p>
    <button type="button" class="btn btn-primary" aria-label="Update">
      更新
    </button>
  </div>
</aside>

    

    <!-- Embedded scripts -->

    
      
      <!-- The comments switcher -->


    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  
  document.addEventListener('DOMContentLoaded', () => {
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('search-results'),
      json: '/assets/js/data/search.json',
      searchResultTemplate: '  <article class="px-1 px-sm-2 px-lg-4 px-xl-0">    <header>      <h2><a href="{url}">{title}</a></h2>      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">        {categories}        {tags}      </div>    </header>    <p>{content}</p>  </article>',
      noResultsText: '<p class="mt-5">搜索结果为空</p>',
      templateMiddleware: function(prop, value, template) {
        if (prop === 'categories') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
          }
        }

        if (prop === 'tags') {
          if (value === '') {
            return `${value}`;
          } else {
            return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
          }
        }
      }
    });
  });
</script>

  </body>
</html>

