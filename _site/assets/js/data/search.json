[
  
  {
    "title": "Pintos 线程系统详解（十二）：优先级调度",
    "url": "/posts/pintos-thread-12-priority/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 优先级调度, 优先级捐赠",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中优先级调度的实现。Pintos 默认使用简单的轮转（Round-Robin）调度，但 Project 1 要求实现基于优先级的调度，以及解决优先级反转问题的优先级捐赠（Priority Donation）机制。    原始代码  优先级相关定义（thread.h）  /** Thread priorities. */ #define PRI_MIN 0                       /**&lt; Lowest priority. */ #define PRI_DEFAULT 31                  /**&lt; Default priority. */ #define PRI_MAX 63                      /**&lt; Highest priority. */  struct thread   {     // ...     int priority;                       /**&lt; Priority. */     struct list_elem allelem;           /**&lt; List element for all threads list. */     struct list_elem elem;              /**&lt; List element. */     // ...   };   优先级相关函数声明  void thread_set_priority (int); int thread_get_priority (void);   默认实现（thread.c）  /** Sets the current thread's priority to NEW_PRIORITY. */ void thread_set_priority (int new_priority)  {   thread_current ()-&gt;priority = new_priority; }  /** Returns the current thread's priority. */ int thread_get_priority (void)  {   return thread_current ()-&gt;priority; }   调度相关代码  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }     前置知识  1. 调度策略                 策略       描述       优点       缺点                       FCFS       先来先服务       简单，公平       平均等待时间长                 Round-Robin       轮转调度       响应时间好       频繁切换开销                 Priority       优先级调度       重要任务优先       可能饥饿                 MLFQ       多级反馈队列       兼顾多种需求       复杂           2. 优先级调度的问题  优先级反转（Priority Inversion）：  场景： - 高优先级线程 H (priority = 60) - 中优先级线程 M (priority = 40) - 低优先级线程 L (priority = 20) - L 持有一个锁，H 需要这个锁  时间线: t0: L 获取锁 t1: H 需要锁，阻塞等待 t2: M 就绪，开始运行（比 L 优先级高） t3: M 运行很长时间...     H 无法运行（因为 L 无法运行来释放锁）  结果：高优先级的 H 被中优先级的 M 间接阻塞！   3. 优先级捐赠（Priority Donation）  解决优先级反转的方法：  修正后: t0: L 获取锁 (priority = 20) t1: H 需要锁，阻塞     H 将自己的优先级捐赠给 L     L.priority 暂时提升到 60 t2: M 就绪，但 L 优先级更高     L 继续运行 t3: L 释放锁     L 恢复原优先级 20     H 运行（获得锁）     默认实现分析  当前的 FIFO 实现  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }   问题：总是取队列前端，不考虑优先级。  thread_unblock() 的实现  void thread_unblock (struct thread *t)  {   enum intr_level old_level;    ASSERT (is_thread (t));    old_level = intr_disable ();   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_push_back (&amp;ready_list, &amp;t-&gt;elem);  // 简单加到末尾   t-&gt;status = THREAD_READY;   intr_set_level (old_level); }   问题：不考虑优先级，直接加到队列末尾。    优先级调度实现方案  方案 1：修改 next_thread_to_run()  每次调度时找最高优先级的线程：  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;      // 找最高优先级的线程   struct list_elem *max_elem = list_max (&amp;ready_list,                                            thread_priority_less, NULL);   list_remove (max_elem);   return list_entry (max_elem, struct thread, elem); }  // 比较函数 bool thread_priority_less (const struct list_elem *a,                       const struct list_elem *b,                       void *aux UNUSED) {   struct thread *ta = list_entry (a, struct thread, elem);   struct thread *tb = list_entry (b, struct thread, elem);   return ta-&gt;priority &lt; tb-&gt;priority; }   方案 2：维护有序队列  插入时保持队列有序：  void thread_unblock (struct thread *t)  {   // ...   // 按优先级降序插入   list_insert_ordered (&amp;ready_list, &amp;t-&gt;elem,                         thread_priority_greater, NULL);   t-&gt;status = THREAD_READY;   // ... }     抢占式优先级调度  当高优先级线程就绪时，应该立即抢占：  修改 thread_unblock()  void thread_unblock (struct thread *t)  {   enum intr_level old_level;    ASSERT (is_thread (t));    old_level = intr_disable ();   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_insert_ordered (&amp;ready_list, &amp;t-&gt;elem,                         thread_priority_greater, NULL);   t-&gt;status = THREAD_READY;      // 如果被 unblock 的线程优先级更高，需要 yield   if (t-&gt;priority &gt; thread_current ()-&gt;priority)     {       if (!intr_context ())         thread_yield ();       else         intr_yield_on_return ();     }      intr_set_level (old_level); }   修改 thread_set_priority()  void thread_set_priority (int new_priority)  {   struct thread *cur = thread_current ();   int old_priority = cur-&gt;priority;   cur-&gt;priority = new_priority;      // 如果降低了优先级，可能需要 yield   if (new_priority &lt; old_priority)     thread_yield (); }     优先级捐赠实现  数据结构扩展  struct thread {   // ...   int priority;                    /* 有效优先级（可能被捐赠） */   int base_priority;               /* 原始优先级 */   struct lock *waiting_lock;       /* 正在等待的锁 */   struct list donations;           /* 捐赠给我的线程列表 */   struct list_elem donation_elem;  /* 用于捐赠列表 */   // ... };   优先级捐赠流程  sequenceDiagram     participant H as Thread H (priority=60)     participant L as Lock L     participant T as Thread L (priority=20)          T-&gt;&gt;L: lock_acquire(&amp;L)     Note over L: L.holder = T          H-&gt;&gt;L: lock_acquire(&amp;L)     Note over H: 检测到锁被占用&lt;br/&gt;H.waiting_lock = &amp;L          rect rgb(255, 220, 220)         Note over H,T: 捐赠优先级&lt;br/&gt;T.priority = max(20, 60) = 60     end          H-&gt;&gt;L: sema_down (H 阻塞)     Note over T: T 运行（优先级 60）          T-&gt;&gt;L: lock_release(&amp;L)     rect rgb(220, 255, 220)         Note over T: 恢复优先级&lt;br/&gt;T.priority = 20     end          L-&gt;&gt;H: H 被 unblock     Note over H: H 运行（优先级 60）   lock_acquire() 修改  void lock_acquire (struct lock *lock) {   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (!lock_held_by_current_thread (lock));    struct thread *cur = thread_current ();      if (lock-&gt;holder != NULL)     {       // 记录正在等待的锁       cur-&gt;waiting_lock = lock;              // 优先级捐赠       donate_priority (lock-&gt;holder, cur-&gt;priority);     }    sema_down (&amp;lock-&gt;semaphore);      // 获得锁   cur-&gt;waiting_lock = NULL;   lock-&gt;holder = cur; }  void donate_priority (struct thread *t, int priority) {   if (t-&gt;priority &lt; priority)     {       t-&gt;priority = priority;              // 如果 t 也在等待锁，需要嵌套捐赠       if (t-&gt;waiting_lock != NULL)         donate_priority (t-&gt;waiting_lock-&gt;holder, priority);     } }   lock_release() 修改  void lock_release (struct lock *lock)  {   ASSERT (lock != NULL);   ASSERT (lock_held_by_current_thread (lock));    struct thread *cur = thread_current ();      // 移除此锁相关的捐赠   remove_donations_for_lock (cur, lock);      // 重新计算有效优先级   update_priority (cur);      lock-&gt;holder = NULL;   sema_up (&amp;lock-&gt;semaphore);      // 可能需要 yield   thread_yield (); }  void update_priority (struct thread *t) {   // 从 base_priority 和所有捐赠中选最高的   int max_priority = t-&gt;base_priority;      for (struct list_elem *e = list_begin (&amp;t-&gt;donations);        e != list_end (&amp;t-&gt;donations);        e = list_next (e))     {       struct thread *donor = list_entry (e, struct thread, donation_elem);       if (donor-&gt;priority &gt; max_priority)         max_priority = donor-&gt;priority;     }      t-&gt;priority = max_priority; }     嵌套捐赠  当优先级捐赠需要传递多层时：  场景： - H (priority=60) 等待 Lock M - M (priority=40) 持有 Lock M，等待 Lock L - L (priority=20) 持有 Lock L  ┌────────────────────────────────────────────────────────────────────┐ │                        嵌套捐赠                                    │ │                                                                    │ │   H(60) ──等待──► Lock M ──持有者──► M(40→60)                     │ │                                        │                           │ │                                      等待                          │ │                                        ▼                           │ │                    Lock L ──持有者──► L(20→60)                     │ │                                                                    │ │   捐赠链：H → M → L                                               │ │   所有持有者的优先级都提升到 60                                    │ └────────────────────────────────────────────────────────────────────┘   实现嵌套捐赠  void donate_priority (struct thread *t, int priority) {   int depth = 0;   const int MAX_DEPTH = 8;  // 防止无限循环      while (t != NULL &amp;&amp; depth &lt; MAX_DEPTH)     {       if (t-&gt;priority &gt;= priority)         break;                t-&gt;priority = priority;              if (t-&gt;waiting_lock == NULL)         break;                t = t-&gt;waiting_lock-&gt;holder;       depth++;     } }     多重捐赠  一个线程可能收到多个捐赠：  场景： - L 持有 Lock A 和 Lock B - H1 (priority=60) 等待 Lock A - H2 (priority=50) 等待 Lock B  L 的有效优先级 = max(base, H1, H2) = max(20, 60, 50) = 60  当 L 释放 Lock A： L 的有效优先级 = max(base, H2) = max(20, 50) = 50     状态图  stateDiagram-v2     RUNNING: RUNNING (最高优先级)     READY: READY (有序队列)     BLOCKED: BLOCKED          RUNNING --&gt; READY : yield     RUNNING --&gt; BLOCKED : block     RUNNING --&gt; [*] : 完成/退出     READY --&gt; RUNNING : 调度：选择最高优先级     BLOCKED --&gt; READY : unblock（可能捐赠）     同步原语的优先级处理  Semaphore  void sema_up (struct semaphore *sema)  {   enum intr_level old_level;    old_level = intr_disable ();   if (!list_empty (&amp;sema-&gt;waiters))      {       // 唤醒最高优先级的等待者       struct list_elem *max_elem = list_max (&amp;sema-&gt;waiters,                                               thread_priority_less, NULL);       list_remove (max_elem);       thread_unblock (list_entry (max_elem, struct thread, elem));     }   sema-&gt;value++;   intr_set_level (old_level); }   Condition Variable  void cond_signal (struct condition *cond, struct lock *lock UNUSED)  {   if (!list_empty (&amp;cond-&gt;waiters))      {       // 唤醒最高优先级等待者的信号量       struct list_elem *max_elem = list_max (&amp;cond-&gt;waiters,                                               cond_waiter_priority_less, NULL);       list_remove (max_elem);       struct semaphore_elem *sema_elem =            list_entry (max_elem, struct semaphore_elem, elem);       sema_up (&amp;sema_elem-&gt;semaphore);     } }     常见问题  Q1: 为什么需要区分 priority 和 base_priority？  答：    priority 是有效优先级（考虑捐赠）   base_priority 是原始优先级   释放锁时需要恢复到原始优先级或其他捐赠值   Q2: 如何避免优先级捐赠中的死循环？  答：    限制嵌套深度（如 MAX_DEPTH = 8）   检测循环等待（死锁检测）   只在优先级真正提高时才传递   Q3: thread_set_priority() 如何与捐赠交互？  答： void thread_set_priority (int new_priority)  {   struct thread *cur = thread_current ();   cur-&gt;base_priority = new_priority;      // 重新计算有效优先级   update_priority (cur);      // 如果有效优先级降低了，可能需要 yield   thread_yield (); }   Q4: 为什么优先级捐赠只针对锁？  答：    信号量没有明确的”持有者”   条件变量的等待者不持有资源   只有锁有明确的持有-等待关系   Q5: 时间片耗尽时如何处理相同优先级的线程？  答：使用 Round-Robin。相同优先级的线程轮流执行，每个线程运行一个时间片（TIME_SLICE = 4 ticks）。    测试用例思考  优先级调度测试  void test_priority_scheduling (void) {   // 创建三个不同优先级的线程   thread_create (\"low\", 20, func, NULL);   thread_create (\"medium\", 40, func, NULL);   thread_create (\"high\", 60, func, NULL);      // 预期：high 先执行，然后 medium，最后 low }   优先级捐赠测试  void test_priority_donation (void) {   struct lock lock;   lock_init (&amp;lock);      // low 先获取锁   // 然后 high 尝试获取   // high 应该捐赠优先级给 low }     练习思考          实现题：完成 Pintos Project 1 的优先级调度部分。           分析题：比较优先级调度和 MLFQ 调度的优缺点。           设计题：如何实现优先级继承协议的变体——优先级天花板协议（Priority Ceiling Protocol）？           扩展题：研究 Linux 的实时调度策略（SCHED_FIFO, SCHED_RR），与 Pintos 对比。           调试题：如何检测优先级反转问题？设计一个监控工具。        总结  优先级调度是操作系统中重要的调度策略：                 方面       实现要点                       基本调度       维护有序队列或每次选择最高优先级                 抢占       unblock 和 set_priority 时检查是否需要 yield                 优先级反转       使用优先级捐赠解决                 嵌套捐赠       沿等待链传递优先级                 多重捐赠       维护捐赠列表，取最大值             文档系列总结  本系列文档详细介绍了 Pintos 线程系统的各个方面：     概述 - 线程系统架构总览   线程结构 - struct thread 详解   生命周期 - 线程状态转换   线程创建 - thread_create() 实现   调度 - 调度机制   上下文切换 - switch_threads() 实现   阻塞与唤醒 - thread_block/unblock   信号量 - 信号量实现   锁 - 锁实现   条件变量 - 条件变量实现   中断 - 中断与线程   空闲线程 - 空闲线程实现   优先级调度 - 优先级调度与捐赠   这些文档涵盖了理解和实现 Pintos Project 1 所需的核心知识。"
  },
  
  {
    "title": "Pintos 线程系统详解（十一）：空闲线程",
    "url": "/posts/pintos-thread-11-idle/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 空闲线程",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中空闲线程（Idle Thread）的实现。空闲线程是操作系统中特殊的系统线程，当没有其他线程可运行时，CPU 执行空闲线程来保持系统正常运行。    原始代码  空闲线程相关变量  /** Idle thread. */ static struct thread *idle_thread;  /** Initial thread, the thread running init.c:main(). */ static struct thread *initial_thread;  /** Statistics. */ static long long idle_ticks;    /**&lt; # of timer ticks spent idle. */ static long long kernel_ticks;  /**&lt; # of timer ticks in kernel threads. */ static long long user_ticks;    /**&lt; # of timer ticks in user programs. */   空闲线程创建  /** Called by the timer interrupt handler at each timer tick.    Thus, this function runs in an external interrupt context. */ void thread_tick (void)  {   struct thread *t = thread_current ();    /* Update statistics. */   if (t == idle_thread)     idle_ticks++; #ifdef USERPROG   else if (t-&gt;pagedir != NULL)     user_ticks++; #endif   else     kernel_ticks++;    /* Enforce preemption. */   if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return (); }   idle() 函数  /** Idle thread.  Executes when no other thread is ready to run.     The idle thread is initially put on the ready list by    thread_start().  It will be scheduled once initially, at which    point it initializes idle_thread, \"up\"s the semaphore passed    to it to enable thread_start() to continue, and immediately    blocks.  After that, the idle thread never appears in the    ready list.  It is returned by next_thread_to_run() as a    special case when the ready list is empty. */ static void idle (void *idle_started_ UNUSED)  {   struct semaphore *idle_started = idle_started_;   idle_thread = thread_current ();   sema_up (idle_started);    for (;;)      {       /* Let someone else run. */       intr_disable ();       thread_block ();        /* Re-enable interrupts and wait for the next one.           The `sti' instruction disables interrupts until the          completion of the next instruction, so these two          instructions are executed atomically.  This atomicity is          important; otherwise, an interrupt could be handled          between re-enabling interrupts and waiting for the next          one to occur, wasting as much as one clock tick worth of          time.           See [IA32-v2a] \"HLT\", [IA32-v2b] \"STI\", and [IA32-v3a]          7.11.1 \"HLT Instruction\". */       asm volatile (\"sti; hlt\" : : : \"memory\");     } }   thread_start() 中创建空闲线程  void thread_start (void)  {   /* Create the idle thread. */   struct semaphore idle_started;   sema_init (&amp;idle_started, 0);   thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);    /* Start preemptive thread scheduling. */   intr_enable ();    /* Wait for the idle thread to initialize idle_thread. */   sema_down (&amp;idle_started); }   next_thread_to_run() 中的特殊处理  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;  // 没有就绪线程时返回空闲线程   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }     前置知识  1. 为什么需要空闲线程？  问题：如果就绪队列为空，CPU 应该做什么？  场景： - Thread A: 等待 I/O - Thread B: 等待信号量 - 就绪队列: [空]  CPU: \"我该运行什么？\"   解决方案：空闲线程  有空闲线程: - Thread A: 等待 I/O - Thread B: 等待信号量 - 就绪队列: [空]  CPU: 运行空闲线程 (执行 HLT，节省电力)   2. HLT 指令  hlt     ; Halt - 暂停 CPU，直到发生中断   效果：    CPU 进入低功耗状态   当中断发生时，CPU 恢复执行   节省电力和减少发热   3. STI; HLT 组合的原子性  asm volatile (\"sti; hlt\" : : : \"memory\");   x86 保证：STI 指令执行后，CPU 会在下一条指令完成后才响应中断。  执行序列: STI         ; 启用中断（但不立即响应） HLT         ; 进入暂停状态             ; 现在才响应中断   为什么需要原子性？  如果不是原子的:  STI                         ; 启用中断 --- 定时器中断发生 ---    中断处理    返回 HLT                         ; 进入暂停  问题：错过了中断触发的机会，可能等待下一个 tick     空闲线程的生命周期  阶段 1：创建  void thread_start (void)  {   struct semaphore idle_started;   sema_init (&amp;idle_started, 0);   thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);  // 创建   // ... }   此时：    空闲线程被创建   状态为 READY   在就绪队列中   阶段 2：首次调度  static void idle (void *idle_started_)  {   struct semaphore *idle_started = idle_started_;   idle_thread = thread_current ();  // 记录自己   sema_up (idle_started);           // 通知 thread_start 继续   // ... }   空闲线程首次运行时：    设置全局 idle_thread 指针   通过信号量通知主线程继续   阶段 3：永久阻塞  for (;;)  {   intr_disable ();   thread_block ();   // ... }   空闲线程立即阻塞自己：    状态变为 BLOCKED   不在就绪队列中   但也不在任何等待队列中   阶段 4：特殊调度  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;  // 直接返回，不从队列取   // ... }   当没有其他线程时：    调度器特殊处理   直接返回 idle_thread   不通过就绪队列     空闲线程状态图  flowchart TD     A[\"系统启动\"] --&gt; B[\"thread_create('idle', ...)&lt;br/&gt;状态: READY&lt;br/&gt;在就绪队列中\"]     B --&gt; C[\"首次被调度\"]     C --&gt; D[\"idle() 开始执行&lt;br/&gt;idle_thread = thread_current()&lt;br/&gt;sema_up(idle_started)\"]     D --&gt; E[\"永久循环\"]          subgraph Loop [\"空闲循环\"]         E --&gt; F[\"intr_disable()&lt;br/&gt;thread_block()&lt;br/&gt;状态: BLOCKED\"]         F --&gt; G[\"next_thread_to_run()&lt;br/&gt;当就绪队列为空时返回 idle_thread\"]         G --&gt; H[\"sti; hlt&lt;br/&gt;CPU 进入低功耗状态&lt;br/&gt;等待中断\"]         H --&gt; I[\"发生中断（通常是定时器）&lt;br/&gt;中断处理&lt;br/&gt;可能 unblock 某个线程\"]         I --&gt; J{\"有线程就绪？\"}         J --&gt;|\"是\"| K[\"切换到其他线程\"]         J --&gt;|\"否\"| E         K --&gt; L[\"其他线程执行...\"]         L --&gt; M[\"所有线程阻塞\"]         M --&gt; G     end     空闲线程的特殊性  1. 不在就绪队列中  static void idle (void *idle_started_)  {   // ...   for (;;)      {       intr_disable ();       thread_block ();  // 阻塞，但不加入任何等待队列       // ...     } }   普通线程阻塞前通常会加入某个等待队列： // 普通线程 list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem); thread_block ();   空闲线程直接阻塞，不加入任何队列。  2. 特殊的调度处理  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;  // 特殊处理   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }   3. 最低优先级  thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);                        ^^^^^^^                        最低优先级   确保空闲线程只在没有其他线程时运行。  4. 统计分离  void thread_tick (void)  {   struct thread *t = thread_current ();    if (t == idle_thread)     idle_ticks++;     // 空闲时间单独统计   else if (t-&gt;pagedir != NULL)     user_ticks++;   else     kernel_ticks++;   // ... }     为什么使用 thread_block() 而不是 yield()？  // idle() 中 for (;;)  {   intr_disable ();   thread_block ();  // 使用 block   asm volatile (\"sti; hlt\" : : : \"memory\"); }   如果使用 yield()： for (;;)  {   thread_yield ();  // 错误！ }   问题：    yield 会把线程放回就绪队列   如果就绪队列只有空闲线程，又会调度到它   无限循环，浪费 CPU   使用 block() 的好处：    空闲线程不在就绪队列中   由调度器特殊处理返回   可以执行 HLT 节省电力     同步：信号量的使用  void thread_start (void)  {   struct semaphore idle_started;   sema_init (&amp;idle_started, 0);      thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);      intr_enable ();      sema_down (&amp;idle_started);  // 等待空闲线程初始化完成 }  static void idle (void *idle_started_)  {   struct semaphore *idle_started = idle_started_;   idle_thread = thread_current ();   sema_up (idle_started);  // 通知初始化完成   // ... }   为什么需要同步？  确保 idle_thread 变量被设置后，才能使用它：  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;  // 必须确保 idle_thread 已设置   // ... }     常见问题  Q1: 为什么空闲线程是必须的？  答：    调度器需要一个总是可运行的线程   没有空闲线程，就绪队列为空时无法处理   空闲线程可以执行 HLT 节省电力   Q2: 空闲线程为什么用最低优先级？  答：确保只有在没有其他线程可运行时才运行空闲线程。如果优先级高，可能会抢占真正的工作线程。  Q3: 为什么在循环开始禁用中断？  答： intr_disable (); thread_block ();  确保 thread_block() 时不会被中断打断。如果在检查状态和 block 之间发生中断，可能导致问题。  Q4: HLT 之后如何被唤醒？  答：任何中断（通常是定时器中断）都会唤醒 CPU。中断处理完成后，CPU 继续执行 HLT 后面的代码（循环回到 thread_block）。  Q5: 空闲线程会被 unblock 吗？  答：不会！空闲线程从不被显式 unblock。它通过 next_thread_to_run() 的特殊处理被选中运行。    CPU 利用率计算  /** Prints thread statistics. */ void thread_print_stats (void)  {   printf (\"Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\\n\",           idle_ticks, kernel_ticks, user_ticks); }   CPU 利用率 = (kernel_ticks + user_ticks) / (idle_ticks + kernel_ticks + user_ticks) × 100%    练习思考          分析题：如果删除空闲线程的代码，系统会发生什么？           设计题：如何实现一个空闲任务，在系统空闲时执行低优先级的后台工作？           扩展题：研究 Linux 的 CPU 空闲处理机制（cpuidle），与 Pintos 对比。           调试题：如何统计系统在不同电源状态下的时间分布？           思考题：在多核系统中，空闲线程应该如何处理？        下一步  理解了空闲线程的实现后，下一篇文档将介绍优先级调度的实现。"
  },
  
  {
    "title": "Pintos 线程系统详解（十）：中断处理",
    "url": "/posts/pintos-thread-10-interrupt/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 中断, 线程",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中中断系统与线程调度的关系。中断是操作系统的核心机制，它允许 CPU 响应外部事件（如定时器、键盘），并在此基础上实现抢占式调度。    原始代码  interrupt.h 中的关键定义  /** Interrupts on or off? */ enum intr_level    {     INTR_OFF,             /**&lt; Interrupts disabled. */     INTR_ON               /**&lt; Interrupts enabled. */   };  enum intr_level intr_get_level (void); enum intr_level intr_set_level (enum intr_level); enum intr_level intr_enable (void); enum intr_level intr_disable (void);  bool intr_context (void); void intr_yield_on_return (void);   interrupt.c 中的关键实现  /** Returns the current interrupt status. */ enum intr_level intr_get_level (void)  {   uint32_t flags;   asm volatile (\"pushfl; popl %0\" : \"=g\" (flags));   return flags &amp; FLAG_IF ? INTR_ON : INTR_OFF; }  /** Enables interrupts and returns the previous interrupt status. */ enum intr_level intr_enable (void)  {   enum intr_level old_level = intr_get_level ();   ASSERT (!intr_context ());   asm volatile (\"sti\");   return old_level; }  /** Disables interrupts and returns the previous interrupt status. */ enum intr_level intr_disable (void)  {   enum intr_level old_level = intr_get_level ();   asm volatile (\"cli\" : : : \"memory\");   return old_level; }  /** Returns true during processing of an external interrupt    and false at all other times. */ bool intr_context (void)  {   return in_external_intr; }  /** During processing of an external interrupt, directs the    interrupt handler to yield to a new process just before    returning from the interrupt. */ void intr_yield_on_return (void)  {   ASSERT (intr_context ());   yield_on_return = true; }   中断处理主函数  void intr_handler (struct intr_frame *frame)  {   bool external;   intr_handler_func *handler;    external = frame-&gt;vec_no &gt;= 0x20 &amp;&amp; frame-&gt;vec_no &lt; 0x30;   if (external)      {       ASSERT (intr_get_level () == INTR_OFF);       ASSERT (!intr_context ());        in_external_intr = true;       yield_on_return = false;     }    handler = intr_handlers[frame-&gt;vec_no];   if (handler != NULL)     handler (frame);   else if (frame-&gt;vec_no == 0x27 || frame-&gt;vec_no == 0x2f)     {       /* Spurious interrupt, ignore. */     }   else     unexpected_interrupt (frame);    if (external)      {       ASSERT (intr_get_level () == INTR_OFF);       ASSERT (intr_context ());        in_external_intr = false;       pic_end_of_interrupt (frame-&gt;vec_no);         if (yield_on_return)          thread_yield ();      } }     前置知识  1. 什么是中断？  中断是 CPU 暂停当前执行，转去处理其他事件的机制。  正常执行: 指令1 → 指令2 → 指令3 → 指令4 → ...  发生中断: 指令1 → 指令2 → [中断!] → 中断处理 → 指令3 → ...   2. 中断的类型                 类型       来源       示例       向量号                       异常（Exception）       CPU 内部       除零、页错误       0-31                 外部中断（External）       外部设备       定时器、键盘       32-47                 软件中断（Software）       int 指令       系统调用       可配置           3. x86 中断机制  ┌─────────────────────────────────────────────────────────────────┐ │                        CPU                                       │ │  ┌─────────┐                                                    │ │  │  EFLAGS │ ─── IF (Interrupt Flag) 位控制中断是否启用         │ │  └─────────┘                                                    │ │       │                                                          │ │       ▼                                                          │ │  IF=1 时，CPU 在每条指令后检查是否有待处理的中断                │ │       │                                                          │ │       ▼                                                          │ │  ┌─────────────────────────────────────────┐                    │ │  │         IDT (中断描述符表)               │                    │ │  │  0: 除零异常                             │                    │ │  │  ...                                     │                    │ │  │  32 (0x20): 定时器中断                   │                    │ │  │  33 (0x21): 键盘中断                     │                    │ │  │  ...                                     │                    │ │  └─────────────────────────────────────────┘                    │ └─────────────────────────────────────────────────────────────────┘   4. CLI 和 STI 指令  cli     ; Clear Interrupt flag - 禁用中断 sti     ; Set Interrupt flag - 启用中断     中断级别控制  intr_disable() 和 intr_enable()  enum intr_level intr_disable (void)  {   enum intr_level old_level = intr_get_level ();   asm volatile (\"cli\" : : : \"memory\");  // 禁用中断   return old_level; }  enum intr_level intr_enable (void)  {   enum intr_level old_level = intr_get_level ();   ASSERT (!intr_context ());  // 不能在中断处理中启用   asm volatile (\"sti\");       // 启用中断   return old_level; }   intr_set_level() - 设置到指定级别  enum intr_level intr_set_level (enum intr_level level)  {   return level == INTR_ON ? intr_enable () : intr_disable (); }   典型使用模式  void some_critical_function (void) {   enum intr_level old_level;      old_level = intr_disable ();  // 禁用中断   // --- 临界区开始 ---      do_something_critical ();      // --- 临界区结束 ---   intr_set_level (old_level);   // 恢复之前的状态 }   为什么返回 old_level？  支持嵌套调用：  void outer (void) {   enum intr_level l1 = intr_disable ();  // 禁用   inner ();   intr_set_level (l1);  // 恢复（仍禁用） }  void inner (void) {   enum intr_level l2 = intr_disable ();  // 已禁用，无操作   // ...   intr_set_level (l2);  // 恢复（仍禁用） }     中断上下文  intr_context() - 检查是否在中断处理中  static bool in_external_intr;  // 是否在处理外部中断  bool intr_context (void)  {   return in_external_intr; }   为什么需要知道是否在中断上下文？  很多操作在中断上下文中是不允许的：  void thread_yield (void)  {   ASSERT (!intr_context ());  // 不能在中断处理中 yield   // ... }  void thread_block (void)  {   ASSERT (!intr_context ());  // 不能在中断处理中阻塞   // ... }  enum intr_level intr_enable (void)  {   ASSERT (!intr_context ());  // 不能在中断处理中启用中断   // ... }   原因：    中断处理必须快速完成   中断处理不应该被调度   嵌套中断可能导致复杂问题     中断与线程调度  定时器中断驱动调度  // timer.c void timer_interrupt (struct intr_frame *args UNUSED) {   ticks++;   thread_tick ();  // 通知线程系统 }  // thread.c void thread_tick (void)  {   struct thread *t = thread_current ();    // 更新统计   if (t == idle_thread)     idle_ticks++;   else if (t-&gt;pagedir != NULL)     user_ticks++;   else     kernel_ticks++;    // 检查时间片   if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return ();  // 请求在中断返回时 yield }   intr_yield_on_return() - 延迟 yield  static bool yield_on_return;  // 是否在中断返回时 yield  void intr_yield_on_return (void)  {   ASSERT (intr_context ());  // 必须在中断上下文中   yield_on_return = true; }   为什么不直接调用 thread_yield()？     中断处理中不能调用会阻塞的函数   需要先完成中断处理   在中断返回时再 yield 更安全   中断返回时的 yield  void intr_handler (struct intr_frame *frame)  {   // ... 处理中断 ...    if (external)      {       in_external_intr = false;       pic_end_of_interrupt (frame-&gt;vec_no);  // 确认中断        if (yield_on_return)          thread_yield ();  // 现在可以安全地 yield     } }     中断处理流程图  flowchart TD     A[正常执行&lt;br/&gt;中断已启用] --&gt; B{发生定时器中断}     B --&gt; C[CPU 自动:&lt;br/&gt;1. 禁用中断&lt;br/&gt;2. 保存状态到栈&lt;br/&gt;3. 跳转到 IDT]     C --&gt; D[intr_handler&lt;br/&gt;in_external_intr = true]     D --&gt; E[timer_interrupt&lt;br/&gt;thread_tick&lt;br/&gt;intr_yield_on_return]     E --&gt; F[处理完成:&lt;br/&gt;in_external_intr = false&lt;br/&gt;pic_end_of_interrupt]     F --&gt; G{yield_on_return?}     G --&gt;|是| H[thread_yield]     G --&gt;|否| I[返回被中断的代码&lt;br/&gt;恢复状态，启用中断]     H --&gt; I     中断与同步原语  为什么同步原语要禁用中断？  void sema_down (struct semaphore *sema)  {   enum intr_level old_level;    old_level = intr_disable ();  // 禁用中断   while (sema-&gt;value == 0)      {       list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);       thread_block ();     }   sema-&gt;value--;   intr_set_level (old_level); }   原因：保证原子性  如果不禁用中断:  Thread A                    定时器中断 ─────────                   ───────── 检查 value == 0                             抢占！切换到 Thread B                             Thread B: sema_up()                             value = 1                             unblock A（但 A 不在等待队列！） 加入等待队列 block()                     // A 永远阻塞   中断与锁的区别                 方面       禁用中断       锁                       粒度       全局       特定资源                 阻塞       不阻塞       可能阻塞                 时长       应该很短       可以较长                 嵌套       支持       Pintos 不支持                 中断中使用       可以       不能 acquire           选择原则：    非常短的临界区 → 禁用中断   较长的临界区 → 使用锁     中断帧（Interrupt Frame）  struct intr_frame   {     /* 由 intr_entry 保存 */     uint32_t edi, esi, ebp, esp_dummy;     uint32_t ebx, edx, ecx, eax;     uint16_t gs, fs, es, ds;      /* 由 intrNN_stub 保存 */     uint32_t vec_no;     uint32_t error_code;     void *frame_pointer;      /* 由 CPU 保存 */     void (*eip) (void);     uint16_t cs;     uint32_t eflags;     void *esp;     uint16_t ss;   };   中断帧包含了被中断时的完整 CPU 状态。    常见问题  Q1: 什么时候应该禁用中断？  答：    访问共享数据结构（如就绪队列）   需要原子操作的场景   非常短的临界区   Q2: 中断处理程序能做什么？  答：    ✓ 读写全局变量   ✓ 调用 sema_up()   ✓ 调用 thread_unblock()   ✗ 调用 thread_yield()   ✗ 调用 thread_block()   ✗ 调用 lock_acquire()   ✗ 调用 printf()（在 Pintos 中可以，但应避免）   Q3: 为什么 intr_enable 不能在中断上下文中调用？  答：因为外部中断不能嵌套。如果在处理中断时启用中断，可能导致：    同一中断再次发生   状态不一致   栈溢出   Q4: 抢占是如何实现的？  答：    定时器每 tick 触发一次中断   thread_tick() 检查是否时间片耗尽   如果耗尽，调用 intr_yield_on_return()   中断返回时调用 thread_yield()   调度器选择下一个线程运行   Q5: 为什么禁用中断不会导致死锁？  答：禁用中断只是阻止 CPU 响应中断，不会阻止当前代码执行。只要确保禁用中断的时间很短，就不会有问题。    练习思考          分析题：如果长时间禁用中断会有什么后果？           设计题：如何实现一个可在中断上下文中调用的安全队列？           调试题：如何检测代码在中断上下文中做了不允许的操作？           思考题：为什么 Pintos 选择在中断返回时 yield，而不是立即 yield？           扩展题：研究 Linux 的中断处理机制（top half / bottom half），与 Pintos 对比。        下一步  理解了中断与线程的关系后，下一篇文档将介绍空闲线程（Idle Thread）的实现。"
  },
  
  {
    "title": "Pintos 线程系统详解（九）：条件变量",
    "url": "/posts/pintos-thread-09-condition/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 同步, 条件变量",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中条件变量（Condition Variable）的实现。条件变量允许线程等待特定条件成立，是实现复杂同步场景的重要工具。  条件变量必须与锁配合使用，用于：    等待某个条件变为真   通知条件已改变     原始代码  synch.h 中的定义  /** Condition variable. */ struct condition    {     struct list waiters;        /**&lt; List of waiting threads. */   };  void cond_init (struct condition *); void cond_wait (struct condition *, struct lock *); void cond_signal (struct condition *, struct lock *); void cond_broadcast (struct condition *, struct lock *);   synch.c 中的实现  /** One semaphore in a list. */ struct semaphore_elem    {     struct list_elem elem;              /**&lt; List element. */     struct semaphore semaphore;         /**&lt; This semaphore. */   };  /** Initializes condition variable COND.  A condition variable    allows one piece of code to signal a condition and cooperating    code to receive the signal and act upon it. */ void cond_init (struct condition *cond) {   ASSERT (cond != NULL);    list_init (&amp;cond-&gt;waiters); }  /** Atomically releases LOCK and waits for COND to be signaled by    some other piece of code.  After COND is signaled, LOCK is    reacquired before returning.  LOCK must be held before calling    this function.     The monitor implemented by this function is \"Mesa\" style, not    \"Hoare\" style, that is, sending and receiving a signal are not    an atomic operation.  Thus, typically the caller must recheck    the condition after the wait completes and, if necessary, wait    again.     A given condition variable is associated with only a single    lock, but one lock may be associated with any number of    condition variables.  That is, there is a one-to-many mapping    from locks to condition variables.     This function may sleep, so it must not be called within an    interrupt handler.  This function may be called with    interrupts disabled, but interrupts will be turned back on if    we need to sleep. */ void cond_wait (struct condition *cond, struct lock *lock)  {   struct semaphore_elem waiter;    ASSERT (cond != NULL);   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (lock_held_by_current_thread (lock));      sema_init (&amp;waiter.semaphore, 0);   list_push_back (&amp;cond-&gt;waiters, &amp;waiter.elem);   lock_release (lock);   sema_down (&amp;waiter.semaphore);   lock_acquire (lock); }  /** If any threads are waiting on COND (protected by LOCK), then    this function signals one of them to wake up from its wait.    LOCK must be held before calling this function.     An interrupt handler cannot acquire a lock, so it does not    make sense to try to signal a condition variable within an    interrupt handler. */ void cond_signal (struct condition *cond, struct lock *lock UNUSED)  {   ASSERT (cond != NULL);   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (lock_held_by_current_thread (lock));    if (!list_empty (&amp;cond-&gt;waiters))      sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;waiters),                           struct semaphore_elem, elem)-&gt;semaphore); }  /** Wakes up all threads, if any, waiting on COND (protected by    LOCK).  LOCK must be held before calling this function.     An interrupt handler cannot acquire a lock, so it does not    make sense to try to signal a condition variable within an    interrupt handler. */ void cond_broadcast (struct condition *cond, struct lock *lock)  {   ASSERT (cond != NULL);   ASSERT (lock != NULL);    while (!list_empty (&amp;cond-&gt;waiters))     cond_signal (cond, lock); }     前置知识  1. 为什么需要条件变量？  考虑一个生产者-消费者场景：  // 消费者 - 不好的实现（忙等待） while (true) {   lock_acquire (&amp;buffer_lock);   while (buffer_is_empty ()) {     lock_release (&amp;buffer_lock);     thread_yield ();              // 忙等待！     lock_acquire (&amp;buffer_lock);   }   consume (buffer_get ());   lock_release (&amp;buffer_lock); }   问题：即使缓冲区为空，消费者也在不断检查，浪费 CPU。  条件变量的解决方案：  // 消费者 - 好的实现 while (true) {   lock_acquire (&amp;buffer_lock);   while (buffer_is_empty ()) {     cond_wait (&amp;not_empty, &amp;buffer_lock);  // 高效等待   }   consume (buffer_get ());   lock_release (&amp;buffer_lock); }   2. Monitor（管程）概念  Monitor 是一种同步机制，包含：    锁：保护共享数据   条件变量：等待/通知机制   共享数据   Pintos 的条件变量实现了 Mesa 风格的管程：    signal 只是唤醒等待者，不会立即切换   等待者被唤醒后需要重新检查条件   3. Mesa vs Hoare 风格                 特性       Mesa 风格       Hoare 风格                       signal 后       继续执行       立即切换到等待者                 wait 后       需要重新检查条件       条件保证为真                 实现复杂度       简单       复杂                 Pintos 使用       ✓                   // Mesa 风格必须用 while while (!condition) {   cond_wait (&amp;cond, &amp;lock); }  // Hoare 风格可以用 if（但通常也用 while 更安全） if (!condition) {   cond_wait (&amp;cond, &amp;lock); }     struct condition 详解  struct condition    {     struct list waiters;        /**&lt; List of waiting threads. */   };   非常简单：只有一个等待者列表。  但等待者不是直接的线程，而是 semaphore_elem：  struct semaphore_elem    {     struct list_elem elem;              /**&lt; List element. */     struct semaphore semaphore;         /**&lt; This semaphore. */   };   为什么用信号量而不是直接用线程？  每个等待者都有自己的信号量，这样可以：    精确唤醒特定等待者   等待者可以自己的速度运行     cond_init() 详解  void cond_init (struct condition *cond) {   ASSERT (cond != NULL);    list_init (&amp;cond-&gt;waiters); }   初始化条件变量：只需初始化等待者列表。    cond_wait() 详解  这是最复杂的函数：  void cond_wait (struct condition *cond, struct lock *lock)  {   struct semaphore_elem waiter;    ASSERT (cond != NULL);   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (lock_held_by_current_thread (lock));  // 必须持有锁      sema_init (&amp;waiter.semaphore, 0);             // 初始化信号量为 0   list_push_back (&amp;cond-&gt;waiters, &amp;waiter.elem); // 加入等待队列   lock_release (lock);                           // 释放锁   sema_down (&amp;waiter.semaphore);                // 等待（阻塞）   lock_acquire (lock);                           // 被唤醒后重新获取锁 }   执行流程  线程 A 调用 cond_wait(&amp;cond, &amp;lock)          │          ▼     检查断言（必须持有锁）          │          ▼     创建 semaphore_elem waiter     sema_init(&amp;waiter.semaphore, 0)          │          ▼     加入 cond-&gt;waiters 队列          │          ▼     lock_release(lock)     ← 释放锁！          │          ▼     sema_down(&amp;waiter.semaphore)  ← 阻塞等待          │          │ (其他线程调用 cond_signal)          │          ▼     lock_acquire(lock)     ← 重新获取锁          │          ▼       返回   关键点     必须持有锁：在检查条件和等待之间需要原子性   释放锁再等待：否则其他线程无法修改条件   被唤醒后重新获取锁：保持调用前后锁的状态一致   为什么用局部变量 waiter？  waiter 在栈上分配，当函数返回时自动销毁。这是安全的，因为：    cond_wait 返回时，waiter 已经被移出队列（由 cond_signal 的 list_pop_front）   函数返回前，不再需要 waiter     cond_signal() 详解  void cond_signal (struct condition *cond, struct lock *lock UNUSED)  {   ASSERT (cond != NULL);   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (lock_held_by_current_thread (lock));  // 必须持有锁    if (!list_empty (&amp;cond-&gt;waiters))      sema_up (&amp;list_entry (list_pop_front (&amp;cond-&gt;waiters),                           struct semaphore_elem, elem)-&gt;semaphore); }   执行流程  线程 B 调用 cond_signal(&amp;cond, &amp;lock)          │          ▼     检查断言（必须持有锁）          │          ▼     waiters 空?  ────► 是 ────► 什么都不做          │          │ 否          │          ▼     取出队首的 semaphore_elem          │          ▼     sema_up(&amp;elem-&gt;semaphore)          │          ▼       返回   关键点     只唤醒一个：使用 list_pop_front   FIFO 顺序：先等待的先被唤醒   可能无人等待：waiters 可能为空     cond_broadcast() 详解  void cond_broadcast (struct condition *cond, struct lock *lock)  {   ASSERT (cond != NULL);   ASSERT (lock != NULL);    while (!list_empty (&amp;cond-&gt;waiters))     cond_signal (cond, lock); }   唤醒所有等待者。简单地重复调用 cond_signal。  使用场景：    当条件改变可能影响多个等待者时   当不知道哪个等待者应该被唤醒时     条件变量的使用模式  1. 等待条件模式  lock_acquire (&amp;lock); while (!condition) {           // 用 while，不用 if   cond_wait (&amp;cond, &amp;lock); } // 条件现在为真 do_something (); lock_release (&amp;lock);   2. 通知模式  lock_acquire (&amp;lock); change_condition ();           // 修改条件 cond_signal (&amp;cond, &amp;lock);    // 通知等待者 // 或 cond_broadcast (&amp;cond, &amp;lock); lock_release (&amp;lock);   3. 生产者-消费者完整示例  struct buffer {   struct lock lock;   struct condition not_empty;   struct condition not_full;   int items[BUFFER_SIZE];   int count;   int in, out; };  void buffer_init (struct buffer *b) {   lock_init (&amp;b-&gt;lock);   cond_init (&amp;b-&gt;not_empty);   cond_init (&amp;b-&gt;not_full);   b-&gt;count = 0;   b-&gt;in = b-&gt;out = 0; }  void producer (struct buffer *b, int item) {   lock_acquire (&amp;b-&gt;lock);      while (b-&gt;count == BUFFER_SIZE)     cond_wait (&amp;b-&gt;not_full, &amp;b-&gt;lock);  // 等待有空位      b-&gt;items[b-&gt;in] = item;   b-&gt;in = (b-&gt;in + 1) % BUFFER_SIZE;   b-&gt;count++;      cond_signal (&amp;b-&gt;not_empty, &amp;b-&gt;lock);  // 通知有数据   lock_release (&amp;b-&gt;lock); }  int consumer (struct buffer *b) {   int item;   lock_acquire (&amp;b-&gt;lock);      while (b-&gt;count == 0)     cond_wait (&amp;b-&gt;not_empty, &amp;b-&gt;lock);  // 等待有数据      item = b-&gt;items[b-&gt;out];   b-&gt;out = (b-&gt;out + 1) % BUFFER_SIZE;   b-&gt;count--;      cond_signal (&amp;b-&gt;not_full, &amp;b-&gt;lock);   // 通知有空位   lock_release (&amp;b-&gt;lock);      return item; }     cond_wait 的原子性  void cond_wait (struct condition *cond, struct lock *lock)  {   // ...   list_push_back (&amp;cond-&gt;waiters, &amp;waiter.elem);   lock_release (lock);            // ← 这两步必须原子   sema_down (&amp;waiter.semaphore);  // ← 否则可能丢失信号   lock_acquire (lock); }   问题场景（如果不是原子的）：  Thread A (等待者)              Thread B (通知者) ─────────────────────         ───────────────────── lock_release(lock)                               lock_acquire(lock)                               change_condition()                               cond_signal(...)  // 信号丢失！                               lock_release(lock) sema_down(...)  // 永远等待   为什么 Pintos 的实现是安全的？  因为：    lock_release 前，A 已经在等待队列中   sema_down 会阻塞，即使 sema_up 还没调用   如果 B 在 A 的 lock_release 和 sema_down 之间调用 cond_signal，A 的信号量会被 up，sema_down 会立即返回     条件变量状态图                      cond_init()                          │                          ▼                    ┌───────────┐                    │ waiters=[]│                    │   (空)    │                    └───────────┘                          │                          │ Thread A: cond_wait                          ▼                    ┌───────────┐                    │waiters=[A]│  A 的信号量值为 0                    └───────────┘                          │           ┌──────────────┴──────────────┐           │                             │           │ Thread B: cond_wait         │ Thread C: cond_signal           ▼                             ▼    ┌───────────┐                 ┌───────────┐    │waiters=   │                 │ waiters=[]│  A 被唤醒    │  [A, B]   │                 └───────────┘    └───────────┘           │           │ Thread C: cond_broadcast           ▼    ┌───────────┐    │ waiters=[]│  A 和 B 都被唤醒    └───────────┘     常见问题  Q1: 为什么 cond_wait 必须用 while 循环？  答：因为 Mesa 风格的管程中，被唤醒的线程不保证条件仍然为真：     虚假唤醒：多个线程等待同一条件   竞争：从被唤醒到重新获取锁之间，条件可能又变了   // 错误 if (!condition) {   cond_wait (&amp;cond, &amp;lock); } // 可能条件仍然为假！  // 正确 while (!condition) {   cond_wait (&amp;cond, &amp;lock); } // 条件保证为真   Q2: signal 和 broadcast 有什么区别？  答：    signal：唤醒一个等待者（效率高）   broadcast：唤醒所有等待者（更安全）   使用 broadcast 的场景：    条件变化可能满足多个等待者   不同等待者等待不同条件   不确定哪个等待者应该被唤醒   Q3: 为什么条件变量必须和锁一起使用？  答：为了保护条件检查的原子性：  // 没有锁 - 危险！ if (!condition) {         // 检查条件   // 这里条件可能改变！   cond_wait (...);        // 等待 }  // 有锁 - 安全 lock_acquire (&amp;lock); while (!condition) {   cond_wait (&amp;cond, &amp;lock);  // 原子地释放锁并等待 } lock_release (&amp;lock);   Q4: cond_signal 在无人等待时调用会怎样？  答：什么都不会发生。信号会”丢失”。这与信号量不同（信号量会记住）。  Q5: 为什么等待者队列存储 semaphore_elem 而不是直接存储线程？  答：每个等待者有自己的信号量，可以：    精确地唤醒特定等待者   避免虚假唤醒问题   简化实现     调试技巧  打印等待队列  void debug_print_condition (struct condition *cond) {   struct list_elem *e;   printf (\"Condition waiters: \");   for (e = list_begin (&amp;cond-&gt;waiters);         e != list_end (&amp;cond-&gt;waiters);        e = list_next (e))     {       struct semaphore_elem *se = list_entry (e, struct semaphore_elem, elem);       // 需要额外信息来识别等待者       printf (\"(sema) \");     }   printf (\"\\n\"); }   检测死锁模式  void cond_wait (struct condition *cond, struct lock *lock)  {   printf (\"Thread '%s' waiting on condition\\n\", thread_current ()-&gt;name);   // ... 原有代码 ...   printf (\"Thread '%s' woke up from condition\\n\", thread_current ()-&gt;name);   lock_acquire (lock); }     练习思考          分析题：画出生产者-消费者示例中，一个生产者、两个消费者的执行序列。           设计题：如何实现一个带超时的 cond_wait？           编程题：使用条件变量实现一个读写锁（多个读者或一个写者）。           思考题：为什么 Pintos 选择 Mesa 风格而不是 Hoare 风格？           扩展题：研究 pthread_cond_t 的实现，与 Pintos 对比。        下一步  理解了条件变量后，下一篇文档将介绍中断处理与线程的关系，理解中断如何影响线程调度。"
  },
  
  {
    "title": "Pintos 线程系统详解（八）：锁",
    "url": "/posts/pintos-thread-08-lock/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 同步, 锁, 互斥",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中锁（Lock）的实现。锁是最常用的同步原语，用于实现互斥（Mutual Exclusion），确保同一时刻只有一个线程能访问共享资源。  在 Pintos 中，锁是基于信号量实现的。    原始代码  synch.h 中的定义  /** Lock. */ struct lock    {     struct thread *holder;      /**&lt; Thread holding lock (for debugging). */     struct semaphore semaphore; /**&lt; Binary semaphore controlling access. */   };  void lock_init (struct lock *); void lock_acquire (struct lock *); bool lock_try_acquire (struct lock *); void lock_release (struct lock *); bool lock_held_by_current_thread (const struct lock *);   synch.c 中的实现  /** Initializes LOCK.  A lock can be held by at most a single    thread at any given time.  Our locks are not \"recursive\", that    is, it is an error for the thread currently holding a lock to    try to acquire that lock.     A lock is a specialization of a semaphore with an initial    value of 1.  The difference between a lock and such a    semaphore is twofold.  First, a semaphore can have a value    greater than 1, but a lock can only be owned by a single    thread at a time.  Second, a semaphore does not have an owner,    meaning that one thread can \"down\" the semaphore and then    another one \"up\" it, but with a lock the same thread must both    acquire and release it.  When these restrictions prove    onerous, it's a good sign that a semaphore should be used,    instead of a lock. */ void lock_init (struct lock *lock) {   ASSERT (lock != NULL);    lock-&gt;holder = NULL;   sema_init (&amp;lock-&gt;semaphore, 1); }  /** Acquires LOCK, sleeping until it becomes available if    necessary.  The lock must not already be held by the current    thread.     This function may sleep, so it must not be called within an    interrupt handler.  This function may be called with    interrupts disabled, but interrupts will be turned back on if    we need to sleep. */ void lock_acquire (struct lock *lock) {   ASSERT (lock != NULL);   ASSERT (!intr_context ());   ASSERT (!lock_held_by_current_thread (lock));    sema_down (&amp;lock-&gt;semaphore);   lock-&gt;holder = thread_current (); }  /** Tries to acquires LOCK and returns true if successful or false    on failure.  The lock must not already be held by the current    thread.     This function will not sleep, so it may be called within an    interrupt handler. */ bool lock_try_acquire (struct lock *lock) {   bool success;    ASSERT (lock != NULL);   ASSERT (!lock_held_by_current_thread (lock));    success = sema_try_down (&amp;lock-&gt;semaphore);   if (success)     lock-&gt;holder = thread_current ();   return success; }  /** Releases LOCK, which must be owned by the current thread.     An interrupt handler cannot acquire a lock, so it does not    make sense to try to release a lock within an interrupt    handler. */ void lock_release (struct lock *lock)  {   ASSERT (lock != NULL);   ASSERT (lock_held_by_current_thread (lock));    lock-&gt;holder = NULL;   sema_up (&amp;lock-&gt;semaphore); }  /** Returns true if the current thread holds LOCK, false    otherwise.  (Note that testing whether some other thread holds    a lock would be racy.) */ bool lock_held_by_current_thread (const struct lock *lock)  {   ASSERT (lock != NULL);    return lock-&gt;holder == thread_current (); }     前置知识  1. 锁 vs 信号量                 特性       锁（Lock）       信号量（Semaphore）                       值的范围       0 或 1       任意非负整数                 所有者       有（holder）       无                 释放约束       只有持有者可释放       任何线程可 up                 递归支持       Pintos 不支持       不适用                 主要用途       互斥       资源计数、同步           2. 互斥的概念  临界区（Critical Section）：访问共享资源的代码段。  互斥：确保同一时刻只有一个线程在临界区内。  // 没有互斥 - 危险！ shared_counter++;  // 多线程同时执行会出错  // 有互斥 - 安全 lock_acquire (&amp;counter_lock); shared_counter++;  // 只有一个线程能执行 lock_release (&amp;counter_lock);   3. 为什么锁需要所有者？     调试：可以知道谁持有锁   安全：防止非持有者释放锁   防止递归：检测同一线程重复获取锁     struct lock 详解  struct lock    {     struct thread *holder;      /**&lt; Thread holding lock. */     struct semaphore semaphore; /**&lt; Binary semaphore controlling access. */   };   holder：当前持有锁的线程    NULL 表示锁未被持有   非 NULL 表示被某线程持有   semaphore：底层的二进制信号量    初始值为 1   用于实现互斥   内存布局：  struct lock ┌─────────────────────────────────┐ │   holder (4 bytes)              │  指向持有者线程 ├─────────────────────────────────┤ │   semaphore.value (4 bytes)     │  0 或 1 ├─────────────────────────────────┤ │   semaphore.waiters (list)      │  等待队列 └─────────────────────────────────┘     lock_init() 详解  void lock_init (struct lock *lock) {   ASSERT (lock != NULL);    lock-&gt;holder = NULL;   sema_init (&amp;lock-&gt;semaphore, 1); }   初始化锁：    holder 设为 NULL（无持有者）   信号量初始化为 1（锁可用）     lock_acquire() 详解  void lock_acquire (struct lock *lock) {   ASSERT (lock != NULL);   ASSERT (!intr_context ());              // 不能在中断中获取   ASSERT (!lock_held_by_current_thread (lock));  // 不能重复获取    sema_down (&amp;lock-&gt;semaphore);           // 获取信号量   lock-&gt;holder = thread_current ();       // 设置持有者 }   执行流程  线程 A 调用 lock_acquire(&amp;lock)          │          ▼     检查断言          │          ▼     sema_down(&amp;lock-&gt;semaphore)          │          ├─── semaphore.value &gt; 0 ───► value--，立即返回          │          └─── semaphore.value == 0 ───► 阻塞等待                       │                       ▼               (等待锁被释放)                       │                       ▼               (被唤醒，value--)          │          ◄────────────┘          │          ▼     lock-&gt;holder = thread_current()          │          ▼       返回（已获取锁）   为什么不能重复获取？  ASSERT (!lock_held_by_current_thread (lock));   Pintos 的锁是非递归的。如果允许重复获取：  void func_a (void) {   lock_acquire (&amp;lock);   func_b ();            // 调用 func_b   lock_release (&amp;lock); }  void func_b (void) {   lock_acquire (&amp;lock);  // 死锁！已经持有但 value=0   // ...   lock_release (&amp;lock); }   要解决这个问题需要递归锁，但 Pintos 不支持。    lock_try_acquire() 详解  bool lock_try_acquire (struct lock *lock) {   bool success;    ASSERT (lock != NULL);   ASSERT (!lock_held_by_current_thread (lock));    success = sema_try_down (&amp;lock-&gt;semaphore);   if (success)     lock-&gt;holder = thread_current ();   return success; }   特点：    非阻塞   成功返回 true，失败返回 false   可以在中断处理程序中调用（但通常不建议）   使用场景：  if (lock_try_acquire (&amp;lock)) {   // 获取成功，使用资源   use_resource ();   lock_release (&amp;lock); } else {   // 获取失败，做其他事   handle_contention (); }     lock_release() 详解  void lock_release (struct lock *lock)  {   ASSERT (lock != NULL);   ASSERT (lock_held_by_current_thread (lock));  // 必须是持有者    lock-&gt;holder = NULL;              // 清除持有者   sema_up (&amp;lock-&gt;semaphore);       // 释放信号量 }   执行流程  线程 A 调用 lock_release(&amp;lock)          │          ▼     检查是否是持有者          │          ▼     lock-&gt;holder = NULL          │          ▼     sema_up(&amp;lock-&gt;semaphore)          │          ├─── 有等待者 ───► 唤醒一个等待线程          │          └─── 无等待者 ───► 仅 value++          │          ▼       返回   为什么只有持有者可以释放？  ASSERT (lock_held_by_current_thread (lock));   这确保了锁的语义正确性：    防止意外释放别人的锁   便于调试（快速发现错误）     lock_held_by_current_thread() 详解  bool lock_held_by_current_thread (const struct lock *lock)  {   ASSERT (lock != NULL);    return lock-&gt;holder == thread_current (); }   检查当前线程是否持有锁。  为什么只能检查当前线程？     “Note that testing whether some other thread holds a lock would be racy.”   检查其他线程是否持有锁存在竞态条件：    你检查时，那个线程可能正在释放锁   检查结果可能立即过时   但检查当前线程是安全的：    如果我持有锁，只有我能释放它   如果我不持有锁，我不能改变这个状态（直到我获取它）     锁的状态图                      lock_init()                          │                          ▼               ┌─────────────────────┐               │    holder = NULL    │               │ semaphore.value = 1 │               │    (锁可用)         │               └─────────────────────┘                          │                          │ Thread A: lock_acquire                          ▼               ┌─────────────────────┐               │    holder = A       │               │ semaphore.value = 0 │               │   (锁被 A 持有)     │               └─────────────────────┘                          │           ┌──────────────┴──────────────┐           │                             │           │ Thread B: lock_acquire      │ Thread A: lock_release           ▼                             ▼ ┌─────────────────────┐      ┌─────────────────────┐ │    holder = A       │      │    holder = NULL    │ │ semaphore.value = 0 │      │ semaphore.value = 1 │ │  waiters = [B]      │      │    (锁可用)         │ │   (B 在等待)        │      └─────────────────────┘ └─────────────────────┘           │           │ Thread A: lock_release           ▼ ┌─────────────────────┐ │    holder = B       │  ← B 被唤醒并获取锁 │ semaphore.value = 0 │ │   (锁被 B 持有)     │ └─────────────────────┘     锁的使用模式  1. 保护共享数据  struct shared_data {   struct lock lock;   int value;   // ... 其他字段 ... };  void init_shared_data (struct shared_data *data) {   lock_init (&amp;data-&gt;lock);   data-&gt;value = 0; }  void update_data (struct shared_data *data, int new_value) {   lock_acquire (&amp;data-&gt;lock);   data-&gt;value = new_value;   lock_release (&amp;data-&gt;lock); }  int read_data (struct shared_data *data) {   int value;   lock_acquire (&amp;data-&gt;lock);   value = data-&gt;value;   lock_release (&amp;data-&gt;lock);   return value; }   2. 原子操作  void atomic_increment (int *counter, struct lock *lock) {   lock_acquire (lock);   (*counter)++;   lock_release (lock); }   3. 保护链表操作  struct list shared_list; struct lock list_lock;  void add_to_list (struct list_elem *elem) {   lock_acquire (&amp;list_lock);   list_push_back (&amp;shared_list, elem);   lock_release (&amp;list_lock); }  struct list_elem *remove_from_list (void) {   struct list_elem *e = NULL;   lock_acquire (&amp;list_lock);   if (!list_empty (&amp;shared_list))     e = list_pop_front (&amp;shared_list);   lock_release (&amp;list_lock);   return e; }     锁与信号量的对比实现  用信号量实现互斥  struct semaphore mutex; sema_init (&amp;mutex, 1);  // 临界区 sema_down (&amp;mutex); // ... 访问共享资源 ... sema_up (&amp;mutex);   用锁实现互斥  struct lock lock; lock_init (&amp;lock);  // 临界区 lock_acquire (&amp;lock); // ... 访问共享资源 ... lock_release (&amp;lock);   锁的优势：    有所有者概念，更安全   可以检测错误使用（如非持有者释放）   语义更清晰     死锁  什么是死锁？  多个线程互相等待对方持有的锁，永远无法继续。  // Thread A                    // Thread B lock_acquire (&amp;lock1);         lock_acquire (&amp;lock2); lock_acquire (&amp;lock2);         lock_acquire (&amp;lock1);  // 死锁！ // ...                         // ... lock_release (&amp;lock2);         lock_release (&amp;lock1); lock_release (&amp;lock1);         lock_release (&amp;lock2);   Thread A:                    Thread B: 持有 lock1                   持有 lock2 等待 lock2 ─────────────► 被 B 持有                             等待 lock1 ─────────────► 被 A 持有   避免死锁的方法     锁顺序：总是按相同顺序获取锁     // 总是先获取 lock1，再获取 lock2 lock_acquire (&amp;lock1); lock_acquire (&amp;lock2);           尝试获取：使用 try_acquire，失败时释放已持有的锁     while (true) {   lock_acquire (&amp;lock1);   if (lock_try_acquire (&amp;lock2))     break;   lock_release (&amp;lock1);   thread_yield (); }           超时机制：Pintos 不支持，但其他系统可能有     常见问题  Q1: 为什么 lock_acquire 不能在中断中调用？  答：因为它可能阻塞。中断处理程序必须快速完成，不能等待锁。  Q2: 持有锁的线程退出了会怎样？  答：锁不会自动释放，等待的线程会永远阻塞。这是一个bug，应该确保线程退出前释放所有锁。  Q3: 为什么 Pintos 的锁不是递归的？  答：递归锁更复杂，需要：    记录递归深度   只有深度降为 0 时才真正释放   Pintos 为了简单选择不支持。如果需要递归，应该重构代码避免递归获取。  Q4: lock_try_acquire 什么时候有用？  答：    当不能阻塞时（如中断处理）   当有替代方案时   实现超时机制时   Q5: 为什么先清除 holder 再 sema_up？  lock-&gt;holder = NULL; sema_up (&amp;lock-&gt;semaphore);   答：顺序其实不重要，因为整个过程受禁用中断保护。但先清除 holder 更符合逻辑：”先放弃所有权，再唤醒等待者”。    练习思考          分析题：如果 lock_release 不检查是否是持有者就释放，会有什么问题？           设计题：如何实现一个递归锁（可重入锁）？           调试题：如何检测死锁？           思考题：为什么 lock_held_by_current_thread 只能检查当前线程？           扩展题：研究读写锁（rwlock）的概念，思考如何实现。        下一步  理解了锁后，下一篇文档将介绍条件变量（Condition Variable）的实现，它允许线程等待特定条件成立。"
  },
  
  {
    "title": "Pintos 线程系统详解（七）：信号量",
    "url": "/posts/pintos-thread-07-semaphore/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 同步, 信号量",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中信号量（Semaphore）的实现。信号量是最基础的同步原语之一，可以用来实现：    互斥（Mutual Exclusion）   资源计数   线程间同步   Pintos 中的锁和条件变量都是基于信号量实现的。    原始代码  synch.h 中的定义  /** A counting semaphore. */ struct semaphore    {     unsigned value;             /**&lt; Current value. */     struct list waiters;        /**&lt; List of waiting threads. */   };  void sema_init (struct semaphore *, unsigned value); void sema_down (struct semaphore *); bool sema_try_down (struct semaphore *); void sema_up (struct semaphore *);   synch.c 中的实现  /** Initializes semaphore SEMA to VALUE.  A semaphore is a    nonnegative integer along with two atomic operators for    manipulating it:     - down or \"P\": wait for the value to become positive, then      decrement it.     - up or \"V\": increment the value (and wake up one waiting      thread, if any). */ void sema_init (struct semaphore *sema, unsigned value)  {   ASSERT (sema != NULL);    sema-&gt;value = value;   list_init (&amp;sema-&gt;waiters); }  /** Down or \"P\" operation on a semaphore.  Waits for SEMA's value    to become positive and then atomically decrements it.     This function may sleep, so it must not be called within an    interrupt handler.  This function may be called with    interrupts disabled, but if it sleeps then the next scheduled    thread will probably turn interrupts back on. */ void sema_down (struct semaphore *sema)  {   enum intr_level old_level;    ASSERT (sema != NULL);   ASSERT (!intr_context ());    old_level = intr_disable ();   while (sema-&gt;value == 0)      {       list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);       thread_block ();     }   sema-&gt;value--;   intr_set_level (old_level); }  /** Down or \"P\" operation on a semaphore, but only if the    semaphore is not already 0.  Returns true if the semaphore is    decremented, false otherwise.     This function may be called from an interrupt handler. */ bool sema_try_down (struct semaphore *sema)  {   enum intr_level old_level;   bool success;    ASSERT (sema != NULL);    old_level = intr_disable ();   if (sema-&gt;value &gt; 0)      {       sema-&gt;value--;       success = true;      }   else     success = false;   intr_set_level (old_level);    return success; }  /** Up or \"V\" operation on a semaphore.  Increments SEMA's value    and wakes up one thread of those waiting for SEMA, if any.     This function may be called from an interrupt handler. */ void sema_up (struct semaphore *sema)  {   enum intr_level old_level;    ASSERT (sema != NULL);    old_level = intr_disable ();   if (!list_empty (&amp;sema-&gt;waiters))      thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),                                 struct thread, elem));   sema-&gt;value++;   intr_set_level (old_level); }     前置知识  1. 信号量的概念  信号量是 Dijkstra 在 1965 年提出的同步原语，由两部分组成：    一个整数值   两个原子操作：P（等待/down）和 V（信号/up）   P 操作（荷兰语 Proberen，尝试）： while (value == 0) wait; value--;   V 操作（荷兰语 Verhogen，增加）： value++; if (有线程在等待) 唤醒一个;   2. 信号量的用途  二进制信号量（Binary Semaphore）：value 只为 0 或 1    用于互斥（类似锁）   计数信号量（Counting Semaphore）：value 可以是任意非负整数    用于资源计数（如限制并发数）   用于生产者-消费者问题   3. 为什么叫”信号量”？  可以把它想象成停车场的空位数：    初始值 = 总停车位数   进入（P）：如果有空位，占用一个；否则等待   离开（V）：释放一个空位，可能让等待的车进入     struct semaphore 详解  struct semaphore    {     unsigned value;             /**&lt; Current value. */     struct list waiters;        /**&lt; List of waiting threads. */   };   value：当前值    表示可用资源数   value &gt; 0：有可用资源   value == 0：无可用资源，需要等待   waiters：等待线程队列    当 value == 0 时，等待的线程在此队列中   FIFO 顺序（先等待的先被唤醒）   内存布局：  struct semaphore ┌─────────────────────────┐ │   value (4 bytes)       │ ├─────────────────────────┤ │   waiters.head.prev     │ │   waiters.head.next     │ │   waiters.tail.prev     │ │   waiters.tail.next     │ └─────────────────────────┘     sema_init() 详解  void sema_init (struct semaphore *sema, unsigned value)  {   ASSERT (sema != NULL);    sema-&gt;value = value;   list_init (&amp;sema-&gt;waiters); }   初始化信号量：    设置初始值   初始化等待队列（空链表）   使用示例：  struct semaphore sema; sema_init (&amp;sema, 1);  // 二进制信号量，用于互斥 sema_init (&amp;sema, 5);  // 计数信号量，最多 5 个并发 sema_init (&amp;sema, 0);  // 用于同步，初始无资源     sema_down() 详解  这是等待操作（P 操作）：  void sema_down (struct semaphore *sema)  {   enum intr_level old_level;    ASSERT (sema != NULL);   ASSERT (!intr_context ());  // 不能在中断处理中调用    old_level = intr_disable ();   while (sema-&gt;value == 0)    // 循环等待     {       list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);       thread_block ();        // 阻塞自己     }   sema-&gt;value--;              // 获取资源   intr_set_level (old_level); }   执行流程  线程调用 sema_down(&amp;sema)          │          ▼     禁用中断          │          ▼     value == 0?  ─────► 是 ─────► 加入 waiters          │                           │          │ 否                        │          │                           ▼          │                      thread_block()          │                           │          │                           │ (被其他线程唤醒)          │                           │          │ ◄─────────────────────────┘          │          ▼     value-- (获取资源)          │          ▼     恢复中断          │          ▼       返回   为什么用 while 而不是 if？  考虑多个线程等待的情况：  sema.value = 0 waiters: [A] → [B] → [C]  Thread D 调用 sema_up():     1. 唤醒 A     2. value++ (value = 1)  但如果在 A 被调度前，D 又调用了 sema_down():     value-- (value = 0)  A 被调度后:     如果用 if：直接执行 value--，但 value 已经是 0！     如果用 while：重新检查，发现 value == 0，继续等待     sema_try_down() 详解  这是非阻塞版本的 down 操作：  bool sema_try_down (struct semaphore *sema)  {   enum intr_level old_level;   bool success;    ASSERT (sema != NULL);    old_level = intr_disable ();   if (sema-&gt;value &gt; 0)      {       sema-&gt;value--;       success = true;      }   else     success = false;   intr_set_level (old_level);    return success; }   特点：    不会阻塞   成功返回 true，失败返回 false   可以在中断处理程序中调用   使用场景：    轮询资源是否可用   不希望阻塞的情况   if (sema_try_down (&amp;resource_sema)) {   // 获得资源，使用它   use_resource ();   sema_up (&amp;resource_sema); } else {   // 资源不可用，做其他事   do_something_else (); }     sema_up() 详解  这是信号操作（V 操作）：  void sema_up (struct semaphore *sema)  {   enum intr_level old_level;    ASSERT (sema != NULL);    old_level = intr_disable ();   if (!list_empty (&amp;sema-&gt;waiters))      thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),                                 struct thread, elem));   sema-&gt;value++;   intr_set_level (old_level); }   执行流程  线程调用 sema_up(&amp;sema)          │          ▼     禁用中断          │          ▼     waiters 空?  ────► 否 ────► 取出队首线程          │                        │          │ 是                     │          │                        ▼          │                   thread_unblock()          │                        │          │ ◄──────────────────────┘          │          ▼       value++          │          ▼     恢复中断          │          ▼       返回   先唤醒还是先递增？  当前实现：先唤醒，后递增。  这没有本质区别，因为：    整个操作在中断禁用下是原子的   被唤醒的线程不会立即运行（只是变为 READY）     信号量的使用模式  1. 互斥锁（Mutex）  struct semaphore mutex; sema_init (&amp;mutex, 1);  // 初始值为 1  // 临界区 sema_down (&amp;mutex); // ... 访问共享资源 ... sema_up (&amp;mutex);   2. 资源计数  #define MAX_CONNECTIONS 10 struct semaphore conn_sema; sema_init (&amp;conn_sema, MAX_CONNECTIONS);  void handle_connection (void) {   sema_down (&amp;conn_sema);  // 获取连接槽   // ... 处理连接 ...   sema_up (&amp;conn_sema);    // 释放连接槽 }   3. 线程同步  struct semaphore sync_sema; sema_init (&amp;sync_sema, 0);  // 初始值为 0  // 线程 A（等待者） void thread_a (void) {   sema_down (&amp;sync_sema);   // 等待线程 B 的信号   printf (\"B has finished!\\n\"); }  // 线程 B（通知者） void thread_b (void) {   do_something ();   sema_up (&amp;sync_sema);     // 通知线程 A }   4. 生产者-消费者  struct semaphore empty_slots;  // 空槽数 struct semaphore filled_slots; // 满槽数 struct semaphore mutex;        // 保护缓冲区  sema_init (&amp;empty_slots, BUFFER_SIZE); sema_init (&amp;filled_slots, 0); sema_init (&amp;mutex, 1);  void producer (void) {   while (true) {     item = produce_item ();     sema_down (&amp;empty_slots);  // 等待空槽     sema_down (&amp;mutex);        // 获取互斥锁     buffer_add (item);     sema_up (&amp;mutex);          // 释放互斥锁     sema_up (&amp;filled_slots);   // 增加满槽数   } }  void consumer (void) {   while (true) {     sema_down (&amp;filled_slots); // 等待满槽     sema_down (&amp;mutex);        // 获取互斥锁     item = buffer_remove ();     sema_up (&amp;mutex);          // 释放互斥锁     sema_up (&amp;empty_slots);    // 增加空槽数     consume_item (item);   } }     信号量状态图                      sema_init(3)                          │                          ▼                    ┌───────────┐                    │ value = 3 │                    │ waiters=[]│                    └───────────┘                          │         ┌────────────────┼────────────────┐         │ sema_down      │ sema_down      │ sema_down         ▼                ▼                ▼    ┌───────────┐   ┌───────────┐   ┌───────────┐    │ value = 2 │   │ value = 1 │   │ value = 0 │    │ waiters=[]│   │ waiters=[]│   │ waiters=[]│    └───────────┘   └───────────┘   └───────────┘                                         │                                         │ sema_down (Thread A)                                         ▼                                    ┌───────────┐                                    │ value = 0 │                                    │waiters=[A]│                                    └───────────┘                                         │                                         │ sema_up                                         ▼                                    ┌───────────┐                                    │ value = 1 │                                    │ waiters=[]│  A 被唤醒                                    └───────────┘     sema_self_test() 自测试  /** Self-test for semaphores that makes control \"ping-pong\"    between a pair of threads. */ void sema_self_test (void)  {   struct semaphore sema[2];   int i;    printf (\"Testing semaphores...\");   sema_init (&amp;sema[0], 0);   sema_init (&amp;sema[1], 0);   thread_create (\"sema-test\", PRI_DEFAULT, sema_test_helper, &amp;sema);   for (i = 0; i &lt; 10; i++)      {       sema_up (&amp;sema[0]);    // 通知 helper       sema_down (&amp;sema[1]);  // 等待 helper     }   printf (\"done.\\n\"); }  static void sema_test_helper (void *sema_)  {   struct semaphore *sema = sema_;   int i;    for (i = 0; i &lt; 10; i++)      {       sema_down (&amp;sema[0]);  // 等待主线程       sema_up (&amp;sema[1]);    // 通知主线程     } }   这个测试展示了信号量用于线程同步的”乒乓”模式。    常见问题  Q1: 为什么信号量不能有负值？  答：Pintos 使用 unsigned 存储 value，不能为负。概念上，负值表示等待的线程数，但 Pintos 用 waiters 队列的长度来表示。  Q2: sema_down 和 sema_up 必须成对出现吗？  答：不一定。取决于用途：    用于互斥时，应该成对   用于同步时，可能由不同线程调用   用于资源计数时，取决于资源的生命周期   Q3: 信号量可以在中断处理程序中使用吗？  答：    sema_up()：可以   sema_try_down()：可以   sema_down()：不可以（会阻塞）   Q4: 唤醒的线程会立即运行吗？  答：不会。thread_unblock() 只是把线程加入 ready_list。被唤醒的线程会在将来某时刻被调度运行。  Q5: 为什么信号量的 value 使用 unsigned？  答：概念上信号量值不应该为负。使用 unsigned 可以在编译时捕获一些错误，并明确表示设计意图。    练习思考          分析题：如果把 sema_down 中的 while 改成 if，给出一个会出错的场景。           设计题：如何实现一个”公平”的信号量，保证等待最久的线程先被唤醒？           编程题：用信号量实现一个有界缓冲区（bounded buffer）。           思考题：信号量和条件变量的本质区别是什么？           扩展题：研究”信号量的优先级反转问题”，并思考如何解决。        下一步  理解了信号量后，下一篇文档将介绍锁（Lock）的实现，它是信号量的一个重要应用。"
  },
  
  {
    "title": "Pintos 线程系统详解（六）：阻塞与唤醒",
    "url": "/posts/pintos-thread-06-block-unblock/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 同步",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中线程的阻塞与唤醒机制。当线程需要等待某个事件时，它会阻塞自己；当事件发生时，另一个线程会唤醒它。这是实现同步原语的基础。    原始代码  thread_block() 函数  /** Puts the current thread to sleep.  It will not be scheduled    again until awoken by thread_unblock().     This function must be called with interrupts turned off.  It    is usually a better idea to use one of the synchronization    primitives in synch.h. */ void thread_block (void)  {   ASSERT (!intr_context ());   ASSERT (intr_get_level () == INTR_OFF);    thread_current ()-&gt;status = THREAD_BLOCKED;   schedule (); }   thread_unblock() 函数  /** Transitions a blocked thread T to the ready-to-run state.    This is an error if T is not blocked.  (Use thread_yield() to    make the running thread ready.)     This function does not preempt the running thread.  This can    be important: if the caller had disabled interrupts itself,    it may expect that it can atomically unblock a thread and    update other data. */ void thread_unblock (struct thread *t)  {   enum intr_level old_level;    ASSERT (is_thread (t));    old_level = intr_disable ();   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_push_back (&amp;ready_list, &amp;t-&gt;elem);   t-&gt;status = THREAD_READY;   intr_set_level (old_level); }     前置知识  1. 为什么需要阻塞？  线程有时需要等待某些条件才能继续：    等待 I/O 完成   等待其他线程释放资源   等待定时器到期   等待用户输入   如果不阻塞，就需要”忙等待”（busy waiting），浪费 CPU 资源。  2. 阻塞 vs 忙等待  忙等待（Busy Waiting）: while (!condition) {   // 空循环，浪费 CPU }  阻塞等待（Blocking Wait）: while (!condition) {   将自己加入等待队列;   thread_block ();  // 不占用 CPU }   3. 阻塞的语义  当线程阻塞时：    它不再被调度运行   CPU 可以运行其他线程   直到被显式唤醒才能再次运行     thread_block() 详解  函数签名和断言  void thread_block (void)  {   ASSERT (!intr_context ());           // 不能在中断处理中调用   ASSERT (intr_get_level () == INTR_OFF);  // 中断必须已禁用   为什么不能在中断上下文中阻塞？  中断处理程序必须快速完成：    中断处理不应该被调度   阻塞会导致中断无法完成   可能导致系统死锁   为什么中断必须已禁用？  调用者需要在阻塞前完成原子操作：  // 典型使用模式 old_level = intr_disable ();  // 禁用中断 while (!condition) {   list_push_back (&amp;wait_list, &amp;cur-&gt;elem);  // 原子操作 1   thread_block ();                           // 原子操作 2 } intr_set_level (old_level);   如果 thread_block() 自己禁用中断，就无法保证”检查条件”和”阻塞”是原子的。  设置状态并调度    thread_current ()-&gt;status = THREAD_BLOCKED;   schedule (); }   关键点：    先设置状态为 BLOCKED   然后调度其他线程运行   不将自己加入任何队列（调用者的责任）   为什么 thread_block() 不把线程加入等待队列？  因为不同的等待有不同的队列：    信号量有自己的 waiters 队列   条件变量有自己的 waiters 队列   其他等待可能有其他队列   所以调用者负责把线程加入适当的队列。    thread_unblock() 详解  函数签名和断言  void thread_unblock (struct thread *t)  {   enum intr_level old_level;    ASSERT (is_thread (t));  // 必须是有效线程   禁用中断并检查状态    old_level = intr_disable ();   ASSERT (t-&gt;status == THREAD_BLOCKED);  // 必须是阻塞状态   加入就绪队列    list_push_back (&amp;ready_list, &amp;t-&gt;elem);   t-&gt;status = THREAD_READY;   关键点：    将线程加入 ready_list   修改状态为 READY   不立即调度（不会抢占当前线程）   恢复中断    intr_set_level (old_level); }   为什么不立即调度？  为了给调用者更多控制：    调用者可能还需要做其他操作   调用者可能不希望被抢占   保持原子性   如果需要立即调度，调用者可以调用 thread_yield()。    使用模式  等待事件的模式  void wait_for_something (void) {   enum intr_level old_level = intr_disable ();      while (!something_happened) {     // 1. 把自己加入等待队列     list_push_back (&amp;wait_queue, &amp;thread_current ()-&gt;elem);     // 2. 阻塞     thread_block ();     // 3. 被唤醒后，重新检查条件   }      intr_set_level (old_level); }   通知事件的模式  void notify_something (void) {   enum intr_level old_level = intr_disable ();      // 设置事件标志   something_happened = true;      // 唤醒等待的线程   if (!list_empty (&amp;wait_queue)) {     struct thread *t = list_entry (list_pop_front (&amp;wait_queue),                                     struct thread, elem);     thread_unblock (t);   }      intr_set_level (old_level); }   为什么用 while 而不是 if？  可能存在虚假唤醒（spurious wakeup）：    多个线程等待同一事件   只有一个能获得资源   其他线程需要继续等待   // 错误的用法 if (!condition) {   thread_block (); } // 唤醒后直接执行，但条件可能仍不满足！  // 正确的用法 while (!condition) {   thread_block (); } // 唤醒后重新检查条件     阻塞唤醒流程图  单个线程等待  Thread A (等待者)                    Thread B (通知者)      │                                    │      │ intr_disable()                     │      │     │                              │      │     ▼                              │      │ while (!event) {                   │      │     │                              │      │     ├─► 加入 wait_queue            │      │     │                              │      │     ├─► thread_block()             │      │     │        │                     │      │     │        ├─► status = BLOCKED  │      │     │        │                     │      │     │        ├─► schedule()        │      │     │        │                     │      │              ═══════════════════════════  ← A 被换出      │                                    │      │                               一些处理...      │                                    │      │                               event = true      │                                    │      │                               从 wait_queue 取出 A      │                                    │      │                               thread_unblock(A)      │                                    │    │      │                                    │    ├─► 加入 ready_list      │                                    │    │      │                                    │    ├─► A.status = READY      │                                    │      │                               ... 继续运行 ...      │                                    │      │                               最终某时刻 schedule()      │              ═══════════════════════════  ← A 被换回      │     │        │                     │      │     │◄───────┘                     │      │     │                              │      │     └─► 重新检查 while (!event)    │      │                                    │      │ event 为 true，退出循环            │      │     │                              │      │     ▼                              │      │ intr_set_level()                   │      ▼                                    │    继续执行                               │   多个线程等待  wait_queue: [A] → [B] → [C]  Thread D 调用 notify():     1. event = true     2. 从队首取出 A     3. thread_unblock(A)  wait_queue: [B] → [C] ready_list: [...] → [A]  A 被调度后:     - 检查条件，条件满足     - 继续执行，不再加入 wait_queue  B 和 C 仍在 wait_queue 中等待     与 thread_yield() 的区别                 特性       thread_block()       thread_yield()                       目标状态       BLOCKED       READY                 加入队列       无（调用者负责）       ready_list                 何时返回       被 unblock 后       被再次调度后                 典型用途       等待事件       让出 CPU                 可能立即返回       否       是（如果无其他就绪线程）           // thread_yield: \"我不需要 CPU 了，让别人用\" void thread_yield (void) {   cur-&gt;status = THREAD_READY;   list_push_back (&amp;ready_list, &amp;cur-&gt;elem);   schedule (); }  // thread_block: \"我在等某事，别调度我\" void thread_block (void) {   cur-&gt;status = THREAD_BLOCKED;   schedule ();   // 不加入任何队列！ }     中断与阻塞的关系  为什么阻塞操作需要禁用中断？  考虑以下场景：  // 线程 A void wait_for_data (void) {   if (data_ready == false) {           // 检查     // *** 如果这里发生中断 ***     // 中断处理程序设置 data_ready = true     // 并试图唤醒等待者（但还没有等待者！）     list_push_back (&amp;wait_list, &amp;cur-&gt;elem);     thread_block ();                    // 永远不会被唤醒！   } }   禁用中断可以避免这种竞态条件：  void wait_for_data (void) {   old_level = intr_disable ();          // 禁用中断   if (data_ready == false) {     list_push_back (&amp;wait_list, &amp;cur-&gt;elem);     thread_block ();   }   intr_set_level (old_level); }   阻塞后中断会恢复吗？  是的！schedule() 切换到其他线程后，新线程会恢复中断：  void thread_yield (void) {   old_level = intr_disable ();   // ...   schedule ();   intr_set_level (old_level);  // 新线程的代码会执行到这里 }   或者对于新线程：  static void kernel_thread (thread_func *function, void *aux)  {   intr_enable ();  // 新线程第一件事就是开启中断   function (aux);   thread_exit (); }     常见问题  Q1: 为什么 thread_block() 不自己禁用中断？  答：因为调用者通常需要在禁用中断的情况下做其他操作（如检查条件、加入等待队列），然后才阻塞。如果 thread_block() 自己禁用中断，就无法保证这些操作是原子的。  Q2: 阻塞的线程存储在哪里？  答：由调用者决定。常见的有：    信号量的 waiters 队列   条件变量的 waiters 队列   定时器的睡眠队列   自定义的等待队列   Q3: thread_unblock() 能唤醒 READY 状态的线程吗？  答：不能，会触发断言失败：  ASSERT (t-&gt;status == THREAD_BLOCKED);   Q4: 如果没有其他线程可运行，阻塞会怎样？  答：idle_thread 会运行。它执行 hlt 指令等待中断，然后再次阻塞自己。  Q5: thread_unblock() 能在中断处理程序中调用吗？  答：可以。thread_unblock() 只是把线程加入 ready_list，不涉及调度。    调试技巧  打印阻塞/唤醒信息  void thread_block (void)  {   printf (\"Thread '%s' blocking\\n\", thread_current ()-&gt;name);   thread_current ()-&gt;status = THREAD_BLOCKED;   schedule ();   printf (\"Thread '%s' resumed\\n\", thread_current ()-&gt;name); }  void thread_unblock (struct thread *t)  {   printf (\"Unblocking thread '%s'\\n\", t-&gt;name);   // ... }   检查等待队列  void debug_print_waiters (struct list *waiters) {   struct list_elem *e;   printf (\"Waiters: \");   for (e = list_begin (waiters); e != list_end (waiters);        e = list_next (e))     {       struct thread *t = list_entry (e, struct thread, elem);       printf (\"%s \", t-&gt;name);     }   printf (\"\\n\"); }     练习思考          分析题：如果 thread_block() 忘记设置 status = BLOCKED 会怎样？           设计题：如何实现一个带超时的等待？（提示：结合定时器）           调试题：如果一个线程永远阻塞，如何诊断问题？           思考题：为什么 thread_unblock() 使用 list_push_back 而不是 list_push_front？           扩展题：如何实现优先级继承（priority inheritance）来避免优先级反转？        下一步  理解了阻塞与唤醒机制后，下一篇文档将介绍信号量（Semaphore）的实现，它是最基本的同步原语。"
  },
  
  {
    "title": "Pintos 线程系统详解（五）：上下文切换",
    "url": "/posts/pintos-thread-05-switch/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 汇编, 上下文切换",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中线程上下文切换的核心实现——switch.S。上下文切换是操作系统最底层的机制之一，它允许 CPU 从一个线程切换到另一个线程，保存和恢复执行状态。    原始代码  switch.S  #include \"threads/switch.h\"  #### struct thread *switch_threads (struct thread *cur, struct thread *next); #### #### Switches from CUR, which must be the running thread, to NEXT, #### which must also be running switch_threads(), returning CUR in #### NEXT's context. #### #### This function works by assuming that the thread we're switching #### into is also running switch_threads().  Thus, all it has to do is #### preserve a few registers on the stack, then switch stacks and #### restore the registers.  As part of switching stacks we record the #### current stack pointer in CUR's thread structure.  .globl switch_threads .func switch_threads switch_threads: \t# Save caller's register state. \t# \t# Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx, \t# but requires us to preserve %ebx, %ebp, %esi, %edi.  See \t# [SysV-ABI-386] pages 3-11 and 3-12 for details. \t# \t# This stack frame must match the one set up by thread_create() \t# in size. \tpushl %ebx \tpushl %ebp \tpushl %esi \tpushl %edi  \t# Get offsetof (struct thread, stack). .globl thread_stack_ofs \tmov thread_stack_ofs, %edx  \t# Save current stack pointer to old thread's stack, if any. \tmovl SWITCH_CUR(%esp), %eax \tmovl %esp, (%eax,%edx,1)  \t# Restore stack pointer from new thread's stack. \tmovl SWITCH_NEXT(%esp), %ecx \tmovl (%ecx,%edx,1), %esp  \t# Restore caller's register state. \tpopl %edi \tpopl %esi \tpopl %ebp \tpopl %ebx         ret .endfunc  .globl switch_entry .func switch_entry switch_entry: \t# Discard switch_threads() arguments. \taddl $8, %esp  \t# Call thread_schedule_tail(prev). \tpushl %eax .globl thread_schedule_tail \tcall thread_schedule_tail \taddl $4, %esp  \t# Start thread proper. \tret .endfunc   switch.h  #ifndef THREADS_SWITCH_H #define THREADS_SWITCH_H  #ifndef __ASSEMBLER__ /** switch_thread()'s stack frame. */ struct switch_threads_frame    {     uint32_t edi;               /**&lt;  0: Saved %edi. */     uint32_t esi;               /**&lt;  4: Saved %esi. */     uint32_t ebp;               /**&lt;  8: Saved %ebp. */     uint32_t ebx;               /**&lt; 12: Saved %ebx. */     void (*eip) (void);         /**&lt; 16: Return address. */     struct thread *cur;         /**&lt; 20: switch_threads()'s CUR argument. */     struct thread *next;        /**&lt; 24: switch_threads()'s NEXT argument. */   };  /** Stack frame for switch_entry(). */ struct switch_entry_frame   {     void (*eip) (void);   };  /** Switches from CUR, which must be the running thread, to NEXT,    which must also be running switch_threads(), returning CUR in    NEXT's context. */ struct thread *switch_threads (struct thread *cur, struct thread *next);  void switch_entry (void); #endif  /** Offsets used by switch.S. */ #define SWITCH_CUR      20 #define SWITCH_NEXT     24  #endif /**&lt; threads/switch.h */     前置知识  1. 什么是上下文（Context）？  线程的上下文是线程执行状态的完整描述，包括：    寄存器：EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP   栈：栈上的所有数据   其他：标志寄存器等   切换线程就是切换这些状态。  2. x86 寄存器  通用寄存器: ┌────────────────────────────────────────────────────────┐ │  EAX  │ 累加器，函数返回值                             │ │  EBX  │ 基址寄存器，callee-saved                       │ │  ECX  │ 计数器，caller-saved                           │ │  EDX  │ 数据寄存器，caller-saved                       │ │  ESI  │ 源索引，callee-saved                           │ │  EDI  │ 目的索引，callee-saved                         │ │  EBP  │ 栈帧基址指针，callee-saved                     │ │  ESP  │ 栈指针                                         │ │  EIP  │ 指令指针（程序计数器）                         │ └────────────────────────────────────────────────────────┘   3. 调用约定（Calling Convention）  SVR4 ABI (System V Application Binary Interface)：                 寄存器       保存责任       说明                       EAX, ECX, EDX       Caller-saved       调用者保存，被调用者可随意使用                 EBX, EBP, ESI, EDI       Callee-saved       被调用者保存，必须保持不变           函数调用过程：  调用前: 1. 参数从右向左压栈 2. call 指令压入返回地址 3. 跳转到函数  调用中: 4. 被调用函数保存 callee-saved 寄存器 5. 执行函数体 6. 恢复 callee-saved 寄存器  返回: 7. ret 指令弹出返回地址并跳转 8. 调用者清理参数   4. 栈帧布局  高地址 ┌─────────────────────┐ │     参数 2 (next)   │  ESP+24 (调用后) ├─────────────────────┤ │     参数 1 (cur)    │  ESP+20 (调用后) ├─────────────────────┤ │     返回地址        │  ESP+16 (call 指令压入) ├─────────────────────┤ │     保存的 EBX      │  ESP+12 (push 指令) ├─────────────────────┤ │     保存的 EBP      │  ESP+8 ├─────────────────────┤ │     保存的 ESI      │  ESP+4 ├─────────────────────┤ │     保存的 EDI      │  ESP+0  ← 当前 ESP └─────────────────────┘ 低地址     switch_threads() 逐行详解  函数签名  struct thread *switch_threads (struct thread *cur, struct thread *next);      参数：cur（当前线程），next（下一线程）   返回值：切换前的线程（即 cur），但返回给 next 线程   保存 callee-saved 寄存器  switch_threads: \tpushl %ebx \tpushl %ebp \tpushl %esi \tpushl %edi   这四条指令保存必须保留的寄存器到栈上：  执行前:                          执行后: ┌─────────────────┐              ┌─────────────────┐ │      next       │              │      next       │ ├─────────────────┤              ├─────────────────┤ │      cur        │              │      cur        │ ├─────────────────┤              ├─────────────────┤ │   返回地址      │ ← ESP        │   返回地址      │ └─────────────────┘              ├─────────────────┤                                  │      ebx        │                                  ├─────────────────┤                                  │      ebp        │                                  ├─────────────────┤                                  │      esi        │                                  ├─────────────────┤                                  │      edi        │ ← ESP                                  └─────────────────┘   获取 stack 字段偏移量  .globl thread_stack_ofs \tmov thread_stack_ofs, %edx   thread_stack_ofs 是在 thread.c 中定义的：  uint32_t thread_stack_ofs = offsetof (struct thread, stack);   这告诉汇编代码 stack 字段在 struct thread 中的偏移量。  保存当前栈指针  \tmovl SWITCH_CUR(%esp), %eax    # eax = cur \tmovl %esp, (%eax,%edx,1)       # cur-&gt;stack = esp   步骤分解：     SWITCH_CUR(%esp) = 20(%esp) = cur 参数的地址   movl SWITCH_CUR(%esp), %eax 将 cur 指针加载到 EAX   (%eax,%edx,1) = eax + edx*1 = cur + stack_offset = &amp;(cur-&gt;stack)   movl %esp, (%eax,%edx,1) 将当前 ESP 保存到 cur-&gt;stack   结果：cur 线程的栈指针被保存。  恢复新线程的栈指针  \tmovl SWITCH_NEXT(%esp), %ecx   # ecx = next \tmovl (%ecx,%edx,1), %esp       # esp = next-&gt;stack   步骤分解：     SWITCH_NEXT(%esp) = 24(%esp) = next 参数的地址   movl SWITCH_NEXT(%esp), %ecx 将 next 指针加载到 ECX   (%ecx,%edx,1) = &amp;(next-&gt;stack)   movl (%ecx,%edx,1), %esp 从 next-&gt;stack 恢复 ESP   关键点：执行完这条指令后，我们已经切换到了新线程的栈！  恢复新线程的寄存器  \tpopl %edi \tpopl %esi \tpopl %ebp \tpopl %ebx     ret   从新线程的栈上恢复寄存器，然后 ret 返回到新线程的返回地址。    上下文切换图解  切换前后的栈状态  Thread A 的栈 (切换前正在运行)        Thread B 的栈 (之前被切换出) ┌─────────────────┐                  ┌─────────────────┐ │      next       │                  │      next       │ ├─────────────────┤                  ├─────────────────┤ │      cur        │                  │      cur        │ ├─────────────────┤                  ├─────────────────┤ │  返回到 schedule│                  │  返回到 schedule│ ├─────────────────┤                  ├─────────────────┤ │      ebx        │                  │      ebx        │ ├─────────────────┤                  ├─────────────────┤ │      ebp        │                  │      ebp        │ ├─────────────────┤                  ├─────────────────┤ │      esi        │                  │      esi        │ ├─────────────────┤                  ├─────────────────┤ │      edi        │ ← ESP(A)         │      edi        │ ← ESP(B) └─────────────────┘                  └─────────────────┘         │                                    │         │                                    │ A-&gt;stack ───────┘                  B-&gt;stack ─┘                       执行 switch_threads(A, B)   Thread A 的栈 (已保存状态)           Thread B 的栈 (正在恢复) ┌─────────────────┐                  ┌─────────────────┐ │      next       │                  │      next       │ ├─────────────────┤                  ├─────────────────┤ │      cur        │                  │      cur        │ ├─────────────────┤                  ├─────────────────┤ │  返回到 schedule│                  │  返回到 schedule│ ├─────────────────┤                  ├─────────────────┤ │      ebx        │                  │      ebx        │ ├─────────────────┤                  ├─────────────────┤ │      ebp        │                  │      ebp        │ ├─────────────────┤                  ├─────────────────┤ │      esi        │                  │      esi        │ ├─────────────────┤                  ├─────────────────┤ │      edi        │                  │      edi        │ ← ESP (已切换!) └─────────────────┘                  └─────────────────┘         │                             A-&gt;stack ─┘ (已保存)                   切换的关键时刻  时间 ──────────────────────────────────────────────────────────────►  Thread A 执行                 Thread B 执行      │                             │      │ call switch_threads         │      ▼                             │   压入返回地址                     │      │                             │      ▼                             │   pushl %ebx/ebp/esi/edi          │      │                             │      ▼                             │   A-&gt;stack = esp                   │      │                             │      ▼                             │   esp = B-&gt;stack                   │      │                             │   ═══════════════════════════════════  ← 栈切换点！      │                             │                                    ▼                            popl %edi/esi/ebp/ebx                                    │                                    ▼                                   ret                                    │                                    ▼                            返回到 schedule()     switch_entry() 详解  这是新线程第一次运行时的入口点：  .globl switch_entry .func switch_entry switch_entry: \t# Discard switch_threads() arguments. \taddl $8, %esp  \t# Call thread_schedule_tail(prev). \tpushl %eax .globl thread_schedule_tail \tcall thread_schedule_tail \taddl $4, %esp  \t# Start thread proper. \tret .endfunc   为什么需要 switch_entry？  新线程第一次被调度时：    它从未调用过 switch_threads()   但它的栈被设置成好像调用过一样   switch_entry 处理这种特殊情况   逐行解析  丢弃参数：  addl $8, %esp   栈上有两个假的参数（cur 和 next），需要丢弃。  调用 thread_schedule_tail：  pushl %eax                    # 压入参数 (prev = eax) call thread_schedule_tail     # 调用收尾函数 addl $4, %esp                 # 清理参数   EAX 包含 prev（切换前的线程），是 switch_threads 的返回值。  开始执行线程：  ret   返回到栈上的下一个返回地址，即 kernel_thread()。  新线程的栈帧回顾  高地址 ┌─────────────────────────────────────────────┐ │               aux                           │ ← kernel_thread_frame │             function                        │ │           eip (NULL)                        │ ├─────────────────────────────────────────────┤ │         eip (kernel_thread)                 │ ← switch_entry_frame ├─────────────────────────────────────────────┤ │    next  (未使用)                           │ │    cur   (未使用)                           │ │    eip   (switch_entry)                     │ ← switch_threads_frame │    ebx   (0)                                │ │    ebp   (0)                                │ │    esi   (0)                                │ │    edi   (0)                                │ ← t-&gt;stack └─────────────────────────────────────────────┘ 低地址   新线程首次执行流程  switch_threads() 切换到新线程         │         ▼     popl %edi, %esi, %ebp, %ebx (值都是 0)         │         ▼     ret (返回到 switch_entry)         │         ▼ switch_entry:         │     addl $8, %esp (丢弃 cur, next)         │         ▼     pushl %eax; call thread_schedule_tail         │         ▼     ret (返回到 kernel_thread)         │         ▼ kernel_thread:         │     intr_enable ()         │     function (aux)  ← 执行用户指定的函数！         │     thread_exit ()     为什么这样设计？  1. 统一的切换模型  所有线程（无论是第一次运行还是恢复执行）都通过 switch_threads() 切换。这种统一性简化了代码。  2. 最小化保存的状态  只保存 callee-saved 寄存器（EBX, EBP, ESI, EDI）和栈指针。其他寄存器由调用约定保证。  3. 栈就是上下文  线程的执行状态主要保存在栈上。切换栈指针就是切换上下文。    关键数据结构  thread_stack_ofs  /* thread.c */ uint32_t thread_stack_ofs = offsetof (struct thread, stack);   这是 stack 字段在 struct thread 中的偏移量。汇编代码需要知道这个值来访问 t-&gt;stack。  SWITCH_CUR 和 SWITCH_NEXT  /* switch.h */ #define SWITCH_CUR      20 #define SWITCH_NEXT     24   这些是参数在栈上的偏移量（相对于执行完 4 个 push 后的 ESP）。  ESP+24: next ESP+20: cur ESP+16: 返回地址 ESP+12: ebx ESP+8:  ebp ESP+4:  esi ESP+0:  edi  ← ESP     常见问题  Q1: 为什么不保存所有寄存器？  答：根据调用约定，caller-saved 寄存器（EAX, ECX, EDX）由调用者保存。调用 switch_threads() 的函数会处理这些寄存器。  Q2: EIP 在哪里保存？  答：call 指令自动将返回地址（下一条指令的 EIP）压入栈。ret 指令从栈弹出并跳转。  Q3: 为什么切换栈就能切换上下文？  答：因为：    寄存器状态保存在栈上   返回地址在栈上   局部变量在栈上   切换栈指针后，popl 和 ret 会自动恢复正确的状态。  Q4: switch_threads 的返回值是什么？  答：返回切换前的线程（cur）。但这个返回值是给切换后的线程看的。  prev = switch_threads (cur, next); // 这行代码执行后，\"当前线程\"已经变成了 next // prev 是 next 看到的\"之前的线程\"   Q5: 新线程为什么需要特殊处理？  答：新线程从未调用过 switch_threads()，但我们把它的栈设置成好像调用过一样。switch_entry 处理这种”假装”的情况，确保新线程能正确启动。    调试技巧  在 GDB 中观察切换  # 在 switch_threads 设置断点 b switch_threads  # 显示寄存器 info registers  # 显示栈内容 x/10x $esp  # 单步执行 si  # 观察 ESP 的变化 p/x $esp   添加调试输出  由于 switch_threads 中不能调用 printf（栈正在切换），可以在其前后添加：  static void schedule (void)  {   printf (\"Before switch: cur=%s, next=%s\\n\",            cur-&gt;name, next-&gt;name);      if (cur != next)     prev = switch_threads (cur, next);      // 此时已经是新线程了   printf (\"After switch: now=%s, prev=%s\\n\",           running_thread()-&gt;name,            prev ? prev-&gt;name : \"NULL\");      thread_schedule_tail (prev); }     练习思考          分析题：如果忘记 pushl %ebx，会发生什么？           计算题：switch_threads_frame 占用多少字节？验证 SWITCH_CUR 和 SWITCH_NEXT 的值是否正确。           设计题：如果要支持浮点运算，需要保存哪些额外的寄存器？           调试题：如何验证上下文切换正在正确工作？           扩展题：研究 Linux 的 context_switch 实现，与 Pintos 对比有什么不同？        下一步  理解了上下文切换后，下一篇文档将介绍线程的阻塞与唤醒机制（thread_block() 和 thread_unblock()）。"
  },
  
  {
    "title": "Pintos 线程系统详解（四）：线程调度",
    "url": "/posts/pintos-thread-04-schedule/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 调度",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中的线程调度机制。调度器（scheduler）是操作系统的核心组件，负责决定哪个线程获得 CPU 时间。Pintos 默认使用轮转调度（Round-Robin）算法。    原始代码  schedule() 函数  /** Schedules a new process.  At entry, interrupts must be off and    the running process's state must have been changed from    running to some other state.  This function finds another    thread to run and switches to it.     It's not safe to call printf() until thread_schedule_tail()    has completed. */ static void schedule (void)  {   struct thread *cur = running_thread ();   struct thread *next = next_thread_to_run ();   struct thread *prev = NULL;    ASSERT (intr_get_level () == INTR_OFF);   ASSERT (cur-&gt;status != THREAD_RUNNING);   ASSERT (is_thread (next));    if (cur != next)     prev = switch_threads (cur, next);   thread_schedule_tail (prev); }   next_thread_to_run() 函数  /** Chooses and returns the next thread to be scheduled.  Should    return a thread from the run queue, unless the run queue is    empty.  (If the running thread can continue running, then it    will be in the run queue.)  If the run queue is empty, return    idle_thread. */ static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }   thread_schedule_tail() 函数  /** Completes a thread switch by activating the new thread's page    tables, and, if the previous thread is dying, destroying it.     At this function's invocation, we just switched from thread    PREV, the new thread is already running, and interrupts are    still disabled.  This function is normally invoked by    thread_schedule() as its final action before returning, but    the first time a thread is scheduled it is called by    switch_entry() (see switch.S).     It's not safe to call printf() until the thread switch is    complete.  In practice that means that printf()s should be    added at the end of the function.     After this function and its caller returns, the thread switch    is complete. */ void thread_schedule_tail (struct thread *prev) {   struct thread *cur = running_thread ();      ASSERT (intr_get_level () == INTR_OFF);    /* Mark us as running. */   cur-&gt;status = THREAD_RUNNING;    /* Start new time slice. */   thread_ticks = 0;  #ifdef USERPROG   /* Activate the new address space. */   process_activate (); #endif    /* If the thread we switched from is dying, destroy its struct      thread.  This must happen late so that thread_exit() doesn't      pull out the rug under itself.  (We don't free      initial_thread because its memory was not obtained via      palloc().) */   if (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread)      {       ASSERT (prev != cur);       palloc_free_page (prev);     } }   thread_yield() 函数  /** Yields the CPU.  The current thread is not put to sleep and    may be scheduled again immediately at the scheduler's whim. */ void thread_yield (void)  {   struct thread *cur = thread_current ();   enum intr_level old_level;      ASSERT (!intr_context ());    old_level = intr_disable ();   if (cur != idle_thread)      list_push_back (&amp;ready_list, &amp;cur-&gt;elem);   cur-&gt;status = THREAD_READY;   schedule ();   intr_set_level (old_level); }   thread_tick() 函数  /** Called by the timer interrupt handler at each timer tick.    Thus, this function runs in an external interrupt context. */ void thread_tick (void)  {   struct thread *t = thread_current ();    /* Update statistics. */   if (t == idle_thread)     idle_ticks++; #ifdef USERPROG   else if (t-&gt;pagedir != NULL)     user_ticks++; #endif   else     kernel_ticks++;    /* Enforce preemption. */   if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return (); }     前置知识  1. 调度的基本概念  调度器的职责：    决定哪个线程运行   决定运行多长时间   实现公平性或其他策略   调度时机：    线程主动让出 CPU（yield）   线程阻塞等待事件（block）   线程时间片耗尽（抢占）   线程退出（exit）   2. 轮转调度（Round-Robin）  最简单的调度算法：    所有就绪线程排成队列   每个线程运行固定时间（时间片）   时间片耗尽后，排到队尾   下一个线程继续运行   就绪队列: [A] → [B] → [C] → (尾部)  时间片 1: A 运行，队列变为 [B] → [C] → [A] 时间片 2: B 运行，队列变为 [C] → [A] → [B] 时间片 3: C 运行，队列变为 [A] → [B] → [C] ... 循环 ...   3. 时间片  #define TIME_SLICE 4  // 4 个 tick   一个 tick 是定时器中断的周期，默认约 10ms。 所以一个时间片约 40ms。    schedule() 函数详解  函数签名和断言  static void schedule (void)  {   struct thread *cur = running_thread ();   struct thread *next = next_thread_to_run ();   struct thread *prev = NULL;    ASSERT (intr_get_level () == INTR_OFF);  // 中断必须禁用   ASSERT (cur-&gt;status != THREAD_RUNNING);   // 当前线程状态已改变   ASSERT (is_thread (next));                // next 是有效线程   为什么中断必须禁用？  调度涉及多个操作，必须原子执行：    修改 ready_list   修改线程状态   切换栈和寄存器   为什么 cur-&gt;status != THREAD_RUNNING？  调用 schedule() 前，当前线程应该已经：    变为 READY（如果是 yield）   变为 BLOCKED（如果是 block）   变为 DYING（如果是 exit）   选择下一个线程    struct thread *next = next_thread_to_run ();   static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;         // 队列空，运行 idle   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }   这就是轮转调度的核心：    从队首取出一个线程   如果队列空，返回 idle_thread   执行上下文切换    if (cur != next)     prev = switch_threads (cur, next);   如果 cur == next：当前线程继续运行（例如只有一个线程时）。  switch_threads()：在 switch.S 中实现，后面详细讲解。  完成切换    thread_schedule_tail (prev); }   切换完成后的收尾工作，包括：    标记新线程为 RUNNING   重置时间片计数   释放 DYING 线程的内存     next_thread_to_run() 详解  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }   list_pop_front() 的作用  从链表头部移除并返回元素：  调用前: ready_list: [A] → [B] → [C]  调用后: ready_list: [B] → [C] 返回值: 指向 A 的 elem 的指针   list_entry() 宏  #define list_entry(LIST_ELEM, STRUCT, MEMBER) \\         ((STRUCT *) ((uint8_t *) (LIST_ELEM) - offsetof (STRUCT, MEMBER)))   从 list_elem 指针获取包含它的结构体指针：  // elem 是 struct thread 中的成员 struct thread *t = list_entry (e, struct thread, elem);   工作原理：  struct thread ┌───────────────────┐ 0 │ tid               │ │ status            │ │ name[16]          │ │ stack             │ │ priority          │ │ allelem           │ ├───────────────────┤ 40  ← elem 的偏移量 (假设) │ elem.prev         │ │ elem.next         │ ├───────────────────┤ │ ...               │ └───────────────────┘  如果知道 elem 的地址是 X， 那么 struct thread 的地址是 X - 40     thread_schedule_tail() 详解  标记运行状态  void thread_schedule_tail (struct thread *prev) {   struct thread *cur = running_thread ();      ASSERT (intr_get_level () == INTR_OFF);    /* Mark us as running. */   cur-&gt;status = THREAD_RUNNING;    /* Start new time slice. */   thread_ticks = 0;   注意：此时 running_thread() 返回的是新线程，因为栈已经切换了。  切换地址空间（用户程序）  #ifdef USERPROG   /* Activate the new address space. */   process_activate (); #endif   对于用户进程，需要切换页表。内核线程不需要。  销毁 DYING 线程    /* If the thread we switched from is dying, destroy its struct thread. */   if (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread)      {       ASSERT (prev != cur);       palloc_free_page (prev);     } }   为什么由下一个线程来释放？  因为 DYING 线程正在使用自己的栈，不能释放自己占用的内存。  为什么不释放 initial_thread？  initial_thread 的内存不是通过 palloc 分配的，而是由 loader.S 设置的。    thread_yield() 详解  void thread_yield (void)  {   struct thread *cur = thread_current ();   enum intr_level old_level;      ASSERT (!intr_context ());  // 不能在中断处理中调用    old_level = intr_disable ();  // 禁用中断      if (cur != idle_thread)      list_push_back (&amp;ready_list, &amp;cur-&gt;elem);  // 加入队尾   cur-&gt;status = THREAD_READY;   schedule ();                  // 调度      intr_set_level (old_level);   // 恢复中断（被调度回来后） }   执行流程  Thread A 调用 thread_yield()         │         ▼     禁用中断         │         ▼     A 加入 ready_list 队尾         │         ▼     A.status = READY         │         ▼     schedule()         │         ├───────────────────────┐         │                       │         ▼                       │     切换到 Thread B             │                                 │     ... B 运行一段时间 ...       │                                 │     某时刻 B yield 或 block      │         │                       │         ▼                       │     切换回 Thread A ◄───────────┘         │         ▼     恢复中断         │         ▼     thread_yield() 返回   为什么 idle_thread 不加入 ready_list？  idle_thread 是特殊的：    当且仅当 ready_list 为空时才运行   永远不应该出现在 ready_list 中   由 next_thread_to_run() 在需要时返回     时间片和抢占  thread_tick() - 定时器中断处理  void thread_tick (void)  {   struct thread *t = thread_current ();    /* Update statistics. */   if (t == idle_thread)     idle_ticks++; #ifdef USERPROG   else if (t-&gt;pagedir != NULL)     user_ticks++; #endif   else     kernel_ticks++;    /* Enforce preemption. */   if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return (); }   抢占机制  #define TIME_SLICE 4  // 时间片 = 4 ticks  static unsigned thread_ticks;  // 当前线程已运行的 ticks   每次定时器中断（每 tick）：    thread_ticks++   如果 thread_ticks &gt;= TIME_SLICE，设置抢占标志   intr_yield_on_return()  void intr_yield_on_return (void)  {   ASSERT (intr_context ());  // 必须在中断上下文中   yield_on_return = true; }   只是设置一个标志，不立即 yield。  中断返回时检查  在 intr_handler() 末尾：  void intr_handler (struct intr_frame *frame)  {   // ... 处理中断 ...    if (external)      {       // ...       if (yield_on_return)          thread_yield ();  // 中断返回前 yield     } }     调度流程图  时间片耗尽的抢占流程  时间 ──────────────────────────────────────────────────────►  Thread A 运行 ┌─────────────────────────────────────────────────────────┐ │ tick 1 │ tick 2 │ tick 3 │ tick 4 │                     │ │        │        │        │   ↓    │                     │ │        │        │        │ 时间片耗尽                   │ │        │        │        │ intr_yield_on_return()      │ │        │        │        │   ↓                          │ │        │        │        │ thread_yield()              │ │        │        │        │   ↓                          │ │        │        │        │ schedule()                  │ └────────┴────────┴────────┴───┬──────────────────────────┘                                │                                ▼ 切换 Thread B 运行 ┌─────────────────────────────────────────────────────────┐ │ tick 1 │ tick 2 │ tick 3 │ tick 4 │                     │ │        │        │        │   ...  │                     │   主动 yield 的流程  Thread A                          Thread B     │                                │     │ thread_yield()                 │     │     │                          │     │     ├── 加入 ready_list        │     │     │                          │     │     ├── status = READY         │     │     │                          │     │     ├── schedule()             │     │     │        │                 │     │     │        ├── next = B      │     │     │        │                 │     │     │        ├── switch ───────┤     │                                │     │                                │ 开始运行     │                                │     │                                │ ... 一段时间后 ...     │                                │     │                                │ schedule() 切回 A     │◄───────────────────────────────┤     │     │                          │     │     └── 恢复中断               │     │                                │     ▼                                │   继续运行                           │     调度的原子性保证  为什么需要禁用中断？  调度涉及的操作必须不可分割：  // 危险的非原子操作示例（如果不禁用中断）： list_push_back (&amp;ready_list, &amp;cur-&gt;elem);  // 步骤 1 // 如果这里发生中断，调度器可能看到不一致的状态！ cur-&gt;status = THREAD_READY;                 // 步骤 2 schedule ();                                // 步骤 3   中断禁用的范围  void thread_yield (void)  {   old_level = intr_disable ();   // ← 禁用   // ---------- 临界区 ----------   if (cur != idle_thread)      list_push_back (&amp;ready_list, &amp;cur-&gt;elem);   cur-&gt;status = THREAD_READY;   schedule ();   // ---------- 临界区 ----------   intr_set_level (old_level);    // ← 恢复 }     调度器的数据结构  /* 就绪队列 - FIFO */ static struct list ready_list;  /* 时间片计数 */ static unsigned thread_ticks;  /* 时间片长度 */ #define TIME_SLICE 4  /* 统计信息 */ static long long idle_ticks; static long long kernel_ticks; static long long user_ticks;   ready_list 结构：  ready_list (双向链表) ┌──────────────────────────────────────────────────────┐ │                                                        │ │  head ◄──► Thread A ◄──► Thread B ◄──► Thread C ◄──► tail │            (elem)        (elem)        (elem)          │ └──────────────────────────────────────────────────────┘     常见问题  Q1: 如果所有线程都阻塞了会怎样？  答：idle_thread 会运行。idle_thread 的工作是：    阻塞自己   执行 hlt 指令等待中断   中断发生后唤醒，然后继续阻塞   static void idle (void *aux UNUSED)  {   for (;;)      {       intr_disable ();       thread_block ();       asm volatile (\"sti; hlt\" : : : \"memory\");     } }   Q2: schedule() 为什么是 static 函数？  答：schedule() 是内部函数，只应该被以下函数调用：    thread_yield()   thread_block()   thread_exit()   不应该直接从外部调用，因为调用前需要设置正确的状态。  Q3: 为什么 thread_schedule_tail() 是全局函数？  答：因为 switch_entry() 需要调用它。switch_entry() 在 switch.S 中定义，需要一个全局符号。  Q4: 线程优先级在当前实现中有效吗？  答：没有。当前实现只是 FIFO，不考虑优先级。实现优先级调度是 Project 1 的任务。  Q5: thread_ticks 在哪里重置？  答：在 thread_schedule_tail() 中：  thread_ticks = 0;  // 新线程开始新的时间片     练习思考          分析题：如果把 list_push_back 改成 list_push_front，对调度有什么影响？           设计题：如何实现基于优先级的调度？需要修改哪些函数？           计算题：假设有 3 个线程，时间片为 4 ticks，tick 周期为 10ms，每个线程运行完一轮需要多少时间？           调试题：如何验证轮转调度正在工作？（提示：打印日志）           扩展题：如何实现可变时间片？（不同优先级不同时间片长度）        下一步  理解了调度机制后，下一篇文档将深入 switch.S 汇编代码，看看上下文切换是如何在底层实现的。"
  },
  
  {
    "title": "Pintos 线程系统详解（三）：线程创建",
    "url": "/posts/pintos-thread-03-create/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 内存管理",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中线程创建的过程。thread_create() 是创建新线程的核心函数，它负责：    分配内存（一个 4KB 页）   初始化线程结构体   设置初始栈帧   将线程加入就绪队列   理解这个函数是理解线程如何开始执行的关键。    原始代码  thread_create() 函数  /** Creates a new kernel thread named NAME with the given initial    PRIORITY, which executes FUNCTION passing AUX as the argument,    and adds it to the ready queue.  Returns the thread identifier    for the new thread, or TID_ERROR if creation fails.     If thread_start() has been called, then the new thread may be    scheduled before thread_create() returns.  It could even exit    before thread_create() returns.  Contrariwise, the original    thread may run for any amount of time before the new thread is    scheduled.  Use a semaphore or some other form of    synchronization if you need to ensure ordering.     The code provided sets the new thread's `priority' member to    PRIORITY, but no actual priority scheduling is implemented.    Priority scheduling is the goal of Problem 1-3. */ tid_t thread_create (const char *name, int priority,                thread_func *function, void *aux)  {   struct thread *t;   struct kernel_thread_frame *kf;   struct switch_entry_frame *ef;   struct switch_threads_frame *sf;   tid_t tid;    ASSERT (function != NULL);    /* Allocate thread. */   t = palloc_get_page (PAL_ZERO);   if (t == NULL)     return TID_ERROR;    /* Initialize thread. */   init_thread (t, name, priority);   tid = t-&gt;tid = allocate_tid ();    /* Stack frame for kernel_thread(). */   kf = alloc_frame (t, sizeof *kf);   kf-&gt;eip = NULL;   kf-&gt;function = function;   kf-&gt;aux = aux;    /* Stack frame for switch_entry(). */   ef = alloc_frame (t, sizeof *ef);   ef-&gt;eip = (void (*) (void)) kernel_thread;    /* Stack frame for switch_threads(). */   sf = alloc_frame (t, sizeof *sf);   sf-&gt;eip = switch_entry;   sf-&gt;ebp = 0;    /* Add to run queue. */   thread_unblock (t);    return tid; }   init_thread() 函数  /** Does basic initialization of T as a blocked thread named NAME. */ static void init_thread (struct thread *t, const char *name, int priority) {   enum intr_level old_level;    ASSERT (t != NULL);   ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX);   ASSERT (name != NULL);    memset (t, 0, sizeof *t);   t-&gt;status = THREAD_BLOCKED;   strlcpy (t-&gt;name, name, sizeof t-&gt;name);   t-&gt;stack = (uint8_t *) t + PGSIZE;   t-&gt;priority = priority;   t-&gt;magic = THREAD_MAGIC;    old_level = intr_disable ();   list_push_back (&amp;all_list, &amp;t-&gt;allelem);   intr_set_level (old_level); }   alloc_frame() 函数  /** Allocates a SIZE-byte frame at the top of thread T's stack and    returns a pointer to the frame's base. */ static void * alloc_frame (struct thread *t, size_t size)  {   /* Stack data is always allocated in word-size units. */   ASSERT (is_thread (t));   ASSERT (size % sizeof (uint32_t) == 0);    t-&gt;stack -= size;   return t-&gt;stack; }   kernel_thread() 函数  /** Function used as the basis for a kernel thread. */ static void kernel_thread (thread_func *function, void *aux)  {   ASSERT (function != NULL);    intr_enable ();       /**&lt; The scheduler runs with interrupts off. */   function (aux);       /**&lt; Execute the thread function. */   thread_exit ();       /**&lt; If function() returns, kill the thread. */ }     前置知识  1. 函数调用约定  在 x86 32 位系统中，函数调用遵循以下约定（cdecl）：  调用前: ┌──────────────────┐ │     参数 n       │  高地址 │     ...          │ │     参数 2       │ │     参数 1       │ │   返回地址       │  ← call 指令自动压入 └──────────────────┘  ← ESP（调用后）  函数开头: push %ebp          ; 保存旧 ebp mov %esp, %ebp     ; 建立栈帧   2. 栈帧结构  每个函数调用都会建立一个栈帧：  高地址 ┌──────────────────┐ │   参数 n         │ │   ...            │ │   参数 1         │ ├──────────────────┤ │   返回地址       │  ← call 指令压入 ├──────────────────┤ │   旧 EBP         │  ← 当前 EBP 指向这里 ├──────────────────┤ │   局部变量 1     │ │   ...            │ │   局部变量 n     │  ← ESP └──────────────────┘ 低地址   3. 栈帧类型定义  /* switch.h */  /** switch_thread()'s stack frame. */ struct switch_threads_frame    {     uint32_t edi;               /**&lt;  0: Saved %edi. */     uint32_t esi;               /**&lt;  4: Saved %esi. */     uint32_t ebp;               /**&lt;  8: Saved %ebp. */     uint32_t ebx;               /**&lt; 12: Saved %ebx. */     void (*eip) (void);         /**&lt; 16: Return address. */     struct thread *cur;         /**&lt; 20: switch_threads()'s CUR argument. */     struct thread *next;        /**&lt; 24: switch_threads()'s NEXT argument. */   };  /** Stack frame for switch_entry(). */ struct switch_entry_frame   {     void (*eip) (void);   };  /* thread.c */  /** Stack frame for kernel_thread(). */ struct kernel_thread_frame    {     void *eip;                  /**&lt; Return address. */     thread_func *function;      /**&lt; Function to call. */     void *aux;                  /**&lt; Auxiliary data for function. */   };     逐步详解  第一步：参数检查和内存分配  tid_t thread_create (const char *name, int priority,                thread_func *function, void *aux)  {   struct thread *t;   struct kernel_thread_frame *kf;   struct switch_entry_frame *ef;   struct switch_threads_frame *sf;   tid_t tid;    ASSERT (function != NULL);  // function 不能为 NULL    /* Allocate thread. */   t = palloc_get_page (PAL_ZERO);  // 分配一个全零的页   if (t == NULL)     return TID_ERROR;  // 内存不足   palloc_get_page(PAL_ZERO)：    分配一个 4KB 页   PAL_ZERO 标志表示将页内容清零   返回页的起始地址（页对齐）   内存布局（刚分配完）：          4096 ┌─────────────────────┐              │                     │              │    全是 0           │              │                     │              │                     │              │                     │              │                     │              │                     │              │                     │            0 └─────────────────────┘ ← t 指向这里   第二步：初始化线程结构    /* Initialize thread. */   init_thread (t, name, priority);   tid = t-&gt;tid = allocate_tid ();   init_thread() 详解：  static void init_thread (struct thread *t, const char *name, int priority) {   ASSERT (t != NULL);   ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX);   ASSERT (name != NULL);    memset (t, 0, sizeof *t);           // 清零（虽然 PAL_ZERO 已经做了）   t-&gt;status = THREAD_BLOCKED;          // 初始状态为阻塞   strlcpy (t-&gt;name, name, sizeof t-&gt;name);  // 复制名称（最多 15 字符）   t-&gt;stack = (uint8_t *) t + PGSIZE;   // 栈指针指向页顶   t-&gt;priority = priority;              // 设置优先级   t-&gt;magic = THREAD_MAGIC;             // 设置魔数    // 加入 all_list   old_level = intr_disable ();   list_push_back (&amp;all_list, &amp;t-&gt;allelem);   intr_set_level (old_level); }   内存布局（init_thread 后）：          4096 ┌─────────────────────┐ ← t-&gt;stack 初始值              │                     │              │    (栈空间)         │              │                     │              │                     │              ├─────────────────────┤              │      magic          │              │      priority       │              │      stack (指针)   │              │      name[16]       │              │      status         │              │      tid            │            0 └─────────────────────┘ ← t   第三步：设置栈帧  这是最关键的部分！我们需要设置三层栈帧：    /* Stack frame for kernel_thread(). */   kf = alloc_frame (t, sizeof *kf);   kf-&gt;eip = NULL;   kf-&gt;function = function;   kf-&gt;aux = aux;    /* Stack frame for switch_entry(). */   ef = alloc_frame (t, sizeof *ef);   ef-&gt;eip = (void (*) (void)) kernel_thread;    /* Stack frame for switch_threads(). */   sf = alloc_frame (t, sizeof *sf);   sf-&gt;eip = switch_entry;   sf-&gt;ebp = 0;   alloc_frame() 的工作：  static void * alloc_frame (struct thread *t, size_t size)  {   t-&gt;stack -= size;   // 栈向下增长   return t-&gt;stack;    // 返回新的栈顶 }   让我们一步步看栈的变化：  初始状态：          4096 ┌─────────────────────┐ ← t-&gt;stack              │                     │              │                     │              │                     │   设置 kernel_thread_frame 后：  kf = alloc_frame (t, sizeof *kf);  // 12 字节 kf-&gt;eip = NULL; kf-&gt;function = function; kf-&gt;aux = aux;           4096 ┌─────────────────────┐              │       aux           │  4 字节              │     function        │  4 字节              │     eip (NULL)      │  4 字节         4084 ├─────────────────────┤ ← t-&gt;stack, kf              │                     │   设置 switch_entry_frame 后：  ef = alloc_frame (t, sizeof *ef);  // 4 字节 ef-&gt;eip = (void (*) (void)) kernel_thread;           4096 ┌─────────────────────┐              │       aux           │              │     function        │              │     eip (NULL)      │  ← kf         4084 ├─────────────────────┤              │ eip (kernel_thread) │  ← ef         4080 ├─────────────────────┤ ← t-&gt;stack              │                     │   设置 switch_threads_frame 后：  sf = alloc_frame (t, sizeof *sf);  // 28 字节 sf-&gt;eip = switch_entry; sf-&gt;ebp = 0; // edi, esi, ebx 保持为 0（PAL_ZERO）           4096 ┌─────────────────────┐              │       aux           │              │     function        │              │     eip (NULL)      │  ← kf         4084 ├─────────────────────┤              │ eip (kernel_thread) │  ← ef         4080 ├─────────────────────┤              │    next (未设置)    │  28: 参数              │    cur (未设置)     │  24: 参数              │  eip (switch_entry) │  20: 返回地址              │    ebx (0)          │  16:              │    ebp (0)          │  12:              │    esi (0)          │   8:              │    edi (0)          │   4:         4052 ├─────────────────────┤ ← t-&gt;stack, sf              │                     │   第四步：加入就绪队列    /* Add to run queue. */   thread_unblock (t);    return tid; }   thread_unblock(t) 将线程从 BLOCKED 变为 READY，加入 ready_list。    完整栈帧布局  高地址 4096    ┌───────────────────────────────────────────┐         │               aux                         │ ┐         │             function                      │ │ kernel_thread_frame         │           eip (NULL)                      │ ┘ (12 bytes)         ├───────────────────────────────────────────┤         │         eip (kernel_thread)               │   switch_entry_frame         ├───────────────────────────────────────────┤   (4 bytes)         │    next  (未初始化，由 schedule 设置)     │ ┐         │    cur   (未初始化，由 schedule 设置)     │ │         │    eip   (switch_entry)                   │ │ switch_threads_frame         │    ebx   (0)                              │ │ (28 bytes)         │    ebp   (0)                              │ │         │    esi   (0)                              │ │         │    edi   (0)                              │ ┘         ├───────────────────────────────────────────┤ ← t-&gt;stack         │                                           │         │         (栈增长空间 - 未使用)             │         │    kernel_thread() 执行时使用此空间      │         │                                           │         ├───────────────────────────────────────────┤         │              magic                        │         │            (其他字段)                     │         │           struct thread                   │ 0       └───────────────────────────────────────────┘ ← t 低地址     新线程如何开始执行？  这是理解线程系统的关键！让我们跟踪新线程第一次被调度的过程：  1. 调度器选中新线程  static void schedule (void)  {   struct thread *cur = running_thread ();   struct thread *next = next_thread_to_run ();  // 选中新线程      if (cur != next)     prev = switch_threads (cur, next);  // 切换到新线程   thread_schedule_tail (prev); }   2. switch_threads() 切换  switch_threads:     # 保存旧线程的寄存器     pushl %ebx     pushl %ebp     pushl %esi     pushl %edi      # 保存旧线程的栈指针     mov thread_stack_ofs, %edx     movl SWITCH_CUR(%esp), %eax     movl %esp, (%eax,%edx,1)      # cur-&gt;stack = esp      # 恢复新线程的栈指针     movl SWITCH_NEXT(%esp), %ecx     movl (%ecx,%edx,1), %esp      # esp = next-&gt;stack      # 恢复新线程的寄存器（对于新线程，是 0）     popl %edi     popl %esi     popl %ebp     popl %ebx     ret  # 返回到 sf-&gt;eip，即 switch_entry   3. switch_entry() 执行  switch_entry:     # 丢弃 switch_threads() 的参数     addl $8, %esp      # 调用 thread_schedule_tail(prev)     pushl %eax     call thread_schedule_tail     addl $4, %esp      # ret 将返回到 ef-&gt;eip，即 kernel_thread     ret   4. kernel_thread() 执行  static void kernel_thread (thread_func *function, void *aux)  {   ASSERT (function != NULL);    intr_enable ();       // 开启中断   function (aux);       // 执行用户指定的函数！   thread_exit ();       // 函数返回后退出线程 }   执行流程图  schedule()     │     ▼ switch_threads(cur, next)     │     │  保存 cur 的寄存器和栈指针     │  恢复 next 的栈指针     │  恢复 next 的寄存器 (全是 0)     │     ▼  ret (从 next 的栈弹出返回地址) switch_entry  (sf-&gt;eip)     │     │  丢弃参数     │  调用 thread_schedule_tail()     │     ▼  ret (从栈弹出返回地址) kernel_thread  (ef-&gt;eip)     │     │  intr_enable()     │  function(aux)   ← 执行用户函数！     │     ▼  thread_exit() 线程结束     为什么需要三层栈帧？  switch_threads_frame  作用：模拟 switch_threads() 被调用后的状态  新线程第一次被调度时，需要假装它之前调用过 switch_threads()：    有保存的寄存器（初始化为 0）   有返回地址（指向 switch_entry）   switch_entry_frame  作用：提供 switch_entry 的返回地址  switch_entry 需要一个返回地址（指向 kernel_thread）。  kernel_thread_frame  作用：为 kernel_thread() 提供参数  kernel_thread() 需要知道要执行的函数和参数。    thread_func 类型  typedef void thread_func (void *aux);   线程函数的签名：    返回类型：void   参数：一个 void 指针   使用示例：  void my_thread_func (void *aux)  {   int *data = (int *) aux;   printf (\"Thread received: %d\\n\", *data); }  // 创建线程 int value = 42; thread_create (\"my-thread\", PRI_DEFAULT, my_thread_func, &amp;value);     常见问题  Q1: 为什么 kf-&gt;eip 设置为 NULL？  答：这是 kernel_thread() 的”返回地址”。正常情况下，kernel_thread() 不会 return（它调用 thread_exit()）。设置为 NULL 是一个安全措施：如果意外 return，访问 NULL 会导致明显的错误。  Q2: 新线程的栈指针为什么指向 switch_threads_frame？  答：因为新线程第一次被调度时，会从 switch_threads() 的末尾继续执行。此时栈上需要有：    保存的寄存器（供 popl 恢复）   返回地址（供 ret 跳转）   Q3: 为什么 sf-&gt;ebp 设置为 0？  答：ebp=0 表示栈帧链的终点。调试器在回溯调用栈时，遇到 ebp=0 就知道到顶了。  Q4: thread_create() 返回后新线程就开始运行了吗？  答：不一定。thread_create() 只是将新线程加入 ready_list。新线程什么时候运行取决于调度器。可能：    立即被调度（如果优先级更高）   在下一个时间片   当前线程主动 yield 后   Q5: 如何向线程函数传递多个参数？  答：将多个参数打包成一个结构体：  struct thread_args {   int a;   int b;   char *str; };  void my_func (void *aux) {   struct thread_args *args = aux;   // 使用 args-&gt;a, args-&gt;b, args-&gt;str }  // 注意：args 必须在线程执行期间有效！ struct thread_args args = {1, 2, \"hello\"}; thread_create (\"test\", PRI_DEFAULT, my_func, &amp;args);   Q6: 线程函数 return 后会发生什么？  答：kernel_thread() 会调用 thread_exit()：  static void kernel_thread (thread_func *function, void *aux)  {   function (aux);       // 执行用户函数   thread_exit ();       // 用户函数返回后，退出线程 }   所以线程函数可以安全地 return，不需要显式调用 thread_exit()。    调试技巧  打印新线程信息  tid_t thread_create (const char *name, int priority,                thread_func *function, void *aux)  {   // ... 原有代码 ...      printf (\"Created thread '%s' (tid=%d, priority=%d)\\n\",           name, tid, priority);   printf (\"  stack at %p, thread at %p\\n\", t-&gt;stack, t);      thread_unblock (t);   return tid; }   使用 GDB 跟踪  # 在 thread_create 设置断点 b thread_create  # 运行后查看新线程的栈 print *t print *kf print *ef print *sf  # 单步执行 n     练习思考          计算题：thread_create() 在栈上分配了多少字节？（kernel_thread_frame + switch_entry_frame + switch_threads_frame）           分析题：如果 palloc_get_page() 不使用 PAL_ZERO 标志，会有什么问题？           设计题：如果想让线程创建时就是 RUNNING 状态（立即执行），需要修改哪些代码？           调试题：如果新线程创建后立即崩溃，可能是什么原因？如何诊断？           扩展题：如何实现 thread_create_suspended()，创建一个不自动加入就绪队列的线程？        下一步  理解了线程创建后，下一篇文档将详细介绍线程调度，看看调度器是如何选择下一个运行的线程的。"
  },
  
  {
    "title": "Pintos 线程系统详解（二）：线程生命周期",
    "url": "/posts/pintos-thread-02-lifecycle/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 状态机",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中线程的生命周期管理。一个线程从创建到销毁会经历多种状态，理解这些状态及其转换是理解调度和同步的基础。    线程状态定义  原始代码  /** States in a thread's life cycle. */ enum thread_status   {     THREAD_RUNNING,     /**&lt; Running thread. */     THREAD_READY,       /**&lt; Not running but ready to run. */     THREAD_BLOCKED,     /**&lt; Waiting for an event to trigger. */     THREAD_DYING        /**&lt; About to be destroyed. */   };     前置知识  1. 为什么需要线程状态？  操作系统需要跟踪每个线程的当前情况：    哪个线程正在运行？   哪些线程可以运行但还没轮到？   哪些线程在等待某些事件？   2. 状态机概念  线程状态可以用有限状态机来描述：    状态：线程当前的情况   转换：从一个状态变到另一个状态   触发器：引起转换的事件或操作     四种线程状态详解  1. THREAD_RUNNING（运行态）  状态：线程正在 CPU 上执行 特点：在单核系统中，任一时刻只有一个线程处于此状态   进入此状态：被调度器选中执行 离开此状态：主动让出 CPU 或被抢占  相关操作： // 在 schedule() 函数末尾，切换到新线程后 cur-&gt;status = THREAD_RUNNING;   2. THREAD_READY（就绪态）  状态：线程准备好运行，等待 CPU 位置：在 ready_list 队列中   进入此状态：    新创建的线程（thread_create → thread_unblock）   运行中的线程让出 CPU（thread_yield）   阻塞的线程被唤醒（thread_unblock）   离开此状态：被调度器选中执行  相关操作： // thread_unblock() - 将阻塞线程变为就绪 void thread_unblock (struct thread *t)  {   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_push_back (&amp;ready_list, &amp;t-&gt;elem);  // 加入就绪队列   t-&gt;status = THREAD_READY;                 // 设置状态 }  // thread_yield() - 当前线程主动让出 CPU void thread_yield (void)  {   struct thread *cur = thread_current ();   if (cur != idle_thread)      list_push_back (&amp;ready_list, &amp;cur-&gt;elem);  // 加入就绪队列   cur-&gt;status = THREAD_READY;                   // 设置状态   schedule ();                                  // 调度其他线程 }   3. THREAD_BLOCKED（阻塞态）  状态：线程在等待某个事件 位置：在某个等待队列中（如信号量的 waiters 队列）   进入此状态：    等待信号量（sema_down）   等待锁（lock_acquire）   等待条件变量（cond_wait）   其他等待操作（thread_block）   离开此状态：等待的事件发生（thread_unblock）  相关操作： // thread_block() - 阻塞当前线程 void thread_block (void)  {   ASSERT (intr_get_level () == INTR_OFF);  // 必须禁用中断   thread_current ()-&gt;status = THREAD_BLOCKED;   schedule ();  // 切换到其他线程 }   重要：调用 thread_block() 前，调用者必须：    禁用中断   将当前线程加入某个等待队列   4. THREAD_DYING（将死态）  状态：线程即将被销毁 特点：永远不会再运行   进入此状态：线程退出（thread_exit）  相关操作： void thread_exit (void)  {   intr_disable ();   list_remove (&amp;thread_current()-&gt;allelem);  // 从 all_list 移除   thread_current ()-&gt;status = THREAD_DYING;   schedule ();  // 切换到其他线程   NOT_REACHED ();  // 永远不会返回 }   销毁时机：在 thread_schedule_tail() 中，由下一个运行的线程来释放内存：  void thread_schedule_tail (struct thread *prev) {   // ... 其他代码 ...    /* If the thread we switched from is dying, destroy its struct thread. */   if (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread)      {       ASSERT (prev != cur);       palloc_free_page (prev);  // 释放线程占用的页     } }     状态转换图  完整状态转换图  stateDiagram-v2     [*] --&gt; BLOCKED : thread_create()     BLOCKED --&gt; READY : thread_unblock()     READY --&gt; RUNNING : schedule()     RUNNING --&gt; READY : thread_yield()/时间片耗尽     RUNNING --&gt; BLOCKED : thread_block()/sema_down()/lock_acquire()/cond_wait()     RUNNING --&gt; DYING : thread_exit()     DYING --&gt; [*] : palloc_free_page()          BLOCKED : 初始状态/等待事件     READY : 准备运行，在 ready_list 中     RUNNING : 正在 CPU 上执行     DYING : 即将被销毁   状态转换表                 当前状态       触发事件       目标状态       函数                       (不存在)       创建       BLOCKED       thread_create()                 BLOCKED       解除阻塞       READY       thread_unblock()                 READY       被调度       RUNNING       schedule()                 RUNNING       让出 CPU       READY       thread_yield()                 RUNNING       时间片耗尽       READY       定时器中断                 RUNNING       等待事件       BLOCKED       thread_block()                 RUNNING       退出       DYING       thread_exit()                 DYING       内存释放       (销毁)       palloc_free_page()             状态转换详细分析  转换 1: 创建 → BLOCKED  tid_t thread_create (const char *name, int priority,                thread_func *function, void *aux)  {   struct thread *t;      t = palloc_get_page (PAL_ZERO);  // 分配页   init_thread (t, name, priority);  // 初始化，状态设为 BLOCKED   // ... 设置栈帧 ...   thread_unblock (t);  // 转为 READY   return tid; }  static void init_thread (struct thread *t, const char *name, int priority) {   t-&gt;status = THREAD_BLOCKED;  // 初始状态为 BLOCKED   // ... 其他初始化 ... }   为什么初始状态是 BLOCKED？     线程创建时还没准备好运行（栈帧未设置完）   通过 thread_unblock() 显式转为 READY 更清晰   与其他阻塞→就绪的路径保持一致   转换 2: BLOCKED → READY  void thread_unblock (struct thread *t)  {   enum intr_level old_level;    ASSERT (is_thread (t));    old_level = intr_disable ();  // 禁用中断   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_push_back (&amp;ready_list, &amp;t-&gt;elem);  // 加入就绪队列   t-&gt;status = THREAD_READY;   intr_set_level (old_level);  // 恢复中断 }   关键点：    必须禁用中断，保证原子性   先加入 ready_list，再改状态   不会立即调度（调用者可能还需要做其他事）   转换 3: READY → RUNNING  static void schedule (void)  {   struct thread *cur = running_thread ();   struct thread *next = next_thread_to_run ();  // 从 ready_list 选择   struct thread *prev = NULL;    ASSERT (cur-&gt;status != THREAD_RUNNING);  // 当前线程已不是 RUNNING   ASSERT (is_thread (next));    if (cur != next)     prev = switch_threads (cur, next);  // 执行上下文切换   thread_schedule_tail (prev); }  void thread_schedule_tail (struct thread *prev) {   struct thread *cur = running_thread ();   cur-&gt;status = THREAD_RUNNING;  // 设置为运行状态   thread_ticks = 0;  // 重置时间片计数   // ... }   转换 4: RUNNING → READY  void thread_yield (void)  {   struct thread *cur = thread_current ();   enum intr_level old_level;      ASSERT (!intr_context ());  // 不能在中断处理中调用    old_level = intr_disable ();   if (cur != idle_thread)      list_push_back (&amp;ready_list, &amp;cur-&gt;elem);   cur-&gt;status = THREAD_READY;   schedule ();  // 调度其他线程   intr_set_level (old_level);  // 返回后恢复中断 }   两种触发方式：     主动让出：调用 thread_yield()   被动抢占：时间片耗尽，定时器中断处理中设置标志   // timer.c - 定时器中断处理 void thread_tick (void)  {   struct thread *t = thread_current ();   // ... 统计 ...      if (++thread_ticks &gt;= TIME_SLICE)  // 时间片耗尽     intr_yield_on_return ();  // 设置标志，中断返回时 yield }   转换 5: RUNNING → BLOCKED  void thread_block (void)  {   ASSERT (!intr_context ());  // 不能在中断处理中   ASSERT (intr_get_level () == INTR_OFF);  // 中断必须已禁用    thread_current ()-&gt;status = THREAD_BLOCKED;   schedule ();  // 调度其他线程 }   典型使用场景（信号量的 down 操作）：  void sema_down (struct semaphore *sema)  {   enum intr_level old_level;    old_level = intr_disable ();  // 禁用中断   while (sema-&gt;value == 0)  // 资源不可用     {       list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);       thread_block ();  // 阻塞     }   sema-&gt;value--;   intr_set_level (old_level); }   转换 6: RUNNING → DYING  void thread_exit (void)  {   ASSERT (!intr_context ());  #ifdef USERPROG   process_exit ();  // 用户进程清理 #endif    intr_disable ();  // 禁用中断   list_remove (&amp;thread_current()-&gt;allelem);  // 从 all_list 移除   thread_current ()-&gt;status = THREAD_DYING;   schedule ();  // 切换到其他线程   NOT_REACHED ();  // 永远不会执行到这里 }   为什么自己不能释放自己的内存？  因为正在使用自己的栈！如果释放了，栈就没了，代码无法继续执行。  解决方案：让下一个运行的线程来清理：  void thread_schedule_tail (struct thread *prev) {   // ...    if (prev != NULL &amp;&amp; prev-&gt;status == THREAD_DYING &amp;&amp; prev != initial_thread)      {       ASSERT (prev != cur);  // 不能是自己       palloc_free_page (prev);  // 释放前一个线程的页     } }     时间片和抢占  时间片机制  #define TIME_SLICE 4  // 时间片 = 4 个 tick  static unsigned thread_ticks;  // 当前线程已运行的 tick 数  void thread_tick (void)  {   // ... 统计 ...      if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return ();  // 时间片耗尽，请求调度 }   抢占式调度  时间轴 ──────────────────────────────────────────────►         │                                │         ▼                                ▼     Thread A 开始运行               时间片耗尽         │                                │    ┌────┴────┐  tick  tick  tick  tick  ─┴──► 中断返回时 yield    │         │   1     2     3     4    │ Thread A 运行                           │         │    └─────────┘                                          Thread B 开始运行                                              │                                     ┌────────┴────────┐                                     │                 │                                     │  Thread B 运行  │                                     │                 │                                     └─────────────────┘     中断与线程状态  为什么状态转换需要禁用中断？  状态转换涉及多个步骤，必须原子执行：  // 例如 thread_unblock list_push_back (&amp;ready_list, &amp;t-&gt;elem);  // 步骤 1 t-&gt;status = THREAD_READY;                 // 步骤 2   如果在步骤 1 和 2 之间发生中断，可能导致：    线程在 ready_list 中但状态不是 READY   调度器可能做出错误决定   禁用中断的范围  void thread_unblock (struct thread *t)  {   enum intr_level old_level;    old_level = intr_disable ();  // ← 禁用中断   // --- 临界区开始 ---   ASSERT (t-&gt;status == THREAD_BLOCKED);   list_push_back (&amp;ready_list, &amp;t-&gt;elem);   t-&gt;status = THREAD_READY;   // --- 临界区结束 ---   intr_set_level (old_level);  // ← 恢复之前的状态 }     线程状态与数据结构的对应  状态            所在位置               说明 ─────────────────────────────────────────────────────── RUNNING        无（正在 CPU 上执行）   通过 thread_current() 获取 READY          ready_list            等待 CPU BLOCKED        某等待队列             如 sema-&gt;waiters DYING          无                    即将被回收     常见问题  Q1: 为什么新创建的线程初始状态是 BLOCKED 而不是 READY？  答：这是一个设计选择：    init_thread() 只做基本初始化   调用者通过 thread_unblock() 显式表示线程准备好了   这样 thread_unblock() 有统一的语义：将线程加入就绪队列   Q2: thread_yield() 和 thread_block() 有什么区别？  答：                 方面       thread_yield()       thread_block()                       目标状态       READY       BLOCKED                 加入队列       ready_list       调用者指定的队列                 何时返回       再次被调度时       被 unblock 后调度时                 使用场景       主动让出 CPU       等待某事件           Q3: 为什么 DYING 状态的线程不能自己释放内存？  答：因为线程正在使用自己的栈：    释放内存后，栈空间就无效了   无法继续执行代码，甚至无法 return   解决方案是让下一个运行的线程来清理。  Q4: 中断处理中能调用 thread_yield() 吗？  答：不能。thread_yield() 有断言：  ASSERT (!intr_context ());  // 不能在中断上下文中   中断处理中应该使用 intr_yield_on_return()，它只是设置一个标志，在中断返回后才真正 yield。  Q5: 如果 ready_list 为空会怎样？  答：会调度 idle_thread（空闲线程）：  static struct thread * next_thread_to_run (void)  {   if (list_empty (&amp;ready_list))     return idle_thread;  // 空闲线程总是存在   else     return list_entry (list_pop_front (&amp;ready_list), struct thread, elem); }     状态检查函数  thread_current()  struct thread * thread_current (void)  {   struct thread *t = running_thread ();      ASSERT (is_thread (t));   ASSERT (t-&gt;status == THREAD_RUNNING);  // 必须是运行状态    return t; }   is_thread()  static bool is_thread (struct thread *t) {   return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; }     练习思考     分析题：画出以下场景的状态转换序列：            Thread A 创建 Thread B       Thread B 调用 sema_down 等待       Thread A 调用 sema_up 唤醒 Thread B                设计题：如果要添加一个 THREAD_SUSPENDED 状态（可以被其他线程挂起/恢复），需要哪些修改？           调试题：如果发现一个线程长时间处于 READY 状态但不被调度，可能是什么原因？      思考题：为什么 thread_block() 要求调用者先禁用中断，而不是自己禁用？     下一步  理解了线程生命周期后，下一篇文档将详细介绍 thread_create() 函数，看看一个线程是如何被创建出来的。"
  },
  
  {
    "title": "Pintos 线程系统详解（一）：线程结构",
    "url": "/posts/pintos-thread-01-structure/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 数据结构",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  本文档详细解析 Pintos 中线程的核心数据结构 struct thread。理解这个结构是理解整个线程系统的基础。  Pintos 采用了一种独特的设计：每个线程占用一个完整的 4KB 页。线程结构体位于页的底部，而线程的内核栈从页的顶部向下增长。这种设计使得通过栈指针就能快速定位到线程结构体。    原始代码  thread.h 中的类型定义  /** Thread identifier type.    You can redefine this to whatever type you like. */ typedef int tid_t; #define TID_ERROR ((tid_t) -1)          /**&lt; Error value for tid_t. */  /** Thread priorities. */ #define PRI_MIN 0                       /**&lt; Lowest priority. */ #define PRI_DEFAULT 31                  /**&lt; Default priority. */ #define PRI_MAX 63                      /**&lt; Highest priority. */   thread.h 中的线程状态枚举  /** States in a thread's life cycle. */ enum thread_status   {     THREAD_RUNNING,     /**&lt; Running thread. */     THREAD_READY,       /**&lt; Not running but ready to run. */     THREAD_BLOCKED,     /**&lt; Waiting for an event to trigger. */     THREAD_DYING        /**&lt; About to be destroyed. */   };   thread.h 中的 struct thread 定义  struct thread   {     /* Owned by thread.c. */     tid_t tid;                          /**&lt; Thread identifier. */     enum thread_status status;          /**&lt; Thread state. */     char name[16];                      /**&lt; Name (for debugging purposes). */     uint8_t *stack;                     /**&lt; Saved stack pointer. */     int priority;                       /**&lt; Priority. */     struct list_elem allelem;           /**&lt; List element for all threads list. */      /* Shared between thread.c and synch.c. */     struct list_elem elem;              /**&lt; List element. */  #ifdef USERPROG     /* Owned by userprog/process.c. */     uint32_t *pagedir;                  /**&lt; Page directory. */ #endif      /* Owned by thread.c. */     unsigned magic;                     /**&lt; Detects stack overflow. */   };   thread.c 中的魔数定义  /** Random value for struct thread's `magic' member.    Used to detect stack overflow.  See the big comment at the top    of thread.h for details. */ #define THREAD_MAGIC 0xcd6abf4b     前置知识  1. 为什么需要线程结构？  操作系统需要管理多个执行流（线程），这需要：     保存执行状态：当线程不运行时，保存其寄存器、栈指针等   调度信息：优先级、状态等，供调度器使用   身份标识：线程 ID、名称，用于标识和调试   链接信息：将线程组织成各种数据结构（链表等）   2. Pintos 的 4KB 页设计  Pintos 选择让每个线程占用一个 4KB（4096 字节）页，这是一个巧妙的设计：  内存地址（升序）       ▲       │ 4096  ├───────────────────────────────────┐       │                                   │       │          Kernel Stack             │       │               │                   │       │               │                   │       │               ▼                   │       │         (向下增长)                │       │                                   │       │                                   │       │          (未使用空间)             │       │                                   │       │                                   │       ├───────────────────────────────────┤       │            magic                  │  ← 栈溢出检测       │          (其他字段)               │       │            name[16]               │       │            status                 │ 0     │             tid                   │  ← struct thread 起始       └───────────────────────────────────┘   设计优点：     快速定位：通过栈指针可以立即找到线程结构     // 将栈指针向下对齐到页边界，就得到 struct thread 的地址 struct thread *t = (struct thread *) (esp &amp; ~0xfff);                栈溢出检测：如果栈向下增长太多，会覆盖 magic 字段      简化内存管理：分配/释放线程只需一次页操作   3. 内存对齐  页大小是 4096 字节（2^12），页边界地址的低 12 位都是 0：  页边界地址示例： 0x0000_0000 0x0000_1000 0x0000_2000 ... 0xFFFF_F000   4. list_elem 结构  Pintos 使用侵入式链表（intrusive list），即链表节点嵌入到数据结构中：  struct list_elem    {     struct list_elem *prev;     /* Previous list element. */     struct list_elem *next;     /* Next list element. */   };   通过 list_entry 宏可以从链表节点获取包含它的结构体：  #define list_entry(LIST_ELEM, STRUCT, MEMBER) \\         ((STRUCT *) ((uint8_t *) (LIST_ELEM) - offsetof (STRUCT, MEMBER)))     逐字段详解  1. tid_t tid - 线程标识符  tid_t tid;                          /**&lt; Thread identifier. */   作用：唯一标识一个线程。  类型：tid_t 是 int 的别名，方便以后修改。  取值：    从 1 开始递增分配   TID_ERROR (-1) 表示错误   分配机制（在 allocate_tid() 中）：  static tid_t allocate_tid (void)  {   static tid_t next_tid = 1;  // 静态变量，全局唯一   tid_t tid;    lock_acquire (&amp;tid_lock);   // 加锁保证原子性   tid = next_tid++;   lock_release (&amp;tid_lock);    return tid; }   2. enum thread_status status - 线程状态  enum thread_status status;          /**&lt; Thread state. */   可能的值：                 状态       含义       所在位置                       THREAD_RUNNING       正在 CPU 上运行       唯一（单核）                 THREAD_READY       准备运行，等待调度       ready_list                 THREAD_BLOCKED       等待某事件       某个等待队列                 THREAD_DYING       即将被销毁       无           状态转换图：                                     创建                                     │                                     ▼                              ┌──────────────┐                              │   BLOCKED    │                              │  (初始状态)  │                              └──────────────┘                                     │                                     │ unblock                                     ▼ ┌──────────────┐  被调度选中   ┌──────────────┐ │   RUNNING    │◄─────────────│    READY     │ │   (运行中)   │              │  (就绪态)    │ └──────────────┘              └──────────────┘        │    │                        ▲        │    │     yield/时间片耗尽    │        │    └────────────────────────┘        │        │ exit        ▼ ┌──────────────┐ │    DYING     │ │   (将销毁)   │ └──────────────┘   3. char name[16] - 线程名称  char name[16];                      /**&lt; Name (for debugging purposes). */   作用：仅用于调试，帮助识别线程。  限制：最多 15 个字符 + 1 个终止符 \\0。  使用场景：    调试输出   错误信息   thread_name() 函数返回   4. uint8_t *stack - 保存的栈指针  uint8_t *stack;                     /**&lt; Saved stack pointer. */   这是最关键的字段之一！  作用：保存线程不运行时的栈指针位置。  何时使用：    线程被切换出去时，保存当前栈指针到此处   线程被切换回来时，从此处恢复栈指针   与上下文切换的关系（在 switch.S 中）：  # 保存当前栈指针到旧线程的 stack 字段 mov thread_stack_ofs, %edx      # 获取 stack 字段的偏移量 movl SWITCH_CUR(%esp), %eax     # 获取当前线程指针 movl %esp, (%eax,%edx,1)        # cur-&gt;stack = esp  # 从新线程的 stack 字段恢复栈指针 movl SWITCH_NEXT(%esp), %ecx    # 获取下一线程指针 movl (%ecx,%edx,1), %esp        # esp = next-&gt;stack   5. int priority - 优先级  int priority;                       /**&lt; Priority. */   作用：决定线程的调度优先级。  取值范围：  #define PRI_MIN 0                   // 最低优先级 #define PRI_DEFAULT 31              // 默认优先级 #define PRI_MAX 63                  // 最高优先级   注意：基础 Pintos 没有实现优先级调度，这是 Project 1 的任务之一。  6. struct list_elem allelem - 全局线程列表元素  struct list_elem allelem;           /**&lt; List element for all threads list. */   作用：将所有线程链接到 all_list 链表。  用途：    遍历所有线程（如 thread_foreach()）   调试和统计   /* 全局线程列表 */ static struct list all_list;  /* 遍历所有线程 */ void thread_foreach (thread_action_func *func, void *aux) {   struct list_elem *e;   for (e = list_begin (&amp;all_list); e != list_end (&amp;all_list);        e = list_next (e))     {       struct thread *t = list_entry (e, struct thread, allelem);       func (t, aux);     } }   7. struct list_elem elem - 通用列表元素  struct list_elem elem;              /**&lt; List element. */   作用：用于将线程加入各种队列。  使用场景（互斥使用）：    在 ready_list 中（状态为 READY）   在信号量的等待队列中（状态为 BLOCKED）   为什么可以复用？  因为一个线程在任一时刻只能处于一个状态：    READY 状态 → 在 ready_list 中   BLOCKED 状态 → 在某个等待队列中   RUNNING 状态 → 不在任何队列中   8. uint32_t *pagedir - 页目录（用户程序）  #ifdef USERPROG     uint32_t *pagedir;              /**&lt; Page directory. */ #endif   作用：指向用户进程的页目录。  条件编译：只在 USERPROG 定义时存在。  用途：    进程切换时激活正确的地址空间   内核线程此字段为 NULL   9. unsigned magic - 魔数  unsigned magic;                     /**&lt; Detects stack overflow. */   作用：检测栈溢出。  原理：     初始化时设置为特定值：     #define THREAD_MAGIC 0xcd6abf4b t-&gt;magic = THREAD_MAGIC;           检查时验证：     static bool is_thread (struct thread *t) {   return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; }           如果栈向下增长过多，会覆盖 magic，导致检测失败。   检测时机：    thread_current() 每次调用都会检查   检测失败会触发 assertion 失败     struct thread 内存布局详图  偏移量    字段                   大小(字节)    说明 ───────────────────────────────────────────────────────    0      tid                      4          线程ID    4      status                   4          状态    8      name[16]                16          名称   24      stack                    4          栈指针   28      priority                 4          优先级   32      allelem.prev             4          ─┐   36      allelem.next             4          ─┴─ allelem (8字节)   40      elem.prev                4          ─┐   44      elem.next                4          ─┴─ elem (8字节)   48      pagedir (if USERPROG)    4          页目录指针   52      magic                    4          魔数 ─────────────────────────────────────────────────────── 总大小: 约 56 字节（不含 USERPROG 为 52 字节）   剩余空间：    页大小：4096 字节   struct thread：约 56 字节   可用于栈：约 4040 字节     全局数据结构  thread.c 中的全局变量  /** List of processes in THREAD_READY state */ static struct list ready_list;  /** List of all processes */ static struct list all_list;  /** Idle thread */ static struct thread *idle_thread;  /** Initial thread, the thread running init.c:main() */ static struct thread *initial_thread;  /** Lock used by allocate_tid() */ static struct lock tid_lock;   数据结构关系图：  all_list (所有线程) ┌─────────────────────────────────────────────────────────────┐ │                                                               │ │  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐  │ │  │  main   │───►│  idle   │───►│thread_A │───►│thread_B │  │ │  │ thread  │◄───│ thread  │◄───│         │◄───│         │  │ │  └─────────┘    └─────────┘    └─────────┘    └─────────┘  │ │       │                              │              │        │ │       ▼                              ▼              ▼        │ │  initial_thread              (可能在 ready_list 或等待队列) │ │                                                               │ └─────────────────────────────────────────────────────────────┘  ready_list (就绪线程) ┌─────────────────────────────────────────────────────────────┐ │                                                               │ │  ┌─────────┐    ┌─────────┐                                 │ │  │thread_A │───►│thread_B │                                 │ │  │ (READY) │◄───│ (READY) │                                 │ │  └─────────┘    └─────────┘                                 │ │                                                               │ └─────────────────────────────────────────────────────────────┘     running_thread() 函数  这是一个精妙的函数，利用了 4KB 页设计：  /** Returns the running thread. */ struct thread * running_thread (void)  {   uint32_t *esp;    /* Copy the CPU's stack pointer into `esp', and then round that      down to the start of a page.  Because `struct thread' is      always at the beginning of a page and the stack pointer is      somewhere in the middle, this locates the current thread. */   asm (\"mov %%esp, %0\" : \"=g\" (esp));   return pg_round_down (esp); }   工作原理：                 4KB 页         ┌─────────────────┐ 0x8001000 (页顶)         │                 │         │   Kernel Stack  │         │        │        │         │        ▼        │         │   ESP ──────────│◄── 当前栈指针位于此处         │                 │         │                 │         │                 │         ├─────────────────┤         │  struct thread  │         └─────────────────┘ 0x8000000 (页底) = pg_round_down(ESP)   pg_round_down 的实现：  /* 向下取整到页边界 */ #define PGSIZE 4096 #define PGMASK (PGSIZE - 1)  // 0xFFF  static inline void *pg_round_down (const void *va) {   return (void *) ((uintptr_t) va &amp; ~PGMASK); }   例如：    ESP = 0x8000F00   pg_round_down(ESP) = 0x8000F00 &amp; ~0xFFF = 0x8000000     常见问题  Q1: 为什么 struct thread 放在页底部而不是顶部？  答：这是为了让 running_thread() 能工作。栈指针在页内某处，向下取整（pg_round_down）就能得到页起始地址，也就是 struct thread 的地址。如果 struct thread 在页顶，就需要向上取整后再计算偏移，更复杂。  Q2: 为什么栈空间只有约 4KB？这够用吗？  答：对于内核线程来说，4KB 通常够用。但要注意：    不要使用大的局部数组   不要深度递归   需要大内存时用 malloc() 或 palloc_get_page()   Q3: magic 字段为什么能检测栈溢出？  答：    struct thread 在页底部   magic 字段在 struct thread 的末尾（最高地址处）   栈从页顶向下增长   如果栈溢出，首先会覆盖 magic 字段   正常情况: ┌─────────────┐ │    Stack    │ │      ↓      │ │   (空间)    │ ├─────────────┤ │   magic ✓   │ &lt;- 未被覆盖 │   ...       │ └─────────────┘  溢出情况: ┌─────────────┐ │    Stack    │ │      ↓      │ │    ↓↓↓↓     │ ├─────────────┤ &lt;- 栈已经越界 │   magic ✗   │ &lt;- 被栈数据覆盖！ │   ...       │ └─────────────┘   Q4: 为什么 elem 字段可以在不同队列中复用？  答：因为一个线程在任一时刻只能处于一种状态：    READY → 在 ready_list 中   BLOCKED → 在某个等待队列中   RUNNING → 不在任何队列中   这是互斥的，所以同一个 elem 字段可以安全复用。  Q5: tid_t 为什么是 int 而不是 unsigned int？  答：使用有符号 int 可以用 -1 (TID_ERROR) 表示错误，这是 Unix 系统的常见做法。    练习思考          计算题：假设 struct thread 占用 64 字节（含 USERPROG），那么内核栈最多可以使用多少字节？           设计题：如果想让每个线程有 8KB 的栈空间，需要修改哪些地方？           分析题：如果没有 magic 字段，栈溢出会导致什么后果？           扩展题：如何实现一个函数 thread_stack_usage()，返回当前线程已使用的栈空间？           思考题：为什么 Pintos 不使用 current_thread 全局变量来保存当前线程指针，而要每次通过栈指针计算？        下一步  理解了线程结构后，下一篇文档将介绍线程的生命周期，包括状态转换和各状态的含义。"
  },
  
  {
    "title": "Pintos 线程系统详解（零）：系列概述",
    "url": "/posts/pintos-thread-00-overview/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 线程, 并发",
    "date": "2026-01-26 00:00:00 +0800",
    "content": "概述  这是一个针对 Pintos 操作系统线程子系统的详细分析文档系列。Pintos 的线程系统是整个操作系统的核心，它提供了：     线程抽象：将执行流封装为可调度的单元   上下文切换：在不同线程间切换 CPU   同步原语：信号量、锁、条件变量   调度机制：决定哪个线程运行     Pintos 线程系统架构  ┌─────────────────────────────────────────────────────────────────┐ │                        应用程序/测试                              │ ├─────────────────────────────────────────────────────────────────┤ │                    线程 API (thread.h)                           │ │  thread_create() | thread_yield() | thread_exit() | ...        │ ├─────────────────────────────────────────────────────────────────┤ │                    同步原语 (synch.h)                            │ │     Semaphore    |      Lock      |    Condition Variable       │ ├─────────────────────────────────────────────────────────────────┤ │                    调度器 (thread.c)                             │ │    schedule()   |   ready_list   |   next_thread_to_run()       │ ├─────────────────────────────────────────────────────────────────┤ │                  上下文切换 (switch.S)                           │ │              switch_threads()  |  switch_entry()                │ ├─────────────────────────────────────────────────────────────────┤ │                    中断系统 (interrupt.c)                        │ │    intr_disable() | intr_enable() | intr_yield_on_return()      │ └─────────────────────────────────────────────────────────────────┘     文档列表                 序号       主题       简介                       1       线程结构       struct thread 详解和内存布局                 2       线程生命周期       线程状态转换和生命周期管理                 3       线程创建       thread_create() 详解                 4       线程调度       schedule() 和调度算法                 5       上下文切换       switch.S 汇编代码详解                 6       阻塞与唤醒       thread_block() 和 thread_unblock()                 7       信号量       计数信号量实现                 8       锁       互斥锁实现                 9       条件变量       条件变量实现                 10       中断处理       中断系统与线程的关系                 11       空闲线程       idle 线程的实现和作用                 12       优先级调度       优先级调度机制             核心概念预览  1. 线程是什么？  线程是 CPU 调度的基本单位。在 Pintos 中，每个线程包含：     执行上下文：寄存器状态、栈指针   管理信息：线程 ID、名称、状态、优先级   栈空间：用于函数调用和局部变量   一个线程 = 执行状态 + 栈空间   2. Pintos 的线程内存模型  Pintos 采用独特的设计：每个线程占用一个 4KB 页。          4 kB ┌─────────────────────────────┐              │                             │              │        Kernel Stack         │              │             │               │              │             │               │              │             ▼               │              │       grows downward        │              │                             │              │                             │              │                             │              │         (unused)            │              │                             │              │                             │              ├─────────────────────────────┤              │           magic             │  &lt;- 用于检测栈溢出              │           name              │              │          status             │              │           tid               │         0 kB └─────────────────────────────┘  &lt;- struct thread 起始   3. 线程状态  stateDiagram-v2     [*] --&gt; BLOCKED : create     BLOCKED --&gt; READY : unblock     READY --&gt; RUNNING : schedule     RUNNING --&gt; READY : yield/时间片耗尽     RUNNING --&gt; BLOCKED : block     RUNNING --&gt; DYING : exit     DYING --&gt; [*] : destroy          BLOCKED : 等待某事件     READY : 准备运行     RUNNING : 正在运行     DYING : 即将销毁   4. 同步原语层次  flowchart TB     CV[\"Condition Variable&lt;br/&gt;(高级别、功能最丰富)\"] --&gt; Lock     Lock[\"Lock&lt;br/&gt;(互斥锁、有所有者)\"] --&gt; Sema     Sema[\"Semaphore&lt;br/&gt;(计数信号量)\"] --&gt; Intr     Intr[\"禁用中断 intr_disable&lt;br/&gt;(最底层保护)\"]               ┌─────────────────────────────────┐             │     禁用中断 (intr_disable)     │             │       (最底层保护)              │             └─────────────────────────────────┘     阅读顺序建议  入门路线（推荐新手）    线程结构 → 2. 线程生命周期 → 3. 线程创建   深入路线    线程调度 → 5. 上下文切换 → 6. 阻塞与唤醒   同步原语路线    信号量 → 8. 锁 → 9. 条件变量   高级话题    中断处理 → 11. 空闲线程 → 12. 优先级调度     每个文档的结构  每个文档都包含以下部分：     概述：本部分内容的作用和意义   原始代码：完整的源代码   前置知识：理解代码所需的背景知识   逐行详解：每一行代码的详细解释   图解/流程图：可视化的执行过程   常见问题：FAQ 解答常见疑惑   练习思考：帮助加深理解的思考题     先决知识  必须掌握  C 语言基础    指针操作   结构体定义和使用   函数指针   宏定义   数据结构    链表操作   栈的概念   有帮助的知识  x86 汇编    寄存器概念（EAX, ESP, EBP 等）   栈操作（push, pop）   函数调用约定   操作系统概念    进程与线程   调度算法   并发与同步     术语表                 术语       英文       解释                       线程       Thread       CPU 调度的基本单位                 上下文       Context       线程的执行状态（寄存器、栈等）                 上下文切换       Context Switch       保存当前线程状态，恢复另一线程状态                 调度器       Scheduler       决定哪个线程运行的组件                 就绪队列       Ready Queue       等待 CPU 的线程队列                 信号量       Semaphore       计数同步原语                 锁       Lock       互斥同步原语                 条件变量       Condition Variable       等待特定条件的同步原语                 中断       Interrupt       打断当前执行的事件                 抢占       Preemption       强制切换当前线程                 时间片       Time Slice       线程运行的最大时间                 优先级       Priority       线程的相对重要性                 原子操作       Atomic Operation       不可分割的操作                 临界区       Critical Section       需要互斥访问的代码段                 死锁       Deadlock       多个线程互相等待的状态             相关源文件                 文件       说明                       threads/thread.c       线程核心实现                 threads/thread.h       线程结构和接口                 threads/switch.S       上下文切换汇编                 threads/switch.h       切换相关定义                 threads/synch.c       同步原语实现                 threads/synch.h       同步原语接口                 threads/interrupt.c       中断处理                 threads/interrupt.h       中断接口                 threads/palloc.c       页分配器                 threads/init.c       内核初始化             学习建议     边读边画            画出 struct thread 内存布局       画出线程状态转换图       画出栈的变化过程           动手调试            使用 GDB 设置断点跟踪执行       打印线程状态变化       观察上下文切换           做练习题            完成每节的思考题       尝试实现优先级调度       分析死锁场景           阅读测试            查看 tests/threads/ 下的测试       理解测试的预期行为       运行测试验证理解             参考资料     Pintos 官方文档            Stanford Pintos Guide           操作系统教材            Operating Systems: Three Easy Pieces (OSTEP)       Operating System Concepts (恐龙书)           x86 参考            Intel 64 and IA-32 Architectures Software Developer’s Manual"
  },
  
  {
    "title": "Pintos Kernel 15 Boot Complete",
    "url": "/posts/pintos-kernel-15-boot-complete/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十五）：启动完成与任务执行  概述  本文档是 Pintos 内核启动系列的最后一篇，详细解析内核启动完成后的任务执行过程。在完成所有初始化工作后，内核需要：     打印启动完成信息   解析并执行命令行指定的操作   正确关闭或重启系统   这一阶段标志着 Pintos 从初始化状态过渡到正常运行状态。  原始代码  pintos_init() 的最后部分  printf (\"Boot complete.\\n\");  if (*argv != NULL) {   /* Run actions specified on kernel command line. */   run_actions (argv); } else {   // TODO: no command line passed to kernel. Run interactively  }  /* Finish up. */ shutdown (); thread_exit ();   run_actions() 函数  /** Executes all of the actions specified in ARGV[]    up to the null pointer sentinel. */ static void run_actions (char **argv)  {   /* An action. */   struct action      {       char *name;                       /* Action name. */       int argc;                         /* # of args, including action name. */       void (*function) (char **argv);   /* Function to execute action. */     };    /* Table of supported actions. */   static const struct action actions[] =      {       {\"run\", 2, run_task}, #ifdef FILESYS       {\"ls\", 1, fsutil_ls},       {\"cat\", 2, fsutil_cat},       {\"rm\", 2, fsutil_rm},       {\"extract\", 1, fsutil_extract},       {\"append\", 2, fsutil_append}, #endif       {NULL, 0, NULL},     };    while (*argv != NULL)     {       const struct action *a;       int i;        /* Find action name. */       for (a = actions; ; a++)         if (a-&gt;name == NULL)           PANIC (\"unknown action `%s' (use -h for help)\", *argv);         else if (!strcmp (*argv, a-&gt;name))           break;        /* Check for required arguments. */       for (i = 1; i &lt; a-&gt;argc; i++)         if (argv[i] == NULL)           PANIC (\"action `%s' requires %d argument(s)\", *argv, a-&gt;argc - 1);        /* Invoke action and advance. */       a-&gt;function (argv);       argv += a-&gt;argc;     } }   run_task() 函数  /** Runs the task specified in ARGV[1]. */ static void run_task (char **argv) {   const char *task = argv[1];      printf (\"Executing '%s':\\n\", task); #ifdef USERPROG   process_wait (process_execute (task)); #else   run_test (task); #endif   printf (\"Execution of '%s' complete.\\n\", task); }   启动完成标志  “Boot complete.” 的意义  当内核打印 “Boot complete.” 时，表示以下所有初始化已完成：  ┌─────────────────────────────────────────────────────────────┐ │                      启动完成检查清单                         │ ├─────────────────────────────────────────────────────────────┤ │ ✓ BSS 段已清零                                               │ │ ✓ 命令行已解析                                               │ │ ✓ 线程系统已初始化                                           │ │ ✓ 控制台已初始化                                             │ │ ✓ 内存系统已初始化（palloc + malloc）                        │ │ ✓ 永久页表已建立                                             │ │ ✓ 中断系统已初始化                                           │ │ ✓ 设备已初始化（定时器、键盘、串口）                          │ │ ✓ 抢占式调度已启动                                           │ │ ✓ 定时器已校准                                               │ │ ✓ 文件系统已初始化（如果启用）                               │ └─────────────────────────────────────────────────────────────┘   启动输出示例  Pintos booting with 4,096 kB RAM... 383 pages available in kernel pool. 383 pages available in user pool. Calibrating timer...  1,234,567 loops/s. Boot complete.   命令行动作系统  动作表结构  struct action  {   char *name;                       /* 动作名称 */   int argc;                         /* 参数数量（包括动作名） */   void (*function) (char **argv);   /* 执行函数 */ };  static const struct action actions[] =  {   {\"run\", 2, run_task},     /* 运行测试或程序 */ #ifdef FILESYS   {\"ls\", 1, fsutil_ls},     /* 列出文件 */   {\"cat\", 2, fsutil_cat},   /* 显示文件内容 */   {\"rm\", 2, fsutil_rm},     /* 删除文件 */   {\"extract\", 1, fsutil_extract},  /* 解压 tar */   {\"append\", 2, fsutil_append},    /* 追加到 tar */ #endif   {NULL, 0, NULL},          /* 哨兵 */ };   动作执行流程  run_actions(argv)     │     │  argv = [\"run\", \"alarm-multiple\", NULL]     │     ↓ ┌─────────────────────────────────────────────────────────────┐ │ while (*argv != NULL)                                       │ │     │                                                       │ │     ├─→ 查找动作名                                          │ │     │   for (a = actions; ...; a++)                        │ │     │       if (!strcmp(*argv, a-&gt;name)) break;            │ │     │                                                       │ │     │   找到: a = {\"run\", 2, run_task}                     │ │     │                                                       │ │     ├─→ 检查参数数量                                        │ │     │   argc = 2, 需要 1 个额外参数                         │ │     │   argv[1] = \"alarm-multiple\" ✓                       │ │     │                                                       │ │     ├─→ 执行动作                                            │ │     │   a-&gt;function(argv)                                   │ │     │   → run_task([\"run\", \"alarm-multiple\"])              │ │     │                                                       │ │     └─→ 前进指针                                            │ │         argv += 2                                           │ │         → argv = [NULL]                                     │ │                                                             │ │ 循环结束，*argv == NULL                                     │ └─────────────────────────────────────────────────────────────┘   命令行示例  运行测试： pintos -- run alarm-multiple  解析后的 argv： [\"run\", \"alarm-multiple\", NULL]   运行用户程序： pintos -- run 'echo hello world'  解析后的 argv： [\"run\", \"echo hello world\", NULL]   多个动作： pintos -- ls cat README run test  解析后的 argv： [\"ls\", \"cat\", \"README\", \"run\", \"test\", NULL]   执行顺序：    ls（无参数）   cat README   run test   测试运行（非用户程序模式）  run_test() 函数  当 USERPROG 未定义时，run_task 调用 run_test()：  /* tests/threads/tests.c */  static const struct test tests[] =  {   {\"alarm-single\", test_alarm_single},   {\"alarm-multiple\", test_alarm_multiple},   {\"alarm-simultaneous\", test_alarm_simultaneous},   {\"alarm-priority\", test_alarm_priority},   {\"alarm-zero\", test_alarm_zero},   {\"alarm-negative\", test_alarm_negative},   {\"priority-change\", test_priority_change},   /* ... 更多测试 ... */   {NULL, NULL}, };  void run_test (const char *name)  {   const struct test *t;    for (t = tests; t-&gt;name != NULL; t++)     if (!strcmp (name, t-&gt;name))       {         t-&gt;function ();         return;       }   PANIC (\"no test named \\\"%s\\\"\", name); }   测试执行流程  run_task([\"run\", \"alarm-multiple\"])     │     ↓ run_test(\"alarm-multiple\")     │     ├─→ 在测试表中查找     │     ├─→ 找到 test_alarm_multiple     │     └─→ 调用 test_alarm_multiple()             │             ├─→ 创建多个测试线程             │             ├─→ 每个线程调用 timer_sleep()             │             ├─→ 等待所有线程完成             │             └─→ 检查结果   用户程序执行（USERPROG 模式）  process_execute() 流程  /* userprog/process.c */  tid_t process_execute (const char *file_name)  {   char *fn_copy;   tid_t tid;    /* Make a copy of FILE_NAME. */   fn_copy = palloc_get_page (0);   if (fn_copy == NULL)     return TID_ERROR;   strlcpy (fn_copy, file_name, PGSIZE);    /* Create a new thread to execute FILE_NAME. */   tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);   if (tid == TID_ERROR)     palloc_free_page (fn_copy);    return tid; }   用户程序加载和执行  process_execute(\"echo hello world\")     │     ├─→ 复制文件名到新页     │     ├─→ thread_create(\"echo\", PRI_DEFAULT, start_process, fn_copy)     │       │     │       └─→ 创建新线程，入口为 start_process     │     └─→ 返回线程 ID  新线程执行: start_process(fn_copy)     │     ├─→ 解析命令行（\"echo hello world\"）     │     ├─→ 加载可执行文件 \"echo\"     │   │     │   ├─→ 打开文件     │   ├─→ 验证 ELF 头     │   ├─→ 加载程序段到内存     │   └─→ 设置入口点     │     ├─→ 设置用户栈     │   │     │   ├─→ 压入参数字符串     │   ├─→ 压入参数指针数组     │   └─→ 压入 argc 和 argv     │     └─→ 跳转到用户空间执行         │         └─→ intr_exit() 返回到用户程序入口   process_wait() 等待子进程  int process_wait (tid_t child_tid)  {   /* 等待子进程退出 */   /* 返回子进程的退出状态 */ }   主线程执行流：  run_task()     │     ├─→ process_execute(\"echo hello world\")     │       │     │       └─→ 返回子进程 tid     │     └─→ process_wait(tid)             │             ├─→ 阻塞等待子进程退出             │             └─→ 子进程退出后，返回退出状态   系统关闭  shutdown() 函数  /* devices/shutdown.c */  static enum shutdown_type how = SHUTDOWN_NONE;  void shutdown (void) {   switch (how)     {     case SHUTDOWN_POWER_OFF:       shutdown_power_off ();       break;            case SHUTDOWN_REBOOT:       shutdown_reboot ();       break;            default:       /* 默认不关机，只是退出 */       break;     } }  void shutdown_configure (enum shutdown_type new_how) {   how = new_how; }   关机方式  关机（Power Off）： void shutdown_power_off (void)  {   printf (\"Powering off...\\n\");      /* ACPI 关机 */   outw (0xB004, 0x2000);  /* Bochs/QEMU */   outw (0x604, 0x2000);   /* QEMU 新版本 */      /* 如果上面不工作，尝试 APM */   outb (0x8900, 'S');   outb (0x8900, 'h');   outb (0x8900, 'u');   outb (0x8900, 't');   outb (0x8900, 'd');   outb (0x8900, 'o');   outb (0x8900, 'w');   outb (0x8900, 'n');      /* 如果还不工作，死循环 */   for (;;); }   重启（Reboot）： void shutdown_reboot (void) {   printf (\"Rebooting...\\n\");      /* 通过 8042 键盘控制器重启 */   outb (0x64, 0xFE);      /* 如果不工作，三重错误重启 */   for (;;); }   命令行关机选项  # 执行完任务后关机 pintos -q -- run alarm-multiple  # 执行完任务后重启 pintos -r -- run alarm-multiple   对应的命令行解析：  else if (!strcmp (name, \"-q\"))   shutdown_configure (SHUTDOWN_POWER_OFF); else if (!strcmp (name, \"-r\"))   shutdown_configure (SHUTDOWN_REBOOT);   主线程退出  thread_exit() 分析  void thread_exit (void)  {   ASSERT (!intr_context ());  #ifdef USERPROG   process_exit (); #endif    /* Remove thread from all threads list, set our status to dying,      and schedule another process.  That process will destroy us      when it calls thread_schedule_tail(). */   intr_disable ();   list_remove (&amp;thread_current()-&gt;allelem);   thread_current ()-&gt;status = THREAD_DYING;   schedule ();   NOT_REACHED (); }   退出流程：  thread_exit()     │     ├─→ 关中断     │     ├─→ 从 all_list 移除当前线程     │     ├─→ 设置状态为 THREAD_DYING     │     └─→ schedule()             │             └─→ 切换到其他线程                 │                 └─→ 其他线程的 thread_schedule_tail()                         │                         └─→ 释放 DYING 线程的内存页                          NOT_REACHED()  // 永远不会执行到这里   为什么主线程要 thread_exit()？     资源回收：释放主线程占用的内存   调度器运行：让空闲线程或其他线程接管 CPU   正确终止：避免执行未定义的代码   完整启动到关机流程  ┌─────────────────────────────────────────────────────────────────┐ │                        Pintos 生命周期                           │ ├─────────────────────────────────────────────────────────────────┤ │                                                                 │ │  1. 电源开启                                                     │ │     │                                                           │ │     ↓                                                           │ │  2. BIOS 执行                                                    │ │     │                                                           │ │     ↓                                                           │ │  3. Loader 加载内核                                              │ │     │                                                           │ │     ↓                                                           │ │  4. start.S 执行                                                 │ │     │                                                           │ │     ├─→ 实模式初始化                                            │ │     ├─→ 进入保护模式                                            │ │     └─→ 跳转到 pintos_init                                      │ │                                                                 │ │  5. pintos_init() 执行                                          │ │     │                                                           │ │     ├─→ 初始化各子系统                                          │ │     │   ├─→ BSS 清零                                            │ │     │   ├─→ 命令行解析                                          │ │     │   ├─→ 线程系统                                            │ │     │   ├─→ 内存系统                                            │ │     │   ├─→ 中断系统                                            │ │     │   └─→ 设备初始化                                          │ │     │                                                           │ │     ├─→ \"Boot complete.\"                                        │ │     │                                                           │ │     ├─→ run_actions()                                           │ │     │   │                                                       │ │     │   └─→ 执行命令行指定的任务                                │ │     │       │                                                   │ │     │       ├─→ run (测试或用户程序)                           │ │     │       ├─→ ls, cat, rm (文件操作)                         │ │     │       └─→ ...                                             │ │     │                                                           │ │     ├─→ shutdown()                                              │ │     │   │                                                       │ │     │   ├─→ -q: 关机                                            │ │     │   └─→ -r: 重启                                            │ │     │                                                           │ │     └─→ thread_exit()                                           │ │                                                                 │ │  6. 空闲线程运行                                                 │ │     │                                                           │ │     └─→ hlt 等待中断（直到关机/重启）                           │ │                                                                 │ └─────────────────────────────────────────────────────────────────┘   调试支持  帮助信息  static void usage (void) {   printf (\"\\nCommand line syntax: [OPTION...] [ACTION...]\\n\"           \"Options must precede actions.\\n\"           \"Actions are executed in the order specified.\\n\"           \"\\nAvailable actions:\\n\" #ifdef USERPROG           \"  run 'PROG [ARG...]' Run PROG and wait for it to complete.\\n\" #else           \"  run TEST           Run TEST.\\n\" #endif #ifdef FILESYS           \"  ls                 List files in the root directory.\\n\"           \"  cat FILE           Print FILE to the console.\\n\"           \"  rm FILE            Delete FILE.\\n\"           /* ... */ #endif           \"\\nOptions:\\n\"           \"  -h                 Print this help message and power off.\\n\"           \"  -q                 Power off VM after actions or on panic.\\n\"           /* ... */           );   shutdown_power_off (); }   使用 -h 查看帮助： pintos -- -h   调试输出  Boot 过程的关键输出：  Pintos booting with 4,096 kB RAM...       ← 内存检测 383 pages available in kernel pool.       ← 页分配器 383 pages available in user pool. Calibrating timer...  1,234,567 loops/s.  ← 定时器校准 Boot complete.                            ← 启动完成 Executing 'alarm-multiple':               ← 开始执行任务 (alarm-multiple) ...                      ← 任务输出 Execution of 'alarm-multiple' complete.   ← 任务完成 Powering off...                           ← 关机   统计信息打印  print_stats() 函数  /* 在关机前打印各种统计信息 */ void print_stats (void) {   timer_print_stats ();    /* 定时器统计 */   thread_print_stats ();   /* 线程统计 */   kbd_print_stats ();      /* 键盘统计 */   console_print_stats ();  /* 控制台统计 */ }   输出示例：  Timer: 1234567 ticks Thread: 1000 idle ticks, 234567 kernel ticks, 0 user ticks Keyboard: 0 keys pressed Console: 5678 characters output   常见问题解答  Q1: 如果不传任何动作会怎样？  A: if (*argv != NULL) {   run_actions (argv); } else {   // TODO: no command line passed to kernel. Run interactively  }  当前实现中，如果没有动作，内核会直接调用 shutdown() 和 thread_exit()，相当于什么都不做就关机。  Q2: run_actions 可以执行多个动作吗？  A: 是的，动作按顺序执行： pintos -- ls cat README run test  会依次执行：ls → cat README → run test  Q3: 为什么 thread_exit() 后还有 NOT_REACHED()？  A:    thread_exit() 调用 schedule() 后永不返回   NOT_REACHED() 是断言，如果执行到说明有 bug   它会触发 PANIC，帮助调试   Q4: 关机失败会怎样？  A:    shutdown_power_off() 尝试多种关机方法   如果都失败，进入无限循环   在真实硬件上可能需要手动关电源   在模拟器中通常不会失败   练习题  练习1：添加新动作  添加一个 “hello” 动作，打印 “Hello, Pintos!”：  static void say_hello (char **argv UNUSED) {   printf (\"Hello, Pintos!\\n\"); }   需要修改哪些代码？  练习2：交互模式  实现简单的交互模式，当没有命令行参数时：    打印提示符   从键盘读取命令   执行命令   重复   提示：使用 input_getc() 读取键盘输入。  练习3：启动时间测量  在 pintos_init() 中添加代码，测量并打印从启动到 “Boot complete.” 的时间。  提示：使用 timer_ticks() 和 TIMER_FREQ。  练习4：分析启动瓶颈  修改内核，打印每个初始化阶段花费的时间： BSS init: 1 ticks Thread init: 5 ticks Memory init: 10 ticks ... Total boot time: 100 ticks   系列总结  恭喜你完成了 Pintos 内核启动系列的所有文档！让我们回顾一下整个启动流程：  启动阶段概览                 文档       阶段       主要内容                       00       概述       系列介绍和整体架构                 01-06       start.S       汇编启动代码                 07-09       pintos_init       C 初始化入口                 10-11       内存       页分配器和页表                 12       线程       线程系统初始化                 13       中断       中断系统初始化                 14       设备       硬件设备初始化                 15       完成       任务执行和关机           关键概念     实模式到保护模式：x86 启动的根本转换   页表和虚拟内存：内存管理的基础   线程和调度：并发执行的基础   中断处理：响应硬件事件   设备驱动：与硬件交互   后续学习建议     Project 1 (Threads)：深入理解线程调度   Project 2 (User Programs)：理解用户/内核分离   Project 3 (Virtual Memory)：实现完整的虚拟内存   Project 4 (File Systems)：实现持久化存储   参考资料     Pintos Documentation   Intel 64 and IA-32 Architectures Software Developer’s Manual   OSDev Wiki   xv6: A Simple, Unix-like Teaching Operating System"
  },
  
  {
    "title": "Pintos Kernel 14 Device Init",
    "url": "/posts/pintos-kernel-14-device-init/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十四）：设备初始化  概述  本文档详细解析 Pintos 内核的设备初始化过程。在中断系统初始化完成后，内核需要初始化各种硬件设备，使它们能够正常工作。Pintos 涉及的主要设备包括：     定时器（Timer）：提供时间基准和周期性中断   键盘（Keyboard）：处理用户输入   串口（Serial Port）：用于调试输出和通信   控制台（Console）：管理屏幕输出   这些设备的初始化顺序是精心设计的，确保系统能够正确响应硬件事件。  初始化顺序  /* pintos_init() 中的设备初始化顺序 */  /* Initialize interrupt handlers. */ intr_init ();        // 中断系统 timer_init ();       // 定时器 kbd_init ();         // 键盘 input_init ();       // 输入缓冲区  /* Start thread scheduler and enable interrupts. */ thread_start ();     // 启动调度（开中断） serial_init_queue ();// 串口队列模式 timer_calibrate ();  // 定时器校准   初始化时序图：  时间轴 ────────────────────────────────────────────────────→  中断关闭                           │  中断开启 ─────────────────────────────────│───────────────────────────                                   │ intr_init()                       │     │                             │     ├─→ pic_init()               │     │                             │     └─→ 加载 IDT                  │                                   │ timer_init()                      │     │                             │     └─→ 配置 PIT                  │         注册定时器中断            │                                   │ kbd_init()                        │     │                             │     └─→ 注册键盘中断              │                                   │ input_init()                      │     │                             │     └─→ 初始化输入队列            │                                   │                               thread_start()                                   │                                   ├─→ 创建空闲线程                                   │                                   └─→ intr_enable()                                         │                                         ↓ 中断开始被处理                                                                        serial_init_queue()                                   │                                   └─→ 启用串口中断                                                                  timer_calibrate()                                   │                                   └─→ 测量 CPU 速度   定时器初始化  原始代码  /* timer.c */  /** Number of timer ticks since OS booted. */ static int64_t ticks;  /** Sets up the timer to interrupt TIMER_FREQ times per second,    and registers the corresponding interrupt. */ void timer_init (void)  {   pit_configure_channel (0, 2, TIMER_FREQ);   intr_register_ext (0x20, timer_interrupt, \"8254 Timer\"); }  /* pit.c */  /** 8254 registers. */ #define PIT_PORT_CONTROL          0x43 #define PIT_PORT_COUNTER(CHANNEL) (0x40 + (CHANNEL))  /** PIT cycles per second. */ #define PIT_HZ 1193180  void pit_configure_channel (int channel, int mode, int frequency) {   uint16_t count;   enum intr_level old_level;    ASSERT (channel == 0 || channel == 2);   ASSERT (mode == 2 || mode == 3);    /* Convert FREQUENCY to a PIT counter value. */   if (frequency &lt; 19)     count = 0;   else if (frequency &gt; PIT_HZ)     count = 2;   else     count = (PIT_HZ + frequency / 2) / frequency;    /* Configure the PIT. */   old_level = intr_disable ();   outb (PIT_PORT_CONTROL, ((channel &lt;&lt; 6) | 0x30 | (mode &lt;&lt; 1)));   outb (PIT_PORT_COUNTER (channel), count);   outb (PIT_PORT_COUNTER (channel), count &gt;&gt; 8);   intr_set_level (old_level); }   8254 PIT 硬件架构                      ┌───────────────────────────────────────┐                     │           8254 PIT                    │                     │                                       │   时钟输入 ─────────┼─→ CLK (1.193180 MHz)                  │   (1.193180 MHz)    │                                       │                     │ ┌─────────────┐ ┌─────────────┐       │                     │ │  Channel 0  │ │  Channel 1  │       │                     │ │             │ │             │       │                     │ │ 计数器      │ │ 计数器      │       │                     │ │             │ │   (DRAM)    │       │                     │ │ OUT0 ───────┼─┼─────────────┼─→ IRQ0 (定时器中断)                     │ └─────────────┘ └─────────────┘       │                     │                                       │                     │ ┌─────────────┐                       │                     │ │  Channel 2  │                       │                     │ │             │                       │                     │ │ 计数器      │                       │                     │ │             │                       │                     │ │ OUT2 ───────┼───────────────────→ Speaker                     │ └─────────────┘                       │                     │                                       │ 端口 0x40-0x43 ────┼─→ 控制/数据                           │                     └───────────────────────────────────────┘   PIT 配置详解  pit_configure_channel() 参数计算：  /* TIMER_FREQ = 100 Hz (每秒 100 次中断) */ /* PIT_HZ = 1193180 Hz */  count = PIT_HZ / TIMER_FREQ       = 1193180 / 100       = 11932 (约)  /* 实际频率 = 1193180 / 11932 ≈ 100.007 Hz */   控制字格式（端口 0x43）：  位 7-6: 通道选择 (00=Ch0, 01=Ch1, 10=Ch2) 位 5-4: 访问模式 (11=先低后高) 位 3-1: 工作模式 (010=Mode 2, 011=Mode 3) 位 0:   BCD/二进制 (0=二进制)  对于 Channel 0, Mode 2: (0 &lt;&lt; 6) | 0x30 | (2 &lt;&lt; 1) = 0x34   Mode 2（速率发生器）工作原理：  计数值 = 11932  时间轴 ─────────────────────────────────────────────→          │←────── 11932 个时钟周期 ──────→│          │                                │ OUT ─────┘                               ┌┘          ↑                               ↑       计数开始                        计数到0       (输出变高)                      (脉冲，输出变低，然后立即变高)                                       同时重新加载计数值   timer_init() 流程  timer_init()     │     ├─→ pit_configure_channel(0, 2, TIMER_FREQ)     │   │     │   ├─→ 计算 count = 11932     │   │     │   ├─→ 关中断（防止配置过程中产生中断）     │   │     │   ├─→ outb(0x43, 0x34)  // 控制字     │   │     │   ├─→ outb(0x40, 11932 &amp; 0xFF)  // 计数值低字节     │   │     │   ├─→ outb(0x40, 11932 &gt;&gt; 8)    // 计数值高字节     │   │     │   └─→ 恢复中断状态     │     └─→ intr_register_ext(0x20, timer_interrupt, \"8254 Timer\")         │         └─→ 注册中断处理程序             向量号 = 0x20 (IRQ0)             处理函数 = timer_interrupt   定时器中断处理  /** Timer interrupt handler. */ static void timer_interrupt (struct intr_frame *args UNUSED) {   ticks++;   thread_tick (); }   每次定时器中断执行的操作：     增加 ticks：全局计时器，记录系统运行的时钟周期数   thread_tick()：            更新线程统计信息       检查时间片是否用完       如果用完，设置 yield_on_return           void thread_tick (void)  {   struct thread *t = thread_current ();    /* Update statistics. */   if (t == idle_thread)     idle_ticks++;   else if (t-&gt;pagedir != NULL)     user_ticks++;   else     kernel_ticks++;    /* Enforce preemption. */   if (++thread_ticks &gt;= TIME_SLICE)     intr_yield_on_return (); }   定时器校准  void timer_calibrate (void)  {   unsigned high_bit, test_bit;    ASSERT (intr_get_level () == INTR_ON);   printf (\"Calibrating timer...  \");    /* Approximate loops_per_tick as the largest power-of-two      still less than one timer tick. */   loops_per_tick = 1u &lt;&lt; 10;   while (!too_many_loops (loops_per_tick &lt;&lt; 1))      {       loops_per_tick &lt;&lt;= 1;       ASSERT (loops_per_tick != 0);     }    /* Refine the next 8 bits of loops_per_tick. */   high_bit = loops_per_tick;   for (test_bit = high_bit &gt;&gt; 1; test_bit != high_bit &gt;&gt; 10; test_bit &gt;&gt;= 1)     if (!too_many_loops (high_bit | test_bit))       loops_per_tick |= test_bit;    printf (\"%'\"PRIu64\" loops/s.\\n\", (uint64_t) loops_per_tick * TIMER_FREQ); }   校准目的：     测量 CPU 在一个时钟周期内能执行多少次空循环   用于实现 timer_mdelay() 等忙等待函数   在不同速度的 CPU 上提供一致的延迟   校准算法：  1. 初始值 = 1024 (2^10)  2. 二分查找最大值：    while (loops_per_tick * 2 &lt; 一个 tick 的循环数)        loops_per_tick *= 2        结果：找到最大的 2 的幂次  3. 精细调整（8位精度）：    逐位测试，得到更精确的值  示例输出： Calibrating timer...  1,234,567 loops/s.   键盘初始化  原始代码  /* kbd.c */  /** Keyboard data register port. */ #define DATA_REG 0x60  static intr_handler_func keyboard_interrupt;  /** Initializes the keyboard. */ void kbd_init (void)  {   intr_register_ext (0x21, keyboard_interrupt, \"8042 Keyboard\"); }   8042 键盘控制器  ┌─────────────────────────────────────────────────────────────┐ │                     8042 键盘控制器                          │ │                                                             │ │  ┌─────────────┐                      ┌─────────────────┐  │ │  │   输入缓冲   │ ◄── 端口 0x60 写 ◄── │  CPU 命令       │  │ │  └─────────────┘                      └─────────────────┘  │ │          │                                                  │ │          ↓                                                  │ │  ┌─────────────┐                                           │ │  │   控制器     │                                           │ │  └─────────────┘                                           │ │          │                                                  │ │          ↓                                                  │ │  ┌─────────────┐                      ┌─────────────────┐  │ │  │   输出缓冲   │ ─→ 端口 0x60 读 ─→  │  CPU 接收数据   │  │ │  └─────────────┘                      └─────────────────┘  │ │          │                                                  │ │          ↓                                                  │ │      IRQ1 (向量 0x21)                                       │ │                                                             │ └─────────────────────────────────────────────────────────────┘             ↑             │ PS/2 协议             ↓       ┌─────────────┐       │   键盘      │       └─────────────┘   键盘中断处理  static void keyboard_interrupt (struct intr_frame *args UNUSED)  {   /* Must read scancode to clear interrupt. */   uint8_t scancode = inb (DATA_REG);      /* 处理扫描码 */   if (scancode &amp; 0x80) {     /* 按键释放 */     scancode &amp;= ~0x80;     handle_key_release (scancode);   } else {     /* 按键按下 */     handle_key_press (scancode);   } }   扫描码到字符的转换：  扫描码 → 查表 → ASCII 字符  示例： 扫描码 0x1E = 'A' (无 Shift) 扫描码 0x1E + Shift = 'A' (有 Shift) 扫描码 0x9E = 'A' 释放 (0x1E | 0x80)   输入缓冲区  /* input.c */  /** Stores a character in the input buffer. */ void input_putc (uint8_t key) {   ASSERT (intr_get_level () == INTR_OFF);   if (!intq_full (&amp;buffer))     intq_putc (&amp;buffer, key); }  /** Retrieves a character from the input buffer. */ uint8_t input_getc (void)  {   enum intr_level old_level;   uint8_t key;    old_level = intr_disable ();   key = intq_getc (&amp;buffer);   intr_set_level (old_level);      return key; }   缓冲区结构：                写入 (中断上下文)                    │                    ↓          ┌─────────────────────────────┐ buffer:  │ a │ b │ c │   │   │   │   │ │          └─────────────────────────────┘            ↑                       ↑           head                    tail            │            └── 读取 (进程上下文)   串口初始化  原始代码  /* serial.c */  /** I/O port base address for the first serial port. */ #define IO_BASE 0x3f8  /** Transmission mode. */ static enum { UNINIT, POLL, QUEUE } mode;  /** Initializes the serial port device for polling mode. */ static void init_poll (void)  {   ASSERT (mode == UNINIT);   outb (IER_REG, 0);                    /* Turn off all interrupts. */   outb (FCR_REG, 0);                    /* Disable FIFO. */   set_serial (9600);                    /* 9.6 kbps, N-8-1. */   outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */   intq_init (&amp;txq);   mode = POLL; }   /** Initializes the serial port device for queued mode. */ void serial_init_queue (void)  {   enum intr_level old_level;    if (mode == UNINIT)     init_poll ();   ASSERT (mode == POLL);    intr_register_ext (0x24, serial_interrupt, \"16550A Serial\");   mode = QUEUE;   old_level = intr_disable ();   write_ier ();   intr_set_level (old_level); }   16550A UART 寄存器  ┌─────────────────────────────────────────────────────────────────┐ │                      16550A UART                                │ │                                                                 │ │  端口 0x3F8 (DLAB=0):                                           │ │    读: RBR (接收缓冲)     写: THR (发送保持)                    │ │                                                                 │ │  端口 0x3F9 (DLAB=0):                                           │ │    读/写: IER (中断使能)                                        │ │                                                                 │ │  端口 0x3F8 (DLAB=1):                                           │ │    读/写: DLL (除数锁存低字节)                                  │ │                                                                 │ │  端口 0x3F9 (DLAB=1):                                           │ │    读/写: DLM (除数锁存高字节)                                  │ │                                                                 │ │  端口 0x3FA:                                                    │ │    读: IIR (中断识别)     写: FCR (FIFO 控制)                   │ │                                                                 │ │  端口 0x3FB: LCR (线路控制)                                     │ │  端口 0x3FC: MCR (调制解调器控制)                               │ │  端口 0x3FD: LSR (线路状态) [只读]                              │ │                                                                 │ └─────────────────────────────────────────────────────────────────┘   串口配置  static void set_serial (int bps) {   int base_rate = 1843200 / 16;   uint16_t divisor = base_rate / bps;    ASSERT (googol &gt;= 300 &amp;&amp; bps &lt;= 115200);    /* Enable DLAB. */   outb (LCR_REG, LCR_DLAB);    /* Set data rate. */   outb (LS_REG, divisor &amp; 0xff);   outb (MS_REG, divisor &gt;&gt; 8);    /* Reset DLAB, set N-8-1. */   outb (LCR_REG, LCR_N81); }   波特率计算：  基准频率 = 1843200 Hz / 16 = 115200 Hz 除数 = 115200 / 目标波特率  9600 bps: 除数 = 115200 / 9600 = 12   串口模式                 模式       描述       使用场景                       UNINIT       未初始化       系统启动初期                 POLL       轮询模式       中断未启用时                 QUEUE       队列模式       正常运行时           轮询模式 vs 队列模式：  轮询模式：   serial_putc()       │       └─→ 循环等待 THR 空           │           └─→ 写入字符到 THR  队列模式：   serial_putc()       │       └─→ 写入字符到发送队列           │           └─→ 启用发送中断               │               ↓ (中断触发时)           serial_interrupt()               │               └─→ 从队列取字符写入 THR   控制台初始化  原始代码  /* console.c */  static struct lock console_lock;  void console_init (void)  {   lock_init (&amp;console_lock); }  void console_print_stats (void)  {   printf (\"Console: %lld characters output\\n\", write_cnt); }   控制台输出路径  printf() / putchar()         │         ↓     console_lock         │         ↓    ┌────┴────┐    │         │    ↓         ↓   VGA     Serial (屏幕)    (串口)   多设备输出：  /* console.c */ static void putchar_unlocked (uint8_t c)  {   if (vga_write_to_screen)     vga_putc (c);   if (serial_write_to_serial)     serial_putc (c);   write_cnt++; }   VGA 初始化  原始代码  /* vga.c */  /** VGA text screen support. */  /** Number of columns and rows on the text display. */ #define COL_CNT 80 #define ROW_CNT 25  /** Current cursor position. */ static size_t cx, cy;  void vga_init (void) {   /* 通常不需要特别初始化 */   /* BIOS 已经设置好文本模式 */ }   VGA 文本模式  VGA 显存地址: 0xB8000  ┌────────────────────────────────────────────────────────────┐ │                     屏幕 (80x25)                            │ │                                                            │ │  每个字符占 2 字节:                                         │ │  ┌─────────┬─────────┐                                     │ │  │ 字符    │ 属性    │                                     │ │  │ (ASCII) │ (颜色)  │                                     │ │  └─────────┴─────────┘                                     │ │                                                            │ │  属性字节:                                                  │ │  ┌───┬───┬───┬───┬───┬───┬───┬───┐                        │ │  │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │                        │ │  │ B │ R │ G │ B │ I │ R │ G │ B │                        │ │  │ ← 背景色  →│← 前景色    →│                              │ │  └───┴───┴───┴───┴───┴───┴───┴───┘                        │ │                                                            │ │  B=闪烁, I=高亮, R=红, G=绿, B=蓝                          │ │                                                            │ └────────────────────────────────────────────────────────────┘   VGA 输出函数  void vga_putc (int c) {   /* 处理特殊字符 */   if (c == '\\n') {     newline ();   } else if (c == '\\r') {     cx = 0;   } else if (c == '\\t') {     do {       vga_putc (' ');     } while (cx % 8 != 0);   } else if (c == '\\b') {     if (cx &gt; 0)       cx--;   } else {     /* 普通字符 */     write_char (c);     if (++cx &gt;= COL_CNT) {       newline ();     }   }      /* 更新硬件光标 */   move_cursor (); }   设备初始化时序  完整初始化流程  pintos_init()     │     ├─→ bss_init()          // BSS 清零     │     ├─→ read_command_line() // 读取命令行     │     ├─→ thread_init()       // 线程系统     │     ├─→ console_init()      // 控制台锁     │       │     │       └─→ 此时 printf 可用（轮询模式）     │     ├─→ palloc_init()       // 页分配器     │     ├─→ malloc_init()       // 块分配器     │     ├─→ paging_init()       // 永久页表     │     ├─→ intr_init()         // 中断系统     │       │     │       ├─→ pic_init()     │       │     │       └─→ 加载 IDT     │     ├─→ timer_init()        // 定时器     │       │     │       └─→ 注册 IRQ0 (0x20)     │     ├─→ kbd_init()          // 键盘     │       │     │       └─→ 注册 IRQ1 (0x21)     │     ├─→ input_init()        // 输入缓冲     │     ├─→ thread_start()      // 开始调度     │       │     │       ├─→ 创建空闲线程     │       │     │       └─→ intr_enable()  ← 中断开始被处理     │     ├─→ serial_init_queue() // 串口队列模式     │       │     │       └─→ 注册 IRQ4 (0x24)     │     └─→ timer_calibrate()   // 校准定时器             │             └─→ 测量 loops_per_tick   中断优先级  PIC 默认中断优先级（数字越小优先级越高）：                 IRQ       向量       设备       优先级                       0       0x20       定时器       1（最高）                 1       0x21       键盘       2                 2       0x22       级联       3                 3       0x23       COM2       4                 4       0x24       COM1       5                 …       …       …       …           常见问题解答  Q1: 为什么定时器要在中断开启前初始化？  A:    配置 PIT 需要写多个端口，必须是原子操作   关中断状态下配置可以防止配置过程中产生中断   注册中断处理程序不需要中断开启   Q2: 为什么串口有两种模式？  A:    轮询模式：系统启动早期，中断未初始化   队列模式：正常运行，不浪费 CPU 等待   Q3: timer_calibrate 必须在中断开启后吗？  A:    是的，需要定时器中断来测量时间   通过等待 ticks 变化来确定循环次数   Q4: 键盘初始化为什么如此简单？  A:    8042 控制器由 BIOS 初始化   只需要注册中断处理程序   键盘硬件已经准备好发送扫描码   练习题  练习1：修改定时器频率  将 TIMER_FREQ 从 100 Hz 改为 1000 Hz：    需要修改哪些代码？   这对系统有什么影响？   练习2：实现键盘 LED 控制  实现函数控制键盘 LED（Caps Lock, Num Lock, Scroll Lock）：  void kbd_set_leds(bool caps, bool num, bool scroll);   提示：向 8042 发送命令 0xED。  练习3：串口接收  当前代码主要关注串口输出。添加串口输入支持：    在串口中断中处理接收   将接收到的字符放入输入缓冲区   练习4：计算实际定时器频率  给定 PIT_HZ = 1193180 和 TIMER_FREQ = 100：    计算实际的中断频率   计算一小时后的时间误差   下一篇预告  在下一篇文档中，我们将详细解析启动完成和任务执行过程，了解 Pintos 如何从初始化阶段过渡到正常运行，以及如何执行用户指定的命令。  参考资料     Intel 8254 Programmable Interval Timer Datasheet   8042 PS/2 Controller   16550 UART   VGA Hardware"
  },
  
  {
    "title": "Pintos Kernel 13 Interrupt Init",
    "url": "/posts/pintos-kernel-13-interrupt-init/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十三）：中断系统初始化  概述  本文档详细解析 Pintos 内核的中断系统初始化过程 intr_init()。中断是操作系统响应外部事件和处理异常的核心机制。正确初始化中断系统是操作系统能够响应硬件事件（如定时器、键盘）和处理软件异常（如除零错误、缺页）的前提。  Pintos 的中断系统涉及以下关键组件：    IDT（Interrupt Descriptor Table）：中断描述符表，存储中断处理程序的入口   PIC（Programmable Interrupt Controller）：可编程中断控制器，管理硬件中断   中断处理函数：实际处理中断的 C 代码   原始代码  interrupt.c 中的 intr_init() 函数  /** Initializes the interrupt system. */ void intr_init (void) {   uint64_t idtr_operand;   int i;    /* Initialize interrupt controller. */   pic_init ();    /* Initialize IDT. */   for (i = 0; i &lt; INTR_CNT; i++)     idt[i] = make_intr_gate (intr_stubs[i], 0);    /* Load IDT register.      See [IA32-v2a] \"LIDT\" and [IA32-v3a] 5.10 \"Interrupt      Descriptor Table (IDT)\". */   idtr_operand = make_idtr_operand (sizeof idt - 1, idt);   asm volatile (\"lidt %0\" : : \"m\" (idtr_operand));    /* Initialize intr_names. */   for (i = 0; i &lt; INTR_CNT; i++)     intr_names[i] = \"unknown\";   intr_names[0] = \"#DE Divide Error\";   intr_names[1] = \"#DB Debug Exception\";   intr_names[2] = \"NMI Interrupt\";   intr_names[3] = \"#BP Breakpoint Exception\";   intr_names[4] = \"#OF Overflow Exception\";   intr_names[5] = \"#BR BOUND Range Exceeded Exception\";   intr_names[6] = \"#UD Invalid Opcode Exception\";   intr_names[7] = \"#NM Device Not Available Exception\";   intr_names[8] = \"#DF Double Fault Exception\";   intr_names[9] = \"Coprocessor Segment Overrun\";   intr_names[10] = \"#TS Invalid TSS Exception\";   intr_names[11] = \"#NP Segment Not Present\";   intr_names[12] = \"#SS Stack Fault Exception\";   intr_names[13] = \"#GP General Protection Exception\";   intr_names[14] = \"#PF Page-Fault Exception\";   intr_names[16] = \"#MF x87 FPU Floating-Point Error\";   intr_names[17] = \"#AC Alignment Check Exception\";   intr_names[18] = \"#MC Machine-Check Exception\";   intr_names[19] = \"#XF SIMD Floating-Point Exception\"; }   pic_init() 函数  /** Initializes the PICs.  Refer to [8259A] for details.     By default, interrupts 0...15 delivered by the PICs will go to    interrupt vectors 0...15.  Those vectors are also used for CPU    traps and exceptions, so we reprogram the PICs so that    interrupts 0...15 are delivered to interrupt vectors 32...47    (0x20...0x2f) instead. */ static void pic_init (void) {   /* Mask all interrupts on both PICs. */   outb (PIC0_DATA, 0xff);   outb (PIC1_DATA, 0xff);    /* Initialize master. */   outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */   outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -&gt; irq 0x20...0x27. */   outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */   outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */    /* Initialize slave. */   outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */   outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -&gt; irq 0x28...0x2f. */   outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */   outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */    /* Unmask all interrupts. */   outb (PIC0_DATA, 0x00);   outb (PIC1_DATA, 0x00); }   前置知识  1. x86 中断分类  x86 系统中的中断分为三类：  中断类型 │ ├─→ 异常（Exceptions）: CPU 内部产生 │   │ │   ├─→ 故障（Faults）: 可恢复，返回到引起故障的指令 │   │   例：#PF Page Fault, #GP General Protection │   │ │   ├─→ 陷阱（Traps）: 可恢复，返回到下一条指令 │   │   例：#BP Breakpoint, #OF Overflow │   │ │   └─→ 终止（Aborts）: 不可恢复 │       例：#DF Double Fault, #MC Machine Check │ ├─→ 软件中断（Software Interrupts）: INT 指令产生 │   例：INT 0x80 (系统调用) │ └─→ 硬件中断（Hardware Interrupts）: 外部设备产生     │     ├─→ 可屏蔽中断（Maskable）: 通过 PIC 传递     │   例：定时器、键盘、硬盘     │     └─→ 不可屏蔽中断（NMI）: 直接到达 CPU         例：内存校验错误   2. 中断向量表  x86 支持 256 个中断向量（0-255）：                 向量范围       类型       说明                       0-19       CPU 异常       由 Intel 定义                 20-31       保留       Intel 保留                 32-47       硬件中断       重映射后的 IRQ 0-15                 48-255       可用       软件中断、系统调用等           3. 8259A PIC 架构  PC 使用两片级联的 8259A PIC：                             ┌─────────────────┐                            │      CPU        │                            │                 │                            │   INTR ◄────────┼──────┐                            └─────────────────┘      │                                                     │ ┌──────────────────────┐                    ┌──────┴──────────────┐ │     外部设备          │                    │    Master PIC       │ │                      │                    │    (8259A #0)       │ │  IRQ0: 定时器 ───────┼────────────────────┼→ IR0               │ │  IRQ1: 键盘 ─────────┼────────────────────┼→ IR1               │ │  IRQ2: 级联 ─────────┼────────────────────┼→ IR2 ◄─────────────┼──┐ │  IRQ3: COM2 ─────────┼────────────────────┼→ IR3               │  │ │  IRQ4: COM1 ─────────┼────────────────────┼→ IR4               │  │ │  IRQ5: LPT2 ─────────┼────────────────────┼→ IR5               │  │ │  IRQ6: 软盘 ─────────┼────────────────────┼→ IR6               │  │ │  IRQ7: LPT1 ─────────┼────────────────────┼→ IR7               │  │ │                      │                    └────────────────────┘  │ │                      │                                            │ │                      │                    ┌────────────────────┐  │ │                      │                    │    Slave PIC        │  │ │                      │                    │    (8259A #1)       │  │ │  IRQ8: RTC ──────────┼────────────────────┼→ IR0               │  │ │  IRQ9: ACPI ─────────┼────────────────────┼→ IR1               │  │ │  IRQ10: 可用 ────────┼────────────────────┼→ IR2               │  │ │  IRQ11: 可用 ────────┼────────────────────┼→ IR3               │  │ │  IRQ12: PS/2鼠标 ────┼────────────────────┼→ IR4               │  │ │  IRQ13: FPU ─────────┼────────────────────┼→ IR5               │  │ │  IRQ14: IDE Primary ─┼────────────────────┼→ IR6               │  │ │  IRQ15: IDE Secondary┼────────────────────┼→ IR7               │  │ │                      │                    │         INT ────────┼──┘ └──────────────────────┘                    └────────────────────┘   4. IDT 描述符格式  每个 IDT 条目（门描述符）是 8 字节：  63                48 47 46 45 44 43 40 39        32 +------------------+--+-----+--+------+------------+ |  Offset 31:16    |P |DPL |S | Type |  Reserved  | +------------------+--+-----+--+------+------------+  31                16 15                           0 +------------------+-----------------------------+ | Segment Selector |       Offset 15:0           | +------------------+-----------------------------+  各字段说明： - Offset: 中断处理程序的地址（分成两部分） - P: 存在位（1=有效） - DPL: 描述符特权级（0-3） - S: 系统段（必须为0） - Type: 门类型（14=中断门，15=陷阱门） - Segment Selector: 代码段选择子   5. 中断门 vs 陷阱门                 特性       中断门（Interrupt Gate）       陷阱门（Trap Gate）                       Type       14 (0xE)       15 (0xF)                 进入时       自动关中断 (IF=0)       保持中断状态                 用途       硬件中断       软件中断、异常           6. 中断帧（Interrupt Frame）  中断发生时 CPU 自动压栈的内容：  高地址 ┌───────────────────┐ │       SS          │  (特权级改变时) ├───────────────────┤ │       ESP         │  (特权级改变时) ├───────────────────┤ │      EFLAGS       │ ├───────────────────┤ │       CS          │ ├───────────────────┤ │       EIP         │ ├───────────────────┤ │   Error Code      │  (某些异常) ├───────────────────┤ │   (软件压入的)     │ │   寄存器等        │ └───────────────────┘ 低地址   逐行代码解析  intr_init() 函数解析  第1-2行：变量声明  uint64_t idtr_operand; int i;   详细解析：     idtr_operand：            64 位值，存储 IDTR 寄存器的操作数       格式：低 16 位是限制（limit），高 32 位是基址（base）           i：循环变量   第3行：初始化 PIC  pic_init ();   详细解析：  这是关键的一步，重新配置 8259A PIC。详见下面的 pic_init() 解析。  第4-5行：初始化 IDT  for (i = 0; i &lt; INTR_CNT; i++)   idt[i] = make_intr_gate (intr_stubs[i], 0);   详细解析：          INTR_CNT = 256：x86 支持的中断向量数      intr_stubs[]：            中断存根函数数组       在 intr-stubs.S 中定义       每个存根函数负责保存上下文并调用统一的处理函数           make_intr_gate()：            创建中断门描述符       DPL=0 表示只有内核可以触发           初始状态：            所有中断都使用中断门（进入时关中断）       所有中断都没有实际处理程序（后续注册）           intr_stubs 示意：  # intr-stubs.S 中的代码结构（简化） intr00_stub:     push $0         # 假错误码     push $0x00      # 向量号     jmp intr_entry  intr01_stub:     push $0         # 假错误码     push $0x01      # 向量号     jmp intr_entry      # ... 256 个存根函数 ...   第6-8行：加载 IDT  idtr_operand = make_idtr_operand (sizeof idt - 1, idt); asm volatile (\"lidt %0\" : : \"m\" (idtr_operand));   详细解析：     make_idtr_operand()：   static inline uint64_t make_idtr_operand (uint16_t limit, void *base) {   return limit | ((uint64_t) (uint32_t) base &lt;&lt; 16); }   构造 IDTR 操作数格式： 63                             16 15              0 +--------------------------------+----------------+ |         Base Address           |     Limit      | +--------------------------------+----------------+      sizeof idt - 1：            IDT 大小为 256 × 8 = 2048 字节       limit = 2048 - 1 = 2047           LIDT 指令：            将 IDT 的位置和大小加载到 IDTR 寄存器       之后 CPU 会使用这个 IDT 处理中断           IDTR 寄存器结构：  47                             16 15              0 +--------------------------------+----------------+ |         IDT Base Address       |   IDT Limit    | +--------------------------------+----------------+   第9-25行：初始化中断名称  for (i = 0; i &lt; INTR_CNT; i++)   intr_names[i] = \"unknown\"; intr_names[0] = \"#DE Divide Error\"; intr_names[1] = \"#DB Debug Exception\"; // ... 更多中断名称 ...   详细解析：  这些名称用于调试，当发生意外中断时打印友好的信息。  标准 CPU 异常列表：                 向量       助记符       名称       类型       错误码                       0       #DE       Divide Error       Fault       无                 1       #DB       Debug       Fault/Trap       无                 2       NMI       Non-Maskable Interrupt       Interrupt       无                 3       #BP       Breakpoint       Trap       无                 4       #OF       Overflow       Trap       无                 5       #BR       BOUND Range Exceeded       Fault       无                 6       #UD       Invalid Opcode       Fault       无                 7       #NM       Device Not Available       Fault       无                 8       #DF       Double Fault       Abort       有(0)                 9       -       Coprocessor Segment Overrun       Fault       无                 10       #TS       Invalid TSS       Fault       有                 11       #NP       Segment Not Present       Fault       有                 12       #SS       Stack-Segment Fault       Fault       有                 13       #GP       General Protection       Fault       有                 14       #PF       Page Fault       Fault       有                 15       -       Reserved       -       -                 16       #MF       x87 FPU Error       Fault       无                 17       #AC       Alignment Check       Fault       有(0)                 18       #MC       Machine Check       Abort       无                 19       #XF       SIMD Floating-Point       Fault       无           pic_init() 函数解析  第1-2行：屏蔽所有中断  outb (PIC0_DATA, 0xff); outb (PIC1_DATA, 0xff);   详细解析：     写入数据端口设置中断屏蔽寄存器（IMR）   0xFF = 11111111b = 屏蔽所有 8 个中断线   防止初始化过程中产生中断   第3-6行：初始化主 PIC  outb (PIC0_CTRL, 0x11); /* ICW1 */ outb (PIC0_DATA, 0x20); /* ICW2 */ outb (PIC0_DATA, 0x04); /* ICW3 */ outb (PIC0_DATA, 0x01); /* ICW4 */   ICW（Initialization Command Words）详解：  ICW1 (0x11)： 位 7-5: 未使用 位 4:   1 = ICW1 标识 位 3:   0 = 边沿触发 位 2:   0 = 8 字节中断向量间隔 位 1:   0 = 级联模式 位 0:   1 = 需要 ICW4   ICW2 (0x20)： 位 7-3: 向量基址的高 5 位 = 0x20 = 32 位 2-0: 由 PIC 填充 结果：IR0-7 映射到向量 0x20-0x27   ICW3 (0x04)： 位 2:   1 = IR2 连接从 PIC 其他位: 0   ICW4 (0x01)： 位 4:   0 = 非特殊全嵌套模式 位 3-2: 00 = 非缓冲模式 位 1:   0 = 正常 EOI 位 0:   1 = 8086 模式   第7-10行：初始化从 PIC  outb (PIC1_CTRL, 0x11); /* ICW1 */ outb (PIC1_DATA, 0x28); /* ICW2: 映射到 0x28-0x2f */ outb (PIC1_DATA, 0x02); /* ICW3: 从 ID = 2 */ outb (PIC1_DATA, 0x01); /* ICW4 */   ICW3 (0x02) 对于从 PIC： 位 2-0: 010 = 从 ID 为 2（连接到主 PIC 的 IR2）   第11-12行：取消屏蔽所有中断  outb (PIC0_DATA, 0x00); outb (PIC1_DATA, 0x00);   详细解析：     0x00 = 00000000b = 允许所有中断   虽然 PIC 不再屏蔽中断，但 CPU 的 IF 标志仍为 0   中断要等到 intr_enable() 才会真正被处理   make_gate() 函数解析  static uint64_t make_gate (void (*function) (void), int dpl, int type) {   uint32_t e0, e1;    ASSERT (function != NULL);   ASSERT (dpl &gt;= 0 &amp;&amp; dpl &lt;= 3);   ASSERT (type &gt;= 0 &amp;&amp; type &lt;= 15);    e0 = (((uint32_t) function &amp; 0xffff)     /* Offset 15:0. */         | (SEL_KCSEG &lt;&lt; 16));              /* Target code segment. */    e1 = (((uint32_t) function &amp; 0xffff0000) /* Offset 31:16. */         | (1 &lt;&lt; 15)                        /* Present. */         | ((uint32_t) dpl &lt;&lt; 13)           /* Descriptor privilege level. */         | (0 &lt;&lt; 12)                        /* System. */         | ((uint32_t) type &lt;&lt; 8));         /* Gate type. */    return e0 | ((uint64_t) e1 &lt;&lt; 32); }   描述符构造图示：  假设 function = 0xC0012345，dpl = 0，type = 14（中断门）：  e0 构造： ┌────────────────┬────────────────┐ │  SEL_KCSEG     │  Offset 15:0   │ │    (0x08)      │   (0x2345)     │ └────────────────┴────────────────┘ e0 = 0x00082345  e1 构造： ┌────────────────┬─┬──┬─┬────┬────┐ │ Offset 31:16   │P│DPL│S│Type│ 0  │ │   (0xC001)     │1│ 0 │0│ E  │    │ └────────────────┴─┴──┴─┴────┴────┘ e1 = 0xC0018E00  最终描述符： 63                                                 0 +--------------------------------------------------+ |  0xC0018E00            |  0x00082345             | +--------------------------------------------------+   中断处理流程  完整的中断处理流程  1. 中断发生    │    ├─→ 硬件中断：设备 → PIC → CPU INTR    │    └─→ 异常/软中断：CPU 内部产生     2. CPU 响应    │    ├─→ 保存当前状态到栈    │   - EFLAGS, CS, EIP    │   - 错误码（如果有）    │   - SS, ESP（特权级改变时）    │    └─→ 从 IDT 获取处理程序地址        向量号 × 8 + IDT 基址  3. 跳转到中断存根    │    ├─→ intrNN_stub (intr-stubs.S)    │   - 压入错误码（如果 CPU 没压入）    │   - 压入向量号    │   - 跳转到 intr_entry    │    └─→ intr_entry        - 保存所有通用寄存器        - 保存段寄存器        - 设置内核数据段        - 调用 intr_handler()  4. C 语言处理    │    └─→ intr_handler (struct intr_frame *frame)        │        ├─→ 外部中断？        │   - 设置 in_external_intr = true        │        ├─→ 查找并调用注册的处理程序        │   handler = intr_handlers[frame-&gt;vec_no]        │        └─→ 外部中断完成处理            - 发送 EOI 到 PIC            - 检查是否需要调度  5. 返回    │    └─→ intr_exit (intr-stubs.S)        - 恢复段寄存器        - 恢复通用寄存器        - iret 指令返回   intr_handler() 函数详解  void intr_handler (struct intr_frame *frame)  {   bool external;   intr_handler_func *handler;    /* External interrupts are special. */   external = frame-&gt;vec_no &gt;= 0x20 &amp;&amp; frame-&gt;vec_no &lt; 0x30;   if (external)      {       ASSERT (intr_get_level () == INTR_OFF);       ASSERT (!intr_context ());        in_external_intr = true;       yield_on_return = false;     }    /* Invoke the interrupt's handler. */   handler = intr_handlers[frame-&gt;vec_no];   if (handler != NULL)     handler (frame);   else if (frame-&gt;vec_no == 0x27 || frame-&gt;vec_no == 0x2f)     {       /* Spurious interrupt, ignore it. */     }   else     unexpected_interrupt (frame);    /* Complete the processing of an external interrupt. */   if (external)      {       ASSERT (intr_get_level () == INTR_OFF);       ASSERT (intr_context ());        in_external_intr = false;       pic_end_of_interrupt (frame-&gt;vec_no);         if (yield_on_return)          thread_yield ();      } }   关键点：          外部中断识别：向量号 0x20-0x2F 是 PIC 重映射后的硬件中断      伪中断（Spurious Interrupt）：            IRQ7 (0x27) 和 IRQ15 (0x2f) 可能产生伪中断       由于 PIC 的硬件特性导致       应该忽略而不是报错           EOI（End of Interrupt）：            必须发送 EOI 告知 PIC 中断处理完成       否则 PIC 不会传递后续中断           yield_on_return：            允许中断处理程序请求调度       常用于定时器中断（时间片用完）           中断帧结构  struct intr_frame 详解  struct intr_frame {   /* 由 intr_entry 压入的寄存器 */   uint32_t edi;               /* Saved EDI. */   uint32_t esi;               /* Saved ESI. */   uint32_t ebp;               /* Saved EBP. */   uint32_t esp_dummy;         /* Not used (PUSHA 的 ESP). */   uint32_t ebx;               /* Saved EBX. */   uint32_t edx;               /* Saved EDX. */   uint32_t ecx;               /* Saved ECX. */   uint32_t eax;               /* Saved EAX. */   uint16_t gs, :16;           /* Saved GS. */   uint16_t fs, :16;           /* Saved FS. */   uint16_t es, :16;           /* Saved ES. */   uint16_t ds, :16;           /* Saved DS. */    /* 由 intrNN_stub 压入 */   uint32_t vec_no;            /* Interrupt vector number. */   uint32_t error_code;        /* Error code. */   void *frame_pointer;        /* Saved EBP (for backtrace). */    /* 由 CPU 压入 */   void (*eip) (void);         /* Next instruction. */   uint16_t cs, :16;           /* Code segment. */   uint32_t eflags;            /* CPU flags. */   void *esp;                  /* Stack pointer. */   uint16_t ss, :16;           /* Stack segment. */ };   栈布局图：  中断发生时的栈布局（从高地址到低地址）：  ┌─────────────────────────────────┐ 高地址 │             SS                  │ ← (仅在特权级改变时) ├─────────────────────────────────┤ │             ESP                 │ ← (仅在特权级改变时) ├─────────────────────────────────┤ │           EFLAGS                │ ← CPU 压入 ├─────────────────────────────────┤ │             CS                  │ ← CPU 压入 ├─────────────────────────────────┤ │             EIP                 │ ← CPU 压入 ├─────────────────────────────────┤ │         Error Code              │ ← CPU/存根 压入 ├─────────────────────────────────┤ │        Frame Pointer            │ ← 存根 压入 ├─────────────────────────────────┤ │          vec_no                 │ ← 存根 压入 ├─────────────────────────────────┤ │           DS                    │ ← intr_entry 压入 ├─────────────────────────────────┤ │           ES                    │ ├─────────────────────────────────┤ │           FS                    │ ├─────────────────────────────────┤ │           GS                    │ ├─────────────────────────────────┤ │      EAX, ECX, EDX, EBX         │ ← PUSHA │      ESP_dummy, EBP, ESI, EDI   │ └─────────────────────────────────┘ 低地址 (ESP 指向这里)   中断注册  注册外部中断  void intr_register_ext (uint8_t vec_no, intr_handler_func *handler,                    const char *name)  {   ASSERT (vec_no &gt;= 0x20 &amp;&amp; vec_no &lt;= 0x2f);   register_handler (vec_no, 0, INTR_OFF, handler, name); }   使用示例（定时器）：  /* timer.c */ void timer_init (void)  {   /* ... 配置 PIT ... */      intr_register_ext (0x20, timer_interrupt, \"8254 Timer\"); }   注册内部中断  void intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,                    intr_handler_func *handler, const char *name) {   ASSERT (vec_no &lt; 0x20 || vec_no &gt; 0x2f);   register_handler (vec_no, dpl, level, handler, name); }   使用示例（缺页异常）：  /* exception.c */ void exception_init (void)  {   /* ... */      intr_register_int (14, 0, INTR_OFF, page_fault, \"#PF Page-Fault Exception\"); }   register_handler() 实现  static void register_handler (uint8_t vec_no, int dpl, enum intr_level level,                   intr_handler_func *handler, const char *name) {   ASSERT (intr_handlers[vec_no] == NULL);   if (level == INTR_ON)     idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);   else     idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);   intr_handlers[vec_no] = handler;   intr_names[vec_no] = name; }   关键选择：     INTR_ON：使用陷阱门（不自动关中断）→ 允许中断嵌套   INTR_OFF：使用中断门（自动关中断）→ 禁止中断嵌套   PIC EOI 处理  static void pic_end_of_interrupt (int irq)  {   ASSERT (irq &gt;= 0x20 &amp;&amp; irq &lt; 0x30);    /* Acknowledge master PIC. */   outb (0x20, 0x20);    /* Acknowledge slave PIC if this is a slave interrupt. */   if (irq &gt;= 0x28)     outb (0xa0, 0x20); }   EOI 流程：  IRQ 0-7 (主 PIC):     │     └─→ 向主 PIC 发送 EOI         outb(0x20, 0x20)  IRQ 8-15 (从 PIC):     │     ├─→ 向主 PIC 发送 EOI     │   outb(0x20, 0x20)     │     └─→ 向从 PIC 发送 EOI         outb(0xa0, 0x20)   为什么从 PIC 中断需要两个 EOI？  因为从 PIC 是级联到主 PIC 的 IR2，所以：    从 PIC 需要知道中断处理完成   主 PIC 也需要知道（释放 IR2 线）   常见问题解答  Q1: 为什么需要重映射 PIC？  A:    x86 架构规定向量 0-31 用于 CPU 异常   默认 PIC 将 IRQ 0-15 映射到向量 0-15   这与 CPU 异常冲突   重映射到 32-47 避免冲突   Q2: 中断门和陷阱门的实际区别？  A:    中断门：进入时自动 CLI（关中断）   陷阱门：保持中断状态不变   效果：中断门处理程序开始时中断是关闭的   Q3: 为什么外部中断处理要关中断？  A:    防止中断嵌套导致栈溢出   简化中断处理程序的编写   Pintos 的设计选择，不是必须的   Q4: yield_on_return 有什么用？  A:    允许中断处理程序请求线程切换   例如：定时器中断检测到时间片用完   在返回前（而不是中断处理中）切换，保证原子性   练习题  练习1：PIC 重映射验证  修改 pic_init()，将硬件中断映射到向量 64-79，需要修改哪些代码？  练习2：中断计数器  添加功能，统计每种中断发生的次数，并提供函数查询：  unsigned int intr_get_count(uint8_t vec_no);   练习3：理解中断优先级  分析以下场景：    CPU 正在处理定时器中断（IRQ0，向量 0x20）   此时键盘产生中断（IRQ1，向量 0x21）   中断会被如何处理？   练习4：实现中断屏蔽  实现函数来单独屏蔽/解除屏蔽特定 IRQ：  void irq_mask(int irq); void irq_unmask(int irq);   提示：操作 PIC 的 IMR（中断屏蔽寄存器）。  下一篇预告  在下一篇文档中，我们将详细解析设备初始化过程，了解 Pintos 如何初始化定时器、键盘、串口等硬件设备。  参考资料     Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A - Chapter 6: Interrupt and Exception Handling   8259A Programmable Interrupt Controller Datasheet   OSDev Wiki - 8259 PIC   OSDev Wiki - Interrupt Descriptor Table"
  },
  
  {
    "title": "Pintos Kernel 12 Thread Init",
    "url": "/posts/pintos-kernel-12-thread-init/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十二）：线程系统初始化  概述  本文档详细解析 Pintos 内核的线程系统初始化过程，包括 thread_init() 和 thread_start() 两个关键函数。线程是操作系统调度的基本单位，线程系统的正确初始化是内核正常运行的基础。  Pintos 的线程系统具有以下特点：    每个线程占用一个页：线程结构体位于页底部，栈从页顶向下增长   简单的调度器：默认使用轮转调度（Round-Robin）   主线程转换：将当前执行流转换为正式的线程   原始代码  thread.c 中的 thread_init() 函数  /** Initializes the threading system by transforming the code    that's currently running into a thread.  This can't work in    general and it is possible in this case only because loader.S    was careful to put the bottom of the stack at a page boundary.     Also initializes the run queue and the tid lock.     After calling this function, be sure to initialize the page    allocator before trying to create any threads with    thread_create().     It is not safe to call thread_current() until this function    finishes. */ void thread_init (void)  {   ASSERT (intr_get_level () == INTR_OFF);    lock_init (&amp;tid_lock);   list_init (&amp;ready_list);   list_init (&amp;all_list);    /* Set up a thread structure for the running thread. */   initial_thread = running_thread ();   init_thread (initial_thread, \"main\", PRI_DEFAULT);   initial_thread-&gt;status = THREAD_RUNNING;   initial_thread-&gt;tid = allocate_tid (); }   thread.c 中的 thread_start() 函数  /** Starts preemptive thread scheduling by enabling interrupts.    Also creates the idle thread. */ void thread_start (void)  {   /* Create the idle thread. */   struct semaphore idle_started;   sema_init (&amp;idle_started, 0);   thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);    /* Start preemptive thread scheduling. */   intr_enable ();    /* Wait for the idle thread to initialize idle_thread. */   sema_down (&amp;idle_started); }   thread.h 中的 struct thread 定义  struct thread   {     /* Owned by thread.c. */     tid_t tid;                          /* Thread identifier. */     enum thread_status status;          /* Thread state. */     char name[16];                      /* Name (for debugging purposes). */     uint8_t *stack;                     /* Saved stack pointer. */     int priority;                       /* Priority. */     struct list_elem allelem;           /* List element for all threads list. */      /* Shared between thread.c and synch.c. */     struct list_elem elem;              /* List element. */  #ifdef USERPROG     /* Owned by userprog/process.c. */     uint32_t *pagedir;                  /* Page directory. */ #endif      /* Owned by thread.c. */     unsigned magic;                     /* Detects stack overflow. */   };   前置知识  1. 线程内存布局  Pintos 中每个线程占用一个完整的 4KB 页：          4 kB +---------------------------------+              |          kernel stack           |              |                |                |              |                |                |              |                V                |              |         grows downward          |              |                                 |              |                                 |              |                                 |              |                                 |              |                                 |              |                                 |              |                                 |              |                                 |              +---------------------------------+              |              magic              |              |                :                |              |                :                |              |               name              |              |              status             |         0 kB +---------------------------------+   这种设计的优点：    快速定位线程结构：将栈指针向下取整到页边界即可找到线程结构   栈溢出检测：通过检查 magic 成员是否被覆写   简化内存管理：分配/释放线程只需操作一个页   2. 线程状态  enum thread_status   {     THREAD_RUNNING,     /* Running thread. */     THREAD_READY,       /* Not running but ready to run. */     THREAD_BLOCKED,     /* Waiting for an event to trigger. */     THREAD_DYING        /* About to be destroyed. */   };   状态转换图：                            创建                            │                            ↓                     ┌─────────────┐                     │  BLOCKED    │◄──────────────┐                     └─────────────┘               │                            │                      │                            │ unblock              │ block (等待事件)                            ↓                      │     ┌─────────────┐  调度  ┌─────────────┐       │     │  RUNNING    │◄──────│   READY     │       │     └─────────────┘       └─────────────┘       │            │                     ↑               │            │                     │               │            │     yield/抢占      │               │            └─────────────────────┘               │            │                                     │            │ exit                                │            ↓                                     │     ┌─────────────┐                              │     │   DYING     │                              │     └─────────────┘                              │   3. 线程优先级  #define PRI_MIN 0       /* Lowest priority. */ #define PRI_DEFAULT 31  /* Default priority. */ #define PRI_MAX 63      /* Highest priority. */      优先级范围：0-63（64 个级别）   数值越大优先级越高   默认优先级为 31   4. 关键数据结构  /* 就绪队列：等待运行的线程 */ static struct list ready_list;  /* 所有线程列表 */ static struct list all_list;  /* 空闲线程 */ static struct thread *idle_thread;  /* 主线程（运行 init.c:main() 的线程）*/ static struct thread *initial_thread;  /* TID 分配锁 */ static struct lock tid_lock;   逐行代码解析  thread_init() 函数解析  第1行：检查中断状态  ASSERT (intr_get_level () == INTR_OFF);   详细解析：     为什么需要关中断？            初始化过程中修改共享数据结构       需要防止中断处理程序访问未初始化的数据       确保初始化的原子性           此时中断为什么是关闭的？            从系统启动开始中断就是关闭的       intr_enable() 在 thread_start() 中才会被调用           第2-4行：初始化全局数据结构  lock_init (&amp;tid_lock); list_init (&amp;ready_list); list_init (&amp;all_list);   详细解析：     tid_lock 初始化：            用于保护线程 ID 的分配       确保每个线程获得唯一的 TID           ready_list 初始化：            就绪队列，存放等待运行的线程       使用双向链表实现           all_list 初始化：            所有线程的列表       用于调试和遍历所有线程           链表初始状态：  ready_list (空) ┌──────────┐ │   head   │◄──┐ ├──────────┤   │ │   tail   │───┘ └──────────┘  all_list (空) ┌──────────┐ │   head   │◄──┐ ├──────────┤   │ │   tail   │───┘ └──────────┘   第5行：获取当前线程结构体  initial_thread = running_thread ();   详细解析：  running_thread() 函数的实现：  struct thread * running_thread (void)  {   uint32_t *esp;    /* Copy the CPU's stack pointer into `esp', and then round that      down to the start of a page.  Because `struct thread' is      always at the beginning of a page and the stack pointer is      somewhere in the middle, this locates the current thread. */   asm (\"mov %%esp, %0\" : \"=g\" (esp));   return pg_round_down (esp); }   工作原理：  当前内存布局：                                  ESP 在这里 ↓ ┌───────────────────────────────────────────┐ 页顶 (页基址 + 4KB) │                栈内容                      │ │            (函数调用等)                    │ ├───────────────────────────────────────────┤ ESP 指向的位置 │                                           │ │             未使用的栈空间                 │ │                                           │ ├───────────────────────────────────────────┤ │                                           │ │          struct thread (未初始化)         │ │                                           │ └───────────────────────────────────────────┘ 页底 (页基址)  pg_round_down(ESP) = 页底地址 = struct thread 地址   为什么这能工作？     loader.S 精心设置了初始栈位置，使其底部对齐到页边界   初始栈在内核 BSS 段的末尾   这个页在 thread_init 之前就已经被当作”主线程”的页使用   第6行：初始化线程结构体  init_thread (initial_thread, \"main\", PRI_DEFAULT);   详细解析：  init_thread() 函数的实现：  static void init_thread (struct thread *t, const char *name, int priority) {   enum intr_level old_level;    ASSERT (t != NULL);   ASSERT (PRI_MIN &lt;= priority &amp;&amp; priority &lt;= PRI_MAX);   ASSERT (name != NULL);    memset (t, 0, sizeof *t);   t-&gt;status = THREAD_BLOCKED;   strlcpy (t-&gt;name, name, sizeof t-&gt;name);   t-&gt;stack = (uint8_t *) t + PGSIZE;   t-&gt;priority = priority;   t-&gt;magic = THREAD_MAGIC;    old_level = intr_disable ();   list_push_back (&amp;all_list, &amp;t-&gt;allelem);   intr_set_level (old_level); }   逐步解析：     memset 清零：将整个结构体清零   status = THREAD_BLOCKED：初始状态为阻塞（稍后会改为 RUNNING）   strlcpy name：复制线程名称（最多 15 字符 + ‘\\0’）   stack = t + PGSIZE：栈指针初始化到页顶   priority：设置优先级   magic = THREAD_MAGIC：设置魔数（用于检测栈溢出）   加入 all_list：将线程添加到所有线程列表   初始化后的布局：  4 KB  ┌───────────────────────────────┐ t-&gt;stack 指向这里       │                               │       │        (栈空间)               │       │                               │       ├───────────────────────────────┤       │   magic = 0xcd6abf4b          │ 栈溢出检测       ├───────────────────────────────┤       │   priority = 31               │       ├───────────────────────────────┤       │   stack (指向页顶)            │       ├───────────────────────────────┤       │   name = \"main\\0...\"          │       ├───────────────────────────────┤       │   status = THREAD_BLOCKED     │       ├───────────────────────────────┤       │   tid = 0 (未分配)            │ 0 KB  └───────────────────────────────┘ initial_thread 指向这里   第7-8行：设置运行状态和分配 TID  initial_thread-&gt;status = THREAD_RUNNING; initial_thread-&gt;tid = allocate_tid ();   详细解析：     状态改为 RUNNING：            主线程当前正在运行       覆盖 init_thread 设置的 BLOCKED 状态           分配 TID：            allocate_tid() 返回下一个可用的线程 ID       主线程的 TID 为 1           allocate_tid() 实现：  static tid_t allocate_tid (void)  {   static tid_t next_tid = 1;   tid_t tid;    lock_acquire (&amp;tid_lock);   tid = next_tid++;   lock_release (&amp;tid_lock);    return tid; }   注意：虽然此时还没有其他线程，但使用锁是好习惯，确保代码的正确性。  thread_start() 函数解析  第1-3行：创建空闲线程同步信号量  struct semaphore idle_started; sema_init (&amp;idle_started, 0); thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);   详细解析：     信号量目的：            等待空闲线程完成初始化       确保 idle_thread 变量被正确设置           thread_create 参数：            \"idle\"：线程名称       PRI_MIN：最低优先级（0）       idle：线程函数       &amp;idle_started：传递给 idle 函数的参数           为什么需要空闲线程？     当没有其他线程就绪时，CPU 需要运行某些东西   空闲线程执行 hlt 指令，使 CPU 进入低功耗状态   这比忙等待更节能   第4行：启用中断  intr_enable ();   详细解析：     从这一刻起，定时器中断开始触发   抢占式调度正式开始   空闲线程可能在这之后被调度运行   第5行：等待空闲线程初始化  sema_down (&amp;idle_started);   详细解析：  这里可能发生以下情况：  场景1：空闲线程先运行 主线程                     空闲线程    │                          │    │ create idle              │    │────────────────────────→│    │                          │    │ enable interrupts        │    │                          │    │                    ┌─────┤ 被调度    │                    │     │    │                    │  idle_thread = self    │                    │     │    │                    │  sema_up()    │◄───────────────────┘     │    │                          │    │ sema_down() (直接成功)   │    │                          │   场景2：主线程继续运行 主线程                     空闲线程    │                          │    │ create idle              │    │                          │ (在 ready_list 中)    │ enable interrupts        │    │                          │    │ sema_down()              │    │     (阻塞，信号量=0)     │    │                    ┌─────┤ 被调度    │                    │     │    │                    │  idle_thread = self    │                    │     │    │                    │  sema_up()    │◄───────────────────┘     │    │ (唤醒)                   │    │                          │   idle() 函数解析  static void idle (void *idle_started_ UNUSED)  {   struct semaphore *idle_started = idle_started_;   idle_thread = thread_current ();   sema_up (idle_started);    for (;;)      {       /* Let someone else run. */       intr_disable ();       thread_block ();        /* Re-enable interrupts and wait for the next one.          The `sti' instruction disables interrupts until the          completion of the next instruction, so these two          instructions are executed atomically.  This atomicity is          important; otherwise, an interrupt could be handled          between re-enabling interrupts and waiting for the next          one to occur, wasting as much as one clock tick worth of          time. */       asm volatile (\"sti; hlt\" : : : \"memory\");     } }   详细解析：     设置 idle_thread：            保存自己的线程指针到全局变量       供调度器在就绪队列为空时使用           通知主线程：            sema_up() 释放信号量       允许主线程继续执行           无限循环：     for (;;) {   intr_disable ();   // 关中断   thread_block ();   // 阻塞自己，调度其他线程         // 被唤醒后执行   asm volatile (\"sti; hlt\" : : : \"memory\"); }           sti; hlt 原子性：            sti：开中断       hlt：停止 CPU 直到下一个中断       x86 保证 sti 后的第一条指令不会被中断       这确保了 hlt 能够被执行           为什么需要这种原子性？  如果不是原子的：  时刻 T:   sti          (开中断) 时刻 T+1: [中断到来]   (处理中断，可能唤醒某个线程) 时刻 T+2: hlt          (进入睡眠，但应该运行被唤醒的线程！)  结果：浪费了处理器时间   thread_create() 函数详解  tid_t thread_create (const char *name, int priority,                thread_func *function, void *aux)  {   struct thread *t;   struct kernel_thread_frame *kf;   struct switch_entry_frame *ef;   struct switch_threads_frame *sf;   tid_t tid;    ASSERT (function != NULL);    /* Allocate thread. */   t = palloc_get_page (PAL_ZERO);   if (t == NULL)     return TID_ERROR;    /* Initialize thread. */   init_thread (t, name, priority);   tid = t-&gt;tid = allocate_tid ();    /* Stack frame for kernel_thread(). */   kf = alloc_frame (t, sizeof *kf);   kf-&gt;eip = NULL;   kf-&gt;function = function;   kf-&gt;aux = aux;    /* Stack frame for switch_entry(). */   ef = alloc_frame (t, sizeof *ef);   ef-&gt;eip = (void (*) (void)) kernel_thread;    /* Stack frame for switch_threads(). */   sf = alloc_frame (t, sizeof *sf);   sf-&gt;eip = switch_entry;   sf-&gt;ebp = 0;    /* Add to run queue. */   thread_unblock (t);    return tid; }   栈帧布局：  新线程创建后，其栈的布局如下：  4 KB  ┌───────────────────────────────┐       │                               │       │        (未使用的栈空间)        │       │                               │       ├───────────────────────────────┤       │   kernel_thread_frame         │       │  ┌─────────────────────────┐  │       │  │ eip = NULL (返回地址)   │  │       │  │ function (线程函数)     │  │       │  │ aux (辅助参数)          │  │       │  └─────────────────────────┘  │       ├───────────────────────────────┤       │   switch_entry_frame          │       │  ┌─────────────────────────┐  │       │  │ eip = kernel_thread     │  │       │  └─────────────────────────┘  │       ├───────────────────────────────┤       │   switch_threads_frame        │       │  ┌─────────────────────────┐  │       │  │ eip = switch_entry      │  │ ← t-&gt;stack       │  │ ebp = 0                 │  │       │  │ ebx, esi, edi = 0       │  │       │  └─────────────────────────┘  │       ├───────────────────────────────┤       │   struct thread               │       │   (tid, name, priority, ...)  │ 0 KB  └───────────────────────────────┘   首次调度时的执行流：  1. switch_threads() 恢复 sf 中的寄存器    └→ ret 执行，跳转到 switch_entry  2. switch_entry (in switch.S)    └→ ret 执行，跳转到 kernel_thread  3. kernel_thread()    intr_enable();        // 开中断    function(aux);        // 执行用户提供的函数    thread_exit();        // 线程结束   调度器核心函数  schedule() 函数  static void schedule (void)  {   struct thread *cur = running_thread ();   struct thread *next = next_thread_to_run ();   struct thread *prev = NULL;    ASSERT (intr_get_level () == INTR_OFF);   ASSERT (cur-&gt;status != THREAD_RUNNING);   ASSERT (is_thread (next));    if (cur != next)     prev = switch_threads (cur, next);   thread_schedule_tail (prev); }   调度流程：  schedule()     │     ├─→ cur = 当前线程     │     ├─→ next = next_thread_to_run()     │         │     │         ├─→ ready_list 非空? 取出第一个线程     │         │     │         └─→ ready_list 为空? 返回 idle_thread     │     ├─→ cur == next? ─→ 是 ─→ 跳过切换     │         │     │         └─→ 否 ─→ switch_threads(cur, next)     │                     │     │                     └─→ 保存 cur 的寄存器     │                         恢复 next 的寄存器     │                         返回 prev (= cur)     │     └─→ thread_schedule_tail(prev)               │               ├─→ 标记新线程为 RUNNING               │               ├─→ 重置时间片计数器               │               └─→ 如果 prev 正在死亡，释放其内存   switch_threads() 函数 (switch.S)  .globl switch_threads .func switch_threads switch_threads:     # Save caller's register state.     pushl %ebx     pushl %ebp     pushl %esi     pushl %edi      # Get offsetof (struct thread, stack).     mov thread_stack_ofs, %edx      # Save current stack pointer to old thread's stack.     movl SWITCH_CUR(%esp), %eax     movl %esp, (%eax,%edx,1)      # Restore stack pointer from new thread's stack.     movl SWITCH_NEXT(%esp), %ecx     movl (%ecx,%edx,1), %esp      # Restore caller's register state.     popl %edi     popl %esi     popl %ebp     popl %ebx     ret .endfunc   线程切换图示：  切换前：                                  切换后：  线程 A (cur)                             线程 B (next) ┌─────────────┐                          ┌─────────────┐ │   栈顶      │                          │   栈顶      │ │     │       │                          │     │       │ │     ↓       │                          │     ↓       │ │             │                          │             │ │ [保存的寄存器]│◄── A-&gt;stack            │ [保存的寄存器]│◄── B-&gt;stack └─────────────┘                          └─────────────┘       ↑                                        │       │                                        │     ESP                                      ESP                            switch_threads()             ──────────────────────────────→             保存 A 的 ESP 到 A-&gt;stack             从 B-&gt;stack 恢复 ESP   线程生命周期  完整生命周期示例  1. 创建阶段    thread_create(\"worker\", PRI_DEFAULT, worker_func, arg)    │    ├─→ 分配一页内存    ├─→ 初始化 thread 结构体    ├─→ 设置栈帧    └─→ thread_unblock() → 加入 ready_list        状态: BLOCKED → READY  2. 首次运行    schedule() 选中新线程    │    ├─→ switch_threads() 切换栈    ├─→ switch_entry → kernel_thread    └─→ function(aux) 开始执行        状态: READY → RUNNING  3. 正常运行    │    ├─→ 可能 yield → READY → RUNNING    ├─→ 可能 block → BLOCKED → READY → RUNNING    └─→ 继续执行  4. 退出阶段    thread_exit()    │    ├─→ 从 all_list 移除    ├─→ 状态设为 DYING    └─→ schedule() → 永不返回         5. 清理阶段    thread_schedule_tail() (由下一个线程执行)    │    └─→ palloc_free_page(prev) 释放内存   魔数与栈溢出检测  THREAD_MAGIC 的作用  #define THREAD_MAGIC 0xcd6abf4b   检测机制：  static bool is_thread (struct thread *t) {   return t != NULL &amp;&amp; t-&gt;magic == THREAD_MAGIC; }  struct thread * thread_current (void)  {   struct thread *t = running_thread ();      /* Make sure T is really a thread.      If either of these assertions fire, then your thread may      have overflowed its stack. */   ASSERT (is_thread (t));   ASSERT (t-&gt;status == THREAD_RUNNING);    return t; }   栈溢出示意：  正常情况： ┌───────────────────────────────┐ 4KB │           栈使用区             │ │             ↓                 │ ├───────────────────────────────┤ │           空闲区               │ ├───────────────────────────────┤ │  magic = 0xcd6abf4b ✓         │ │  ... 其他成员 ...             │ └───────────────────────────────┘ 0  栈溢出后： ┌───────────────────────────────┐ 4KB │           栈使用区             │ │             ↓                 │ │             ↓                 │ │             ↓                 │ ├───────────────────────────────┤ │  magic = ???????? ✗ (被覆盖)   │ │  ... 被破坏的数据 ...          │ └───────────────────────────────┘ 0   常见问题解答  Q1: 为什么主线程可以被”转换”而不是”创建”？  A:    系统启动时已经有代码在执行   这个执行流需要被纳入线程管理   loader.S 确保了栈底对齐到页边界   只需填充 thread 结构体即可   Q2: 为什么空闲线程优先级最低？  A:    空闲线程只在没有其他工作时运行   最低优先级确保它不会抢占任何实际工作   它的唯一目的是节省电力和等待中断   Q3: thread_create 中的多个栈帧有什么作用？  A: 模拟线程之前被调度过的状态：    switch_threads_frame：模拟 switch_threads 调用点   switch_entry_frame：模拟返回到 kernel_thread 的入口   kernel_thread_frame：提供实际线程函数的参数   Q4: 为什么要等待空闲线程初始化？  A:    调度器需要 idle_thread 指针   当 ready_list 为空时返回 idle_thread   如果不等待，可能返回 NULL 导致崩溃   练习题  练习1：分析栈使用  给定以下递归函数，计算需要多少栈空间：  int factorial(int n) {     if (n &lt;= 1) return 1;     return n * factorial(n - 1); }   假设每次函数调用使用 32 字节栈空间，Pintos 线程最多能计算多大的阶乘？  练习2：线程状态追踪  画出以下场景中两个线程的状态转换：    主线程创建线程 A   线程 A 运行并调用 sema_down() 阻塞   主线程调用 sema_up() 唤醒线程 A   线程 A 运行完毕退出   练习3：修改时间片  TIME_SLICE 定义为 4 个时钟周期。如果改为：    TIME_SLICE = 1：会有什么影响？   TIME_SLICE = 100：会有什么影响？   练习4：实现线程统计  添加一个函数 thread_count() 返回当前存活的线程数。  提示：使用 all_list 链表。  下一篇预告  在下一篇文档中，我们将详细解析中断系统的初始化 intr_init()，了解 Pintos 如何设置 IDT（中断描述符表）和处理各种中断。  参考资料     Intel 64 and IA-32 Architectures Software Developer’s Manual   Pintos Documentation - Threads   OSDev Wiki - Context Switching"
  },
  
  {
    "title": "Pintos Kernel 11 Paging Init",
    "url": "/posts/pintos-kernel-11-paging-init/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十一）：永久页表建立  概述  本文档详细解析 Pintos 内核的 paging_init() 函数，该函数负责建立永久的页表结构，替换 start.S 中创建的临时页表。这是内核初始化过程中至关重要的一步，它建立了内核运行所需的完整地址映射。  在 start.S 中，我们创建了一个简单的临时页表，只映射了前 64MB 的物理内存。现在，paging_init() 将创建一个完整的页表，映射所有检测到的物理内存，并正确设置页面保护属性。  原始代码  init.c 中的 paging_init() 函数  /** Populates the base page directory and page table with the    kernel virtual mapping, and then sets up the CPU to use the    new page directory.  Points init_page_dir to the page    directory it creates. */ static void paging_init (void) {   uint32_t *pd, *pt;   size_t page;   extern char _start, _end_kernel_text;    pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);   pt = NULL;   for (page = 0; page &lt; init_ram_pages; page++)     {       uintptr_t paddr = page * PGSIZE;       char *vaddr = ptov (paddr);       size_t pde_idx = pd_no (vaddr);       size_t pte_idx = pt_no (vaddr);       bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text;        if (pd[pde_idx] == 0)         {           pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);           pd[pde_idx] = pde_create (pt);         }        pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);     }    /* Store the physical address of the page directory into CR3      aka PDBR (page directory base register).  This activates our      new page tables immediately.  See [IA32-v2a] \"MOV--Move      to/from Control Registers\" and [IA32-v3a] 3.7.5 \"Base Address      of the Page Directory\". */   asm volatile (\"movl %0, %%cr3\" : : \"r\" (vtop (init_page_dir))); }   pte.h 中的辅助函数和宏  /** Virtual addresses are structured as follows:      31                  22 21                  12 11                   0    +----------------------+----------------------+----------------------+    | Page Directory Index |   Page Table Index   |    Page Offset       |    +----------------------+----------------------+----------------------+ */  /** Page table index (bits 12:21). */ #define PTSHIFT PGBITS                     /* First page table bit. */ #define PTBITS  10                         /* Number of page table bits. */  /** Page directory index (bits 22:31). */ #define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */ #define PDBITS  10                         /* Number of page dir bits. */  /** Obtains page table index from a virtual address. */ static inline unsigned pt_no (const void *va) {   return ((uintptr_t) va &amp; PTMASK) &gt;&gt; PTSHIFT; }  /** Obtains page directory index from a virtual address. */ static inline uintptr_t pd_no (const void *va) {   return (uintptr_t) va &gt;&gt; PDSHIFT; }  /** Page entry flags. */ #define PTE_P 0x1               /* 1=present, 0=not present. */ #define PTE_W 0x2               /* 1=read/write, 0=read-only. */ #define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */  /** Returns a PDE that points to page table PT. */ static inline uint32_t pde_create (uint32_t *pt) {   ASSERT (pg_ofs (pt) == 0);   return vtop (pt) | PTE_U | PTE_P | PTE_W; }  /** Returns a PTE that points to PAGE.    The PTE's page is readable.    If WRITABLE is true then it will be writable as well.    The page will be usable only by ring 0 code (the kernel). */ static inline uint32_t pte_create_kernel (void *page, bool writable) {   ASSERT (pg_ofs (page) == 0);   return vtop (page) | PTE_P | (writable ? PTE_W : 0); }   前置知识  1. x86 两级页表结构  x86 保护模式使用两级页表进行地址转换：  32位虚拟地址 ┌──────────────┬──────────────┬──────────────┐ │  PD Index    │  PT Index    │   Offset     │ │  (10 bits)   │  (10 bits)   │  (12 bits)   │ └──────┬───────┴──────┬───────┴──────┬───────┘        │              │              │        │   ┌──────────┘              │        │   │                         │        ↓   │                         ↓    ┌───────┴──────┐             ┌─────────┐    │ Page Dir     │   ┌─────→ │ Physical│    │ (1024项)     │   │        │  Page   │    │ ┌─────────┐  │   │        │ (4KB)   │ CR3→│ PDE 0   │  │   │        └────┬────┘    │ ├─────────┤  │   │             │    │ │  ...    │  │   │             │    │ ├─────────┤  │   │             ↓    │ │PDE[idx] │──┼───┤        ┌─────────┐    │ ├─────────┤  │   │        │ 物理地址 │    │ │  ...    │  │   │        └─────────┘    │ └─────────┘  │   │    └──────────────┘   │                       │    ┌──────────────┐   │    │ Page Table   │◄──┘    │ (1024项)     │    │ ┌─────────┐  │    │ │ PTE 0   │  │    │ ├─────────┤  │    │ │  ...    │  │    │ ├─────────┤  │    │ │PTE[idx] │──────────────────→ 物理页帧    │ ├─────────┤  │    │ │  ...    │  │    │ └─────────┘  │    └──────────────┘   2. 页目录项（PDE）格式  31                                 12 11  9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ |    Page Table Physical Address     | AVL |G|S|0|A|D|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+                                            | | | | | | | | |                                            | | | | | | | | +-- Present                                            | | | | | | | +---- Read/Write                                            | | | | | | +------ User/Supervisor                                            | | | | | +-------- Write-Through                                            | | | | +---------- Cache Disable                                            | | | +------------ Accessed                                            | | +-------------- (reserved)                                            | +---------------- Page Size (0=4KB)                                            +------------------ Global   3. 页表项（PTE）格式  31                                 12 11  9 8 7 6 5 4 3 2 1 0 +------------------------------------+-----+-+-+-+-+-+-+-+-+-+ |      Physical Page Address         | AVL |G|0|D|A|C|W|U|R|P| +------------------------------------+-----+-+-+-+-+-+-+-+-+-+                                            | | | | | | | | |                                            | | | | | | | | +-- Present                                            | | | | | | | +---- Read/Write                                            | | | | | | +------ User/Supervisor                                            | | | | | +-------- Write-Through                                            | | | | +---------- Cache Disable                                            | | | +------------ Accessed                                            | | +-------------- Dirty                                            | +---------------- (reserved)                                            +------------------ Global   4. 临时页表 vs 永久页表                 特性       临时页表 (start.S)       永久页表 (paging_init)                       创建时机       进入保护模式前       内存系统初始化后                 覆盖范围       固定 64MB       所有检测到的物理内存                 位置       BSS 段静态分配       动态从内存池分配                 代码保护       无       内核代码段只读                 用途       启动过渡       长期运行           5. 链接器符号  链接器脚本（linker script）定义了一些特殊符号：    _start：内核代码段起始地址   _end_kernel_text：内核代码段结束地址   这些符号用于区分代码段和数据段，以便正确设置页面保护。  逐行代码解析  第1-3行：变量声明和外部符号  uint32_t *pd, *pt; size_t page; extern char _start, _end_kernel_text;   详细解析：     pd（Page Directory）：            类型：uint32_t *（指向32位整数的指针）       用途：指向页目录       页目录包含 1024 个 PDE（页目录项）           pt（Page Table）：            类型：uint32_t *       用途：指向当前正在填充的页表       每个页表包含 1024 个 PTE（页表项）           page：            循环变量，遍历所有物理页           外部符号：            _start：内核代码起始位置       _end_kernel_text：内核代码结束位置       这些符号由链接器自动生成           第4行：分配页目录  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);   详细解析：     palloc_get_page 调用：            PAL_ASSERT：分配失败时触发 PANIC       PAL_ZERO：将页清零（所有 PDE 初始化为 0，即”不存在”）           双重赋值：            pd：局部变量，方便后续访问       init_page_dir：全局变量，供其他模块使用           为什么需要清零？            PDE 值为 0 表示页表项”不存在”       CPU 访问不存在的页会触发 Page Fault       确保未映射的地址不会被意外访问           页目录初始状态：  页目录 (4KB) ┌───────────────┐ pd[0] │      0        │ (不存在) ├───────────────┤ pd[1] │      0        │ (不存在) ├───────────────┤ │     ...       │ ├───────────────┤ pd[1023] │      0        │ (不存在) └───────────────┘   第5行：初始化页表指针  pt = NULL;   详细解析：     初始化为 NULL，表示还没有分配任何页表   后续循环中会按需分配页表   第6-7行：遍历所有物理页  for (page = 0; page &lt; init_ram_pages; page++) {   uintptr_t paddr = page * PGSIZE;   详细解析：     循环范围：            从物理页 0 开始       到 init_ram_pages - 1 结束       覆盖所有检测到的物理内存           物理地址计算：            paddr = page * 4096       每次循环处理一个 4KB 物理页           示例：假设有 4MB 物理内存（1024 页）    page = 0: paddr = 0x00000000   page = 1: paddr = 0x00001000   page = 255: paddr = 0x000FF000   page = 256: paddr = 0x00100000 (1MB)   …   第8行：计算虚拟地址  char *vaddr = ptov (paddr);   详细解析：     ptov(paddr) = paddr + PHYS_BASE = paddr + 0xC0000000   建立物理地址到虚拟地址的映射   映射示例：                 物理地址       虚拟地址                       0x00000000       0xC0000000                 0x00001000       0xC0001000                 0x00100000       0xC0100000                 0x003FF000       0xC03FF000           第9-10行：提取页表索引  size_t pde_idx = pd_no (vaddr); size_t pte_idx = pt_no (vaddr);   详细解析：     pd_no (vaddr)：            提取虚拟地址的高 10 位（bits 22-31）       范围：0 - 1023       用于索引页目录           pt_no (vaddr)：            提取虚拟地址的中间 10 位（bits 12-21）       范围：0 - 1023       用于索引页表           地址分解示例：  虚拟地址 0xC0001000 (对应物理地址 0x00001000)  二进制: 1100 0000 0000 0000 0001 0000 0000 0000         ├────────┬─┤├────────┬─┤├────────┬───┤          PD Index    PT Index     Offset            768          1           0  pde_idx = 768 (0x300) pte_idx = 1 offset  = 0   第11行：判断是否为内核代码段  bool in_kernel_text = &amp;_start &lt;= vaddr &amp;&amp; vaddr &lt; &amp;_end_kernel_text;   详细解析：     判断条件：            检查当前虚拟地址是否在内核代码段范围内       _start：内核代码起始       _end_kernel_text：内核代码结束           为什么需要区分？            代码段应该是只读的（不应被修改）       数据段需要是可写的       这是基本的内存保护机制           内核内存布局：  ┌─────────────────────┐ _start (约 0xC0020000) │                     │ │    .text 段         │ ← 代码段（只读） │    (内核代码)        │ │                     │ ├─────────────────────┤ _end_kernel_text │                     │ │    .rodata 段       │ ← 只读数据 │                     │ ├─────────────────────┤ │                     │ │    .data 段         │ ← 已初始化数据（可写） │                     │ ├─────────────────────┤ │                     │ │    .bss 段          │ ← 未初始化数据（可写） │                     │ └─────────────────────┘   第12-16行：按需分配页表  if (pd[pde_idx] == 0) {   pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);   pd[pde_idx] = pde_create (pt); }   详细解析：     检查条件：            pd[pde_idx] == 0 表示该页目录项尚未指向任何页表       需要分配一个新的页表           分配页表：            palloc_get_page(PAL_ASSERT | PAL_ZERO)       获取一个清零的页作为页表       一个页表可以容纳 1024 个 PTE           创建 PDE：            pde_create(pt) 构造页目录项                                                       设置标志位：PTE_U               PTE_P               PTE_W                                                   pde_create 函数分析：  static inline uint32_t pde_create (uint32_t *pt) {   ASSERT (pg_ofs (pt) == 0);        // 确保页表页对齐   return vtop (pt) | PTE_U | PTE_P | PTE_W; }      vtop(pt)：将页表的虚拟地址转换为物理地址   PTE_P：Present 位，表示页表存在   PTE_W：Writable 位，允许写入   PTE_U：User 位，允许用户态访问（这里设置是为了支持用户程序）   PDE 格式：  31                                    12 11        0 +---------------------------------------+----------+ |     Page Table Physical Address       |   Flags  | +---------------------------------------+----------+                                         PTE_U = 0x4                                         PTE_W = 0x2                                         PTE_P = 0x1                                          结果: PDE = (pt 物理地址) | 0x7   第17行：创建页表项  pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);   详细解析：     pte_create_kernel 调用：            第一个参数：虚拟地址（用于计算物理页地址）       第二个参数：是否可写                    !in_kernel_text：如果在代码段内，不可写           代码段：writable = false           数据段：writable = true                           pte_create_kernel 函数分析：  static inline uint32_t pte_create_kernel (void *page, bool writable) {   ASSERT (pg_ofs (page) == 0);      // 确保地址页对齐   return vtop (page) | PTE_P | (writable ? PTE_W : 0); }      vtop(page)：将虚拟地址转换为物理地址   PTE_P：Present 位   条件设置 PTE_W：根据 writable 参数决定   注意：没有设置 PTE_U，所以这些页只能在内核态（Ring 0）访问。  PTE 格式示例：  代码段页（只读）： 31                           12 11        0 +------------------------------+----------+ |    Physical Page Address     | 00000001 | +------------------------------+----------+                                  PTE_P = 1                                  PTE_W = 0 (只读)                                  PTE_U = 0 (仅内核)  数据段页（可写）： 31                           12 11        0 +------------------------------+----------+ |    Physical Page Address     | 00000011 | +------------------------------+----------+                                  PTE_P = 1                                  PTE_W = 1 (可写)                                  PTE_U = 0 (仅内核)   第18-22行：激活新页表  /* Store the physical address of the page directory into CR3    aka PDBR (page directory base register).  This activates our    new page tables immediately.  See [IA32-v2a] \"MOV--Move    to/from Control Registers\" and [IA32-v3a] 3.7.5 \"Base Address    of the Page Directory\". */ asm volatile (\"movl %0, %%cr3\" : : \"r\" (vtop (init_page_dir)));   详细解析：     内联汇编语法：            asm volatile：告诉编译器这是汇编代码，不要优化       \"movl %0, %%cr3\"：将操作数 0 移动到 CR3 寄存器       : :：无输出操作数       \"r\" (vtop (init_page_dir))：输入操作数，使用任意通用寄存器           CR3 寄存器：            也称为 PDBR（Page Directory Base Register）       存储页目录的物理地址       修改 CR3 会导致 TLB（Translation Lookaside Buffer）刷新           地址转换：            init_page_dir 是虚拟地址       vtop() 将其转换为物理地址       CPU 需要物理地址来定位页目录           为什么使用 volatile？     防止编译器优化掉这条指令   确保页表切换立即发生   这是一个有副作用的操作（改变内存映射）   页表切换图示：                          切换前 (临时页表)                     ┌─────────────────────┐                     │  旧页目录 (BSS)      │            CR3 ─────→  位于 init.c        │                     └─────────────────────┘                          ↓ movl %0, %%cr3 ↓                          切换后 (永久页表)                     ┌─────────────────────┐                     │  新页目录 (动态分配) │            CR3 ─────→  位于内核池         │                     └─────────────────────┘   完整地址转换示例  假设访问虚拟地址 0xC0123456：  步骤1：分解虚拟地址  0xC0123456 = 1100 0000 0001 0010 0011 0100 0101 0110  PD Index  = 1100 0000 01 = 769 (0x301) PT Index  = 00 0010 0011 = 35 (0x23) Offset    = 0100 0101 0110 = 0x456   步骤2：查找页目录  PDE = pd[769]     = 页表的物理地址 | PTE_U | PTE_P | PTE_W   步骤3：查找页表  pt = PDE &amp; 0xFFFFF000  (提取页表物理地址) PTE = pt[35]     = 物理页的地址 | PTE_P | (PTE_W)   步骤4：计算物理地址  物理页帧 = PTE &amp; 0xFFFFF000 物理地址 = 物理页帧 + 0x456          = 0x00123000 + 0x456          = 0x00123456   完整转换图：  虚拟地址: 0xC0123456               │               ↓ ┌─────────────────────────────────────────────────────┐ │                                                     │ │    ┌──────────────┐                                │ │    │    CR3       │──────────┐                     │ │    └──────────────┘          │                     │ │                              ↓                     │ │    ┌─────────────────────────────────┐             │ │    │         Page Directory          │             │ │    │  ┌───────────────────────────┐  │             │ │    │  │ pd[0]                     │  │             │ │    │  │ ...                       │  │             │ │    │  │ pd[769] ─────────────────────────┐         │ │    │  │ ...                       │  │   │         │ │    │  │ pd[1023]                  │  │   │         │ │    │  └───────────────────────────┘  │   │         │ │    └─────────────────────────────────┘   │         │ │                                          ↓         │ │    ┌─────────────────────────────────────────┐     │ │    │            Page Table                   │     │ │    │  ┌───────────────────────────────────┐  │     │ │    │  │ pt[0]                             │  │     │ │    │  │ ...                               │  │     │ │    │  │ pt[35] = 0x00123003 ─────────────────────┐ │ │    │  │ ...                               │  │   │ │ │    │  │ pt[1023]                          │  │   │ │ │    │  └───────────────────────────────────┘  │   │ │ │    └─────────────────────────────────────────┘   │ │ │                                                  │ │ │    ┌─────────────────────────────────────────┐   │ │ │    │          Physical Page                  │◄──┘ │ │    │  ┌───────────────────────────────────┐  │     │ │    │  │ offset 0x000                      │  │     │ │    │  │ ...                               │  │     │ │    │  │ offset 0x456 ◄── 目标数据         │  │     │ │    │  │ ...                               │  │     │ │    │  │ offset 0xFFF                      │  │     │ │    │  └───────────────────────────────────┘  │     │ │    └─────────────────────────────────────────┘     │ │                                                     │ └─────────────────────────────────────────────────────┘               │               ↓ 物理地址: 0x00123456   页表覆盖范围分析  内核地址空间布局  虚拟地址空间 (4GB) ┌───────────────────────────────────┐ 0xFFFFFFFF │                                   │ │         内核空间 (1GB)            │ │                                   │ │  ┌───────────────────────────┐   │ │  │ 物理内存直接映射           │   │ │  │ 0xC0000000 → 物理 0x0     │   │ │  │ 0xC0001000 → 物理 0x1000  │   │ │  │      ...                   │   │ │  │ 0xC0000000+RAM → 物理 RAM │   │ │  └───────────────────────────┘   │ │                                   │ ├───────────────────────────────────┤ 0xC0000000 (PHYS_BASE) │                                   │ │                                   │ │         用户空间 (3GB)            │ │         (未映射)                  │ │                                   │ │                                   │ └───────────────────────────────────┘ 0x00000000   需要的页表数量  假设物理内存为 N MB：     每个页表覆盖：4MB（1024 × 4KB）   需要的页表数：⌈N MB / 4 MB⌉   示例：                 物理内存       页目录索引范围       需要的页表数                       4 MB       768       1                 8 MB       768-769       2                 64 MB       768-783       16                 256 MB       768-831       64           页表索引计算  对于内核映射（从 PHYS_BASE 开始）：  PHYS_BASE = 0xC0000000  PD Index = 0xC0000000 &gt;&gt; 22 = 768 (0x300)   所以内核映射从页目录的第 768 项开始。  与临时页表的对比  临时页表（start.S）  # 临时页表：固定映射 64MB .align PGSIZE init_page_dir:     .long 0x00000087    # PDE[0]: 映射 0-4MB     .fill 767, 4, 0     # PDE[1-767]: 空     .long 0x00000087    # PDE[768]: 映射 0-4MB 到 0xC0000000-0xC03FFFFF     # ... 更多固定 PDE   永久页表（paging_init）  // 动态映射所有检测到的内存 for (page = 0; page &lt; init_ram_pages; page++) {     // 按需分配页表     // 正确设置代码段保护 }   主要区别：                 特性       临时页表       永久页表                       大小       固定 64MB       动态（检测到的内存）                 分配方式       静态（BSS）       动态（palloc）                 代码保护       无       代码段只读                 页表数量       固定 16 个       按需分配                 恒等映射       有（方便切换）       无（不再需要）           TLB 刷新  修改 CR3 会自动刷新整个 TLB：  写入 CR3 前: ┌─────────────────────────────────┐ │             TLB                 │ │  ┌─────────────────────────┐   │ │  │ VA 0xC0001000 → PA 0x1000│   │ 旧的缓存项 │  │ VA 0xC0002000 → PA 0x2000│   │ │  │ ...                      │   │ │  └─────────────────────────┘   │ └─────────────────────────────────┘  写入 CR3 后: ┌─────────────────────────────────┐ │             TLB                 │ │  ┌─────────────────────────┐   │ │  │         (空)             │   │ 所有条目被清除 │  └─────────────────────────┘   │ └─────────────────────────────────┘  后续访问会重新填充 TLB   常见问题解答  Q1: 为什么页目录项设置了 PTE_U（用户位）？  A: 虽然内核映射只在内核态使用，但 PDE 的 PTE_U 位需要设置为 1，原因是：    用户程序的页表也会使用同一个页目录   如果 PDE 设置 PTE_U=0，即使 PTE 设置 PTE_U=1，用户程序也无法访问   实际的访问控制由 PTE 的 PTE_U 位决定   Q2: 为什么代码段设置为只读？  A:    安全性：防止恶意或错误代码修改内核指令   调试：写入代码段会触发 Page Fault，便于发现 bug   稳定性：防止缓冲区溢出覆盖代码   Q3: 切换页表时会不会导致问题？  A: 不会，因为：    新旧页表对内核地址的映射完全相同   CPU 当前执行的代码在切换前后都能正确访问   栈和数据也都被正确映射   Q4: 如果物理内存很大，页表会占用多少内存？  A:    页目录：1 页 = 4KB   每 4MB 物理内存需要 1 个页表 = 4KB   例如 256MB 内存：1 + 64 = 65 页 = 260KB   这是相当高效的：260KB 管理 256MB，开销约 0.1%  练习题  练习1：地址分解  给定虚拟地址 0xC0BADCAFE（假设有足够内存），计算：    页目录索引（PD Index）   页表索引（PT Index）   页内偏移（Offset）   对应的物理地址   练习2：页表数量估算  如果系统有 512MB 物理内存：    需要多少个页表？   页目录和所有页表共占用多少内存？   练习3：代码保护验证  修改 paging_init，使数据段也变为只读：    预测会发生什么？   如何安全地测试这个修改？   练习4：添加恒等映射  如果需要在永久页表中保留低地址的恒等映射（物理地址 = 虚拟地址），需要如何修改 paging_init？  提示：考虑需要额外映射哪些地址，以及何时可以安全移除这些映射。  下一篇预告  在下一篇文档中，我们将详细解析线程系统的初始化 thread_init()，了解 Pintos 如何设置主线程和调度器基础设施。  参考资料     Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide - Chapter 4: Paging   Pintos Reference Guide - Virtual Memory   OSDev Wiki - Paging"
  },
  
  {
    "title": "Pintos Kernel 10 Memory Init",
    "url": "/posts/pintos-kernel-10-memory-init/",
    "categories": "",
    "tags": "",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "Pintos 内核启动（十）：内存系统初始化  概述  本文档详细解析 Pintos 内核的内存系统初始化过程，包括页分配器 palloc_init() 和动态内存分配器 malloc_init() 的初始化。内存系统是操作系统最核心的子系统之一，它为内核和用户程序提供内存分配服务。  Pintos 的内存管理采用两级分配策略：    页分配器（Page Allocator）：以页（4KB）为单位分配物理内存   块分配器（Block Allocator）：在页的基础上，提供任意大小的内存分配   原始代码  palloc.c 中的 palloc_init() 函数  /* Pool allocator data structure. */ struct pool   {     struct lock lock;           /* Mutual exclusion. */     struct bitmap *used_map;    /* Bitmap of free pages. */     uint8_t *base;              /* Base of pool. */   };  /* Two pools: one for kernel data, one for user pages. */ static struct pool kernel_pool, user_pool;  /* Initializes the page allocator.  At most USER_PAGE_LIMIT    pages are put into the user pool. */ void palloc_init (size_t user_page_limit) {   /* Free memory starts at 1 MB and runs to the end of RAM. */   uint8_t *free_start = ptov (1024 * 1024);   uint8_t *free_end = ptov (init_ram_pages * PGSIZE);   size_t free_pages = (free_end - free_start) / PGSIZE;   size_t user_pages = free_pages / 2;   size_t kernel_pages;   if (user_pages &gt; user_page_limit)     user_pages = user_page_limit;   kernel_pages = free_pages - user_pages;    /* Give half of memory to kernel, half to user. */   init_pool (&amp;kernel_pool, free_start, kernel_pages, \"kernel pool\");   init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE,              user_pages, \"user pool\"); }  /* Initializes pool P as starting at START and ending at END,    naming it NAME for debugging purposes. */ static void init_pool (struct pool *p, void *base, size_t page_cnt, const char *name)  {   /* We'll put the pool's used_map at its base.      Calculate the space needed for the bitmap      and subtract it from the pool's size. */   size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);   if (bm_pages &gt; page_cnt)     PANIC (\"Not enough memory in %s for bitmap.\", name);   page_cnt -= bm_pages;    printf (\"%zu pages available in %s.\\n\", page_cnt, name);    /* Initialize the pool. */   lock_init (&amp;p-&gt;lock);   p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);   p-&gt;base = base + bm_pages * PGSIZE; }   malloc.c 中的 malloc_init() 函数  /* Descriptor. */ struct desc   {     size_t block_size;          /* Size of each element in bytes. */     size_t blocks_per_arena;    /* Number of blocks in an arena. */     struct list free_list;      /* List of free blocks. */     struct lock lock;           /* Lock. */   };  /* Arena. */ struct arena    {     unsigned magic;             /* Always set to ARENA_MAGIC. */     struct desc *desc;          /* Owning descriptor, null for big block. */     size_t free_cnt;            /* Free blocks; pages in big block. */   };  /* Our set of descriptors. */ static struct desc descs[10];   /* Descriptors. */ static size_t desc_cnt;         /* Number of descriptors. */  /* Initializes the malloc() descriptors. */ void malloc_init (void)  {   size_t block_size;    for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2)     {       struct desc *d = &amp;descs[desc_cnt++];       ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs);       d-&gt;block_size = block_size;       d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;       list_init (&amp;d-&gt;free_list);       lock_init (&amp;d-&gt;lock);     } }   前置知识  1. 内存布局回顾  在 Pintos 启动时，内存布局如下：  物理地址                   内容 ┌─────────────────────┐ │  0x00000 - 0x003FF  │   实模式中断向量表 ├─────────────────────┤ │  0x00400 - 0x004FF  │   BIOS 数据区 ├─────────────────────┤ │  0x07C00 - 0x07DFF  │   引导扇区（loader） ├─────────────────────┤ │  0x20000 - 0x????? │   内核代码和数据 ├─────────────────────┤ │  0xA0000 - 0xBFFFF  │   VGA 显存 ├─────────────────────┤ │  0xC0000 - 0xFFFFF  │   BIOS ROM ├─────────────────────┤ │  0x100000 (1 MB)    │   可用内存开始 │         ...         │   空闲内存 │  init_ram_pages*4KB │   内存结束 └─────────────────────┘   2. 虚拟地址与物理地址转换  Pintos 使用简单的地址映射：    物理地址 → 虚拟地址：ptov(phys) = phys + PHYS_BASE   虚拟地址 → 物理地址：vtop(virt) = virt - PHYS_BASE   其中 PHYS_BASE = 0xC0000000（3GB）。  3. 位图（Bitmap）  位图是一种高效的数据结构，用于追踪资源的使用状态：    每个比特代表一个页的状态（0=空闲，1=已使用）   空间效率高：管理 N 页只需要 N/8 字节   操作效率：O(1) 的单页操作，O(N) 的连续页搜索   4. Slab 分配器思想  malloc 实现采用了类似 Slab 分配器的思想：    Arena：一个页大小的内存块   Block：Arena 中固定大小的分配单元   Descriptor：管理某种大小块的描述符   逐行代码解析  palloc_init() 函数解析  第1-2行：计算可用内存范围  uint8_t *free_start = ptov (1024 * 1024); uint8_t *free_end = ptov (init_ram_pages * PGSIZE);   详细解析：     free_start 的计算：            1024 * 1024 = 0x100000 是物理地址 1MB       ptov(0x100000) 转换为虚拟地址 0xC0100000       为什么从 1MB 开始？因为低 1MB 包含：                    实模式中断向量表和 BIOS 数据区           引导代码           内核代码（加载到 0x20000）           VGA 显存（0xA0000-0xBFFFF）           BIOS ROM（0xC0000-0xFFFFF）                           free_end 的计算：            init_ram_pages 是在 start.S 中通过 BIOS 调用检测到的内存页数       init_ram_pages * PGSIZE 是物理内存的总大小（字节）       ptov() 将其转换为对应的虚拟地址           第3-7行：计算内核和用户页数  size_t free_pages = (free_end - free_start) / PGSIZE; size_t user_pages = free_pages / 2; size_t kernel_pages; if (user_pages &gt; user_page_limit)   user_pages = user_page_limit; kernel_pages = free_pages - user_pages;   详细解析：          free_pages：总的可用页数 = (内存结束 - 1MB) / 页大小      内存分配策略：            默认将可用内存平分给内核和用户       user_page_limit 参数可以限制用户池的最大大小       内核池获得剩余的所有页           为什么需要 user_page_limit？            在测试环境中，可能需要限制用户内存来测试内存不足的情况       默认值来自命令行参数 --ul=           数值示例： 假设物理内存为 4MB（init_ram_pages = 1024）：    free_pages = (4MB - 1MB) / 4KB = 768 页   user_pages = 768 / 2 = 384 页   kernel_pages = 768 - 384 = 384 页   第8-10行：初始化内存池  init_pool (&amp;kernel_pool, free_start, kernel_pages, \"kernel pool\"); init_pool (&amp;user_pool, free_start + kernel_pages * PGSIZE,            user_pages, \"user pool\");   详细解析：  内存池的布局：  虚拟地址 ┌─────────────────────────────┐ 0xC0100000 (1MB 物理地址) │                             │ │       内核池（kernel_pool） │ │                             │ ├─────────────────────────────┤ 0xC0100000 + kernel_pages * 4KB │                             │ │       用户池（user_pool）   │ │                             │ └─────────────────────────────┘ 内存结束   init_pool() 函数解析  第1-4行：计算位图所需空间  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE); if (bm_pages &gt; page_cnt)   PANIC (\"Not enough memory in %s for bitmap.\", name); page_cnt -= bm_pages;   详细解析：     位图大小计算：            bitmap_buf_size(page_cnt) 返回管理 page_cnt 页需要的位图字节数       公式：ceiling(page_cnt / 8) 字节       DIV_ROUND_UP 将字节数向上取整到页           空间检查：            如果位图本身需要的页数超过了总页数，说明内存太小       这是一个致命错误，触发内核 PANIC           调整可用页数：            位图占用的页不能再用于分配       实际可用页数 = 原始页数 - 位图页数           数值示例： 假设 page_cnt = 384：    位图需要 384 / 8 = 48 字节   向上取整到页：1 页   实际可用：384 - 1 = 383 页   第5-9行：初始化池结构  printf (\"%zu pages available in %s.\\n\", page_cnt, name);  lock_init (&amp;p-&gt;lock); p-&gt;used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE); p-&gt;base = base + bm_pages * PGSIZE;   详细解析：     打印信息：启动时会看到类似输出：     383 pages available in kernel pool. 383 pages available in user pool.           锁初始化：            每个池有独立的锁       保证多线程访问时的互斥           位图创建：            bitmap_create_in_buf 在预分配的缓冲区中创建位图       位图放在池的起始位置       所有位初始化为 0（表示空闲）           基址调整：            p-&gt;base 是实际可分配内存的起始地址       跳过位图占用的空间           池结构布局：                      pool 结构                  ┌─────────────┐                  │    lock     │ 互斥锁                  ├─────────────┤                  │  used_map   │───┐ 指向位图                  ├─────────────┤   │                  │    base     │───┼──┐ 指向可分配内存                  └─────────────┘   │  │                                    │  │ 池内存布局                          │  │ ┌─────────────────────────────┐   │  │ │      位图区（bm_pages）      │◄──┘  │ │  [0|0|0|0|0|0|0|0|...]     │       │ ├─────────────────────────────┤◄─────┘ │         第 0 页             │ ├─────────────────────────────┤ │         第 1 页             │ ├─────────────────────────────┤ │          ...                │ ├─────────────────────────────┤ │      第 page_cnt-1 页       │ └─────────────────────────────┘   malloc_init() 函数解析  第1-2行：循环初始化描述符  size_t block_size;  for (block_size = 16; block_size &lt; PGSIZE / 2; block_size *= 2)   详细解析：     块大小范围：            最小块：16 字节       最大块：PGSIZE / 2 = 2048 字节（不含）       实际大小：16, 32, 64, 128, 256, 512, 1024 字节           为什么最小是 16 字节？            struct block 至少需要存储一个 list_elem（8 字节）       对齐要求和实用性考虑           为什么最大是 2KB？            Arena 头部占用空间       需要保证至少能放 2 个块           第3-9行：初始化每个描述符  {   struct desc *d = &amp;descs[desc_cnt++];   ASSERT (desc_cnt &lt;= sizeof descs / sizeof *descs);   d-&gt;block_size = block_size;   d-&gt;blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;   list_init (&amp;d-&gt;free_list);   lock_init (&amp;d-&gt;lock); }   详细解析：     描述符数组：            descs[10] 预分配 10 个描述符槽位       实际使用 7 个（16 到 1024）           每 Arena 块数计算：            PGSIZE = 4096 字节       sizeof(struct arena) 约 12 字节       公式：(4096 - 12) / block_size           各描述符配置：                  desc_cnt       block_size       blocks_per_arena                       0       16       255                 1       32       127                 2       64       63                 3       128       31                 4       256       15                 5       512       7                 6       1024       3              空闲链表：            每个描述符维护一个空闲块链表       初始为空，按需分配 Arena           锁：            每个描述符有独立的锁       不同大小的分配可以并行进行           描述符与 Arena 关系图：  描述符数组 descs[] ┌─────────────┬─────────────┬─────────────┬─────────────┐ │  desc[0]    │  desc[1]    │  desc[2]    │    ...      │ │ size=16     │ size=32     │ size=64     │             │ │ blocks=255  │ blocks=127  │ blocks=63   │             │ │ free_list ──┼─→           │ free_list ──┼─→           │ └──────┼──────┴─────────────┴──────┼──────┴─────────────┘        │                           │        ↓                           ↓    ┌───────┐                   ┌───────┐    │Arena A│                   │Arena C│    │header │                   │header │    ├───────┤                   ├───────┤    │block 0│                   │block 0│    │block 1│                   │block 1│    │  ...  │                   │  ...  │    │blk 254│                   │blk 62 │    └───────┘                   └───────┘   内存分配流程  页分配 palloc_get_multiple()  void * palloc_get_multiple (enum palloc_flags flags, size_t page_cnt) {   struct pool *pool = flags &amp; PAL_USER ? &amp;user_pool : &amp;kernel_pool;   void *pages;   size_t page_idx;    if (page_cnt == 0)     return NULL;    lock_acquire (&amp;pool-&gt;lock);   page_idx = bitmap_scan_and_flip (pool-&gt;used_map, 0, page_cnt, false);   lock_release (&amp;pool-&gt;lock);    if (page_idx != BITMAP_ERROR)     pages = pool-&gt;base + PGSIZE * page_idx;   else     pages = NULL;    if (pages != NULL)      {       if (flags &amp; PAL_ZERO)         memset (pages, 0, PGSIZE * page_cnt);     }   else      {       if (flags &amp; PAL_ASSERT)         PANIC (\"palloc_get: out of pages\");     }    return pages; }   分配流程：  palloc_get_multiple(PAL_USER | PAL_ZERO, 3)               │               ↓     ┌─────────────────────┐     │ 1. 选择内存池       │     │    PAL_USER → user  │     │    否则 → kernel    │     └─────────┬───────────┘               ↓     ┌─────────────────────┐     │ 2. 获取池锁         │     └─────────┬───────────┘               ↓     ┌─────────────────────┐     │ 3. 在位图中搜索     │     │    连续3个空闲位    │     │    并设置为已使用   │     └─────────┬───────────┘               ↓     ┌─────────────────────┐     │ 4. 释放池锁         │     └─────────┬───────────┘               ↓     ┌─────────────────────┐     │ 5. 计算页地址       │     │ addr = base + idx*4K│     └─────────┬───────────┘               ↓     ┌─────────────────────┐     │ 6. PAL_ZERO?        │     │    是 → memset(0)   │     └─────────┬───────────┘               ↓          返回地址   块分配 malloc()  void *malloc (size_t size)   分配流程：  malloc(100)     │     ↓ ┌───────────────────────┐ │ 1. 查找合适的描述符   │ │    100 → desc[3]      │ │    (block_size=128)   │ └───────────┬───────────┘             ↓ ┌───────────────────────┐ │ 2. 获取描述符锁       │ └───────────┬───────────┘             ↓ ┌───────────────────────┐ │ 3. free_list 空?      │ │    是 → 分配新 Arena  │ │    否 → 跳到步骤 5    │ └───────────┬───────────┘             ↓ ┌───────────────────────┐ │ 4. 初始化 Arena       │ │    - 设置 magic       │ │    - 关联描述符       │ │    - 添加所有块到     │ │      free_list        │ └───────────┬───────────┘             ↓ ┌───────────────────────┐ │ 5. 从 free_list 取块  │ │    更新 arena.free_cnt│ └───────────┬───────────┘             ↓ ┌───────────────────────┐ │ 6. 释放描述符锁       │ └───────────┬───────────┘             ↓         返回块地址   内存释放流程  页释放 palloc_free_multiple()  void palloc_free_multiple (void *pages, size_t page_cnt)  {   struct pool *pool;   size_t page_idx;    ASSERT (pg_ofs (pages) == 0);   if (pages == NULL || page_cnt == 0)     return;    if (page_from_pool (&amp;kernel_pool, pages))     pool = &amp;kernel_pool;   else if (page_from_pool (&amp;user_pool, pages))     pool = &amp;user_pool;   else     NOT_REACHED ();    page_idx = pg_no (pages) - pg_no (pool-&gt;base);  #ifndef NDEBUG   memset (pages, 0xcc, PGSIZE * page_cnt); #endif    ASSERT (bitmap_all (pool-&gt;used_map, page_idx, page_cnt));   bitmap_set_multiple (pool-&gt;used_map, page_idx, page_cnt, false); }   释放流程：     地址验证：检查地址是否页对齐   确定所属池：判断页属于内核池还是用户池   计算页索引：page_idx = 页号 - 池基址页号   调试填充：非 Release 版本填充 0xCC（帮助检测 use-after-free）   更新位图：将对应位设置为 0（空闲）   块释放 free()  void free (void *p)   释放流程：     找到块所属的 Arena   验证 Arena 魔数   获取描述符锁   将块加入空闲链表   如果 Arena 完全空闲：            从空闲链表移除所有块       归还页给页分配器           释放描述符锁   内存分配标志  enum palloc_flags   {     PAL_ASSERT = 001,   /* 分配失败时 panic */     PAL_ZERO = 002,     /* 将页清零 */     PAL_USER = 004      /* 从用户池分配 */   };   使用示例：  /* 分配一个清零的内核页 */ void *kpage = palloc_get_page(PAL_ZERO);  /* 分配一个用户页，失败时 panic */ void *upage = palloc_get_page(PAL_USER | PAL_ASSERT);  /* 分配 4 个连续的内核页 */ void *pages = palloc_get_multiple(0, 4);   Arena 内存布局  单个 Arena 的详细布局：  Arena (4096 字节 = 1 页) ┌─────────────────────────────────┐ offset 0 │          struct arena           │ │  ┌─────────────────────────┐   │ │  │ magic = 0x9a548eed      │   │ 4 bytes │  ├─────────────────────────┤   │ │  │ desc (指向描述符)       │   │ 4 bytes │  ├─────────────────────────┤   │ │  │ free_cnt                │   │ 4 bytes │  └─────────────────────────┘   │ ├─────────────────────────────────┤ offset ~12 │           Block 0               │ │  ┌─────────────────────────┐   │ │  │ free_elem (if free)     │   │ │  │ 或 用户数据 (if used)   │   │ │  └─────────────────────────┘   │ ├─────────────────────────────────┤ │           Block 1               │ ├─────────────────────────────────┤ │            ...                  │ ├─────────────────────────────────┤ │    Block (blocks_per_arena-1)   │ └─────────────────────────────────┘ offset 4096   大块分配  对于超过 1KB 的分配请求：  if (d == descs + desc_cnt)  {   /* SIZE is too big for any descriptor.      Allocate enough pages to hold SIZE plus an arena. */   size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);   a = palloc_get_multiple (0, page_cnt);   if (a == NULL)     return NULL;    /* Initialize the arena to indicate a big block of PAGE_CNT      pages, and return it. */   a-&gt;magic = ARENA_MAGIC;   a-&gt;desc = NULL;          /* 标记为大块 */   a-&gt;free_cnt = page_cnt;  /* 存储页数 */   return a + 1; }   大块布局：  ┌─────────────────────────────────┐ │          struct arena           │  第 0 页 │  ┌─────────────────────────┐   │ │  │ magic = 0x9a548eed      │   │ │  │ desc = NULL (大块标记)   │   │ │  │ free_cnt = 页数         │   │ │  └─────────────────────────┘   │ ├─────────────────────────────────┤ │                                 │ │         用户数据区              │ │       (page_cnt * 4KB          │ │        - sizeof arena)         │ │                                 │ └─────────────────────────────────┘   调试支持  Use-After-Free 检测  #ifndef NDEBUG   /* Clear the block to help detect use-after-free bugs. */   memset (b, 0xcc, d-&gt;block_size); #endif      释放的内存填充 0xCC   如果程序访问已释放的内存，会读到 0xCCCCCCCC   这个值作为指针是无效的，容易暴露 bug   Arena 完整性检查  /* Check that the arena is valid. */ ASSERT (a != NULL); ASSERT (a-&gt;magic == ARENA_MAGIC);      魔数 0x9a548eed 检测内存损坏   如果 Arena 头部被覆写，魔数会变化   常见问题解答  Q1: 为什么需要两个内存池？  A: 分离内核和用户内存有多个好处：    安全性：用户程序无法直接访问内核内存   资源控制：可以限制用户程序的内存使用   简化回收：进程退出时只需回收用户池中的页   Q2: 为什么 malloc 使用 2 的幂次块大小？  A:    对齐友好：2 的幂次自然满足各种对齐要求   减少碎片：标准化的块大小减少外部碎片   快速匹配：可以用位操作快速找到合适的描述符   内部碎片可控：最多浪费 50%   Q3: 如何处理内存碎片？  A: Pintos 的设计减少了碎片：    页分配器：只有外部碎片（无法找到连续空闲页）   块分配器：            内部碎片：请求 20 字节分配 32 字节       外部碎片：通过 Arena 归还机制缓解           Q4: palloc_init 为什么从 1MB 开始？  A: 低 1MB 内存布局复杂：    0-1KB：实模式中断向量表   1KB-640KB：常规内存（但已被内核占用）   640KB-1MB：VGA 和 BIOS ROM   从 1MB 开始可以获得干净的连续内存。  练习题  练习1：分析内存效率  假设系统有 8MB 物理内存，计算：    内核池和用户池各有多少可用页？   内核池位图占用多少空间？   提示：    可用内存 = 8MB - 1MB = 7MB   总页数 = 7MB / 4KB = 1792 页   练习2：理解 malloc 选择  对于以下分配请求，malloc 会使用哪个描述符？    malloc(1)   malloc(17)   malloc(1000)   malloc(2000)   malloc(5000)   练习3：实现内存统计  在 palloc.c 中添加函数，返回当前可用的空闲页数：  size_t palloc_free_pages(enum palloc_flags flags);   练习4：分析并发安全  分析以下场景是否线程安全：    线程 A 调用 malloc(32)，线程 B 调用 malloc(64)   线程 A 调用 malloc(32)，线程 B 调用 malloc(32)   线程 A 调用 palloc_get_page(PAL_USER)，线程 B 调用 palloc_get_page(0)   下一篇预告  在下一篇文档中，我们将详细解析 paging_init() 函数，了解 Pintos 如何建立永久的页表结构，替换 start.S 中创建的临时页表。  参考资料     Intel 64 and IA-32 Architectures Software Developer’s Manual   Pintos Documentation - Memory Allocation   The Slab Allocator: An Object-Caching Kernel Memory Allocator"
  },
  
  {
    "title": "Pintos Kernel 启动详解（九）：命令行解析",
    "url": "/posts/pintos-kernel-09-command-line/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, C语言, 命令行, 参数解析",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  内核命令行参数允许用户在启动时配置 Pintos 的行为。例如：  pintos -- -q run alarm-multiple   这会传递参数给内核，指定要运行的测试和完成后关机。  本文详细介绍 Pintos 如何从 Loader 获取命令行参数，以及如何解析这些参数。    原始代码  read_command_line()  /** Breaks the kernel command line into words and returns them as    an argv-like array. */ static char ** read_command_line (void)  {   static char *argv[LOADER_ARGS_LEN / 2 + 1];   char *p, *end;   int argc;   int i;    argc = *(uint32_t *) ptov (LOADER_ARG_CNT);   p = ptov (LOADER_ARGS);   end = p + LOADER_ARGS_LEN;   for (i = 0; i &lt; argc; i++)      {       if (p &gt;= end)         PANIC (\"command line arguments overflow\");        argv[i] = p;       p += strnlen (p, end - p) + 1;     }   argv[argc] = NULL;    /* Print kernel command line. */   printf (\"Kernel command line:\");   for (i = 0; i &lt; argc; i++)     if (strchr (argv[i], ' ') == NULL)       printf (\" %s\", argv[i]);     else       printf (\" '%s'\", argv[i]);   printf (\"\\n\");    return argv; }   parse_options()  /** Parses options in ARGV[]    and returns the first non-option argument. */ static char ** parse_options (char **argv)  {   for (; *argv != NULL &amp;&amp; **argv == '-'; argv++)     {       char *save_ptr;       char *name = strtok_r (*argv, \"=\", &amp;save_ptr);       char *value = strtok_r (NULL, \"\", &amp;save_ptr);              if (!strcmp (name, \"-h\"))         usage ();       else if (!strcmp (name, \"-q\"))         shutdown_configure (SHUTDOWN_POWER_OFF);       else if (!strcmp (name, \"-r\"))         shutdown_configure (SHUTDOWN_REBOOT); #ifdef FILESYS       else if (!strcmp (name, \"-f\"))         format_filesys = true;       else if (!strcmp (name, \"-filesys\"))         filesys_bdev_name = value;       else if (!strcmp (name, \"-scratch\"))         scratch_bdev_name = value; #ifdef VM       else if (!strcmp (name, \"-swap\"))         swap_bdev_name = value; #endif #endif       else if (!strcmp (name, \"-rs\"))         random_init (atoi (value));       else if (!strcmp (name, \"-mlfqs\"))         thread_mlfqs = true; #ifdef USERPROG       else if (!strcmp (name, \"-ul\"))         user_page_limit = atoi (value); #endif       else         PANIC (\"unknown option `%s' (use -h for help)\", name);     }    /* Initialize the random number generator... */   random_init (rtc_get_time ());      return argv; }     前置知识  命令行参数的传递路径  用户输入:     pintos -- -q run alarm-multiple             │            ▼  pintos 脚本处理:     解析参数，准备虚拟机配置             │            ▼  Loader (loader.S):     从磁盘读取参数     存储到内存的固定位置             │            ▼  内核 (init.c):     从固定位置读取参数     解析并执行   Loader 中的参数存储位置  // loader.h 中定义的常量  // 引导扇区末尾的布局： // LOADER_SIG (2字节): 0xAA55 BIOS 签名 // LOADER_PARTS (64字节): 分区表 // LOADER_ARGS (128字节): 命令行参数字符串 // LOADER_ARG_CNT (4字节): 参数数量  #define LOADER_END  0x7e00 #define LOADER_SIG_LEN 2 #define LOADER_PARTS_LEN 64 #define LOADER_ARGS_LEN 128 #define LOADER_ARG_CNT_LEN 4  #define LOADER_SIG (LOADER_END - LOADER_SIG_LEN)           // 0x7DFE #define LOADER_PARTS (LOADER_SIG - LOADER_PARTS_LEN)       // 0x7DBE #define LOADER_ARGS (LOADER_PARTS - LOADER_ARGS_LEN)       // 0x7D3E #define LOADER_ARG_CNT (LOADER_ARGS - LOADER_ARG_CNT_LEN)  // 0x7D3A   内存布局图  物理地址:  0x7C00  ┌────────────────────┐  ← Loader 代码开始         │                    │         │   Loader 代码      │         │                    │ 0x7D3A  ├────────────────────┤  ← LOADER_ARG_CNT         │   参数数量 (4字节)  │ 0x7D3E  ├────────────────────┤  ← LOADER_ARGS         │                    │         │   参数字符串       │     \"-q\\0run\\0alarm-multiple\\0\"         │   (128字节)        │         │                    │ 0x7DBE  ├────────────────────┤  ← LOADER_PARTS         │   分区表 (64字节)  │ 0x7DFE  ├────────────────────┤  ← LOADER_SIG         │   0xAA55 (2字节)   │ 0x7E00  └────────────────────┘  ← Loader 结束     read_command_line() 详解  函数签名  static char ** read_command_line (void)   返回一个指向字符串指针数组的指针（argv 风格）。  静态 argv 数组  static char *argv[LOADER_ARGS_LEN / 2 + 1];   为什么是 LOADER_ARGS_LEN / 2 + 1？  最坏情况：每个参数只有 1 个字符 + 1 个 null 终止符  LOADER_ARGS_LEN = 128 字节 最多参数数量 = 128 / 2 = 64 个参数 + 1 是为了 argv 末尾的 NULL 哨兵  所以数组大小 = 128 / 2 + 1 = 65   为什么用 static？     函数返回的是 argv 的地址   如果是自动变量，函数返回后内存会失效   static 保证 argv 在程序整个运行期间有效   读取参数数量  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);   逐步分析：  // 1. LOADER_ARG_CNT 是物理地址 (0x7D3A) LOADER_ARG_CNT  // 2. ptov() 转换为虚拟地址 ptov(LOADER_ARG_CNT)  // = 0xC0007D3A  // 3. 转换为 uint32_t 指针 (uint32_t *) ptov(LOADER_ARG_CNT)  // 4. 解引用读取值 *(uint32_t *) ptov(LOADER_ARG_CNT)   获取参数字符串起始地址  p = ptov (LOADER_ARGS); end = p + LOADER_ARGS_LEN;   p 指向参数字符串的开始，end 指向边界。  解析参数循环  for (i = 0; i &lt; argc; i++)  {     if (p &gt;= end)         PANIC (\"command line arguments overflow\");      argv[i] = p;     p += strnlen (p, end - p) + 1; } argv[argc] = NULL;   参数存储格式  参数以 null 分隔的字符串形式存储：  内存中的参数：  地址:    │ 0  │ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │...│ 内容:    │ -  │ q  │\\0  │ r  │ u  │ n  │\\0  │ a  │...│          └────┴────┴────┴────┴────┴────┴────┴────┴───┘           ↑             ↑             ↑         argv[0]       argv[1]       argv[2]         \"-q\"          \"run\"         \"alarm-...\"   循环逻辑  第 1 次迭代 (i=0):     argv[0] = p (指向 \"-q\")     p += strlen(\"-q\") + 1 = p + 3      第 2 次迭代 (i=1):     argv[1] = p (指向 \"run\")     p += strlen(\"run\") + 1 = p + 4      ...   打印命令行  printf (\"Kernel command line:\"); for (i = 0; i &lt; argc; i++)     if (strchr (argv[i], ' ') == NULL)         printf (\" %s\", argv[i]);     else         printf (\" '%s'\", argv[i]); printf (\"\\n\");   如果参数包含空格，用引号括起来显示：  输出示例: Kernel command line: -q run alarm-multiple Kernel command line: -q run 'my program with spaces'     parse_options() 详解  选项解析循环  for (; *argv != NULL &amp;&amp; **argv == '-'; argv++)   这个循环：    继续直到 argv 数组结束 (*argv != NULL)   只处理以 - 开头的参数 (**argv == '-')   每次移动到下一个参数 (argv++)   分离选项名和值  char *save_ptr; char *name = strtok_r (*argv, \"=\", &amp;save_ptr); char *value = strtok_r (NULL, \"\", &amp;save_ptr);   strtok_r 的工作原理  输入: \"-rs=12345\"  第一次 strtok_r(*argv, \"=\", &amp;save_ptr):     返回: \"rs\"     save_ptr 指向 \"12345\"  第二次 strtok_r(NULL, \"\", &amp;save_ptr):     返回: \"12345\"   选项处理  if (!strcmp (name, \"-h\"))     usage (); else if (!strcmp (name, \"-q\"))     shutdown_configure (SHUTDOWN_POWER_OFF); // ... 更多选项   支持的选项                 选项       含义       示例                       -h       显示帮助       pintos -- -h                 -q       完成后关机       pintos -- -q run test                 -r       完成后重启       pintos -- -r run test                 -f       格式化文件系统       pintos -f                 -rs=SEED       设置随机种子       pintos -- -rs=12345                 -mlfqs       使用 MLFQS 调度器       pintos -- -mlfqs                 -ul=COUNT       限制用户内存页数       pintos -- -ul=1000           初始化随机数  random_init (rtc_get_time ());   如果没有指定 -rs 选项，使用当前时间作为随机种子。  返回非选项参数  return argv;   返回指向第一个非选项参数的指针。例如：  输入: [\"-q\", \"run\", \"alarm-multiple\", NULL]                  ↑             返回这里     执行流程图  flowchart TD     subgraph \"read_command_line\"         A[\"读取 argc&lt;br/&gt;从 LOADER_ARG_CNT\"] --&gt; B[\"获取参数字符串地址&lt;br/&gt;p = ptov(LOADER_ARGS)\"]         B --&gt; C[\"循环解析每个参数\"]         C --&gt; D{\"i &lt; argc?\"}         D --&gt;|是| E[\"argv[i] = p\"]         E --&gt; F[\"p += strlen + 1\"]         F --&gt; D         D --&gt;|否| G[\"argv[argc] = NULL\"]         G --&gt; H[\"打印命令行\"]     end          subgraph \"parse_options\"         H --&gt; I[\"检查下一个参数\"]         I --&gt; J{\"以 '-' 开头?\"}         J --&gt;|是| K[\"分离 name 和 value\"]         K --&gt; L[\"匹配选项并执行\"]         L --&gt; I         J --&gt;|否| M[\"返回当前 argv\"]     end          style A fill:#f9f,stroke:#333     style M fill:#9f9,stroke:#333     关键数据结构  argv 数组结构  执行 \"pintos -- -q run alarm-multiple\" 后:  argv: ┌───────┬───────┬────────────────┬──────┐ │argv[0]│argv[1]│    argv[2]     │argv[3]│ │  ↓    │   ↓   │       ↓        │  ↓   │ │ \"-q\"  │\"run\"  │\"alarm-multiple\"│ NULL │ └───────┴───────┴────────────────┴──────┘  parse_options 处理后返回:                    ↓              argv 指向 \"run\"   参数值的存储位置  参数字符串实际存储在两个地方：     物理地址 LOADER_ARGS：Loader 写入的原始位置   虚拟地址 ptov(LOADER_ARGS)：内核通过高地址访问   argv 数组中的指针都指向虚拟地址空间。    命令行示例  示例 1：运行测试  pintos -- -q run alarm-multiple   argv: [\"-q\", \"run\", \"alarm-multiple\", NULL]  parse_options 处理:     -q → shutdown_configure(SHUTDOWN_POWER_OFF)     返回 → [\"run\", \"alarm-multiple\", NULL]  run_actions 处理:     action = \"run\"     task = \"alarm-multiple\"   示例 2：使用 MLFQS 调度  pintos -- -mlfqs -q run mlfqs-load-1   argv: [\"-mlfqs\", \"-q\", \"run\", \"mlfqs-load-1\", NULL]  parse_options 处理:     -mlfqs → thread_mlfqs = true     -q → shutdown_configure(SHUTDOWN_POWER_OFF)     返回 → [\"run\", \"mlfqs-load-1\", NULL]   示例 3：设置随机种子  pintos -- -rs=12345 run random-test   argv: [\"-rs=12345\", \"run\", \"random-test\", NULL]  parse_options 处理:     -rs → random_init(12345)     返回 → [\"run\", \"random-test\", NULL]     错误处理  参数溢出  if (p &gt;= end)     PANIC (\"command line arguments overflow\");   如果参数字符串超过 128 字节，内核会 panic。  未知选项  else     PANIC (\"unknown option `%s' (use -h for help)\", name);   遇到未识别的选项会 panic。  帮助信息  if (!strcmp (name, \"-h\"))     usage ();   usage() 打印帮助信息后调用 shutdown_power_off() 关机。    常见问题  Q1: 为什么参数存储在 Loader 区域？  A:    Loader 在加载内核时可以访问原始命令行   这块内存区域在内核启动后不再需要（Loader 已执行完）   复用这块空间很方便   Q2: 参数有长度限制吗？  A:  是的，LOADER_ARGS_LEN = 128 字节。这包括：    所有参数字符串   所有 null 终止符   对于复杂命令可能不够用   Q3: strtok_r 和 strtok 有什么区别？  A: // strtok：使用全局状态，不可重入 char *token = strtok(str, delim);  // strtok_r：使用传入的 save_ptr，可重入 char *save_ptr; char *token = strtok_r(str, delim, &amp;save_ptr);   在可能被中断的代码中应该使用 strtok_r。  Q4: 如果没有传递任何参数会怎样？  A: if (*argv != NULL) {     run_actions (argv); } else {     // TODO: no command line passed to kernel. Run interactively  }   目前 Pintos 没有实现交互模式，会直接跳到 shutdown()。    练习思考  思考题 1 如果在命令行中传递 -q 两次会怎样？   点击查看答案  没有问题，`shutdown_configure(SHUTDOWN_POWER_OFF)` 会被调用两次，但效果相同：  ```c void shutdown_configure (enum shutdown_type type) {   shutdown_type = type;  // 简单赋值，多次赋值无影响 } ```    思考题 2 如何添加一个新的命令行选项 -debug？   点击查看答案  在 `parse_options` 中添加：  ```c // 在 init.c 文件顶部添加 static bool debug_mode = false;  // 在 parse_options 的 if-else 链中添加 else if (!strcmp (name, \"-debug\"))     debug_mode = true; ```  然后在需要的地方检查 `debug_mode`。    思考题 3 为什么 argv 数组定义为 static？如果不是 static 会怎样？   点击查看答案  问题：`read_command_line` 返回 `argv` 的地址。  如果 `argv` 是自动变量（在栈上）： 1. 函数返回后，栈帧被销毁 2. `argv` 所在的内存变为无效 3. 调用者得到一个悬空指针 4. 使用这个指针会导致未定义行为  使用 `static`： 1. `argv` 存储在 .bss 或 .data 段 2. 内存在程序整个生命周期内有效 3. 返回的指针始终有效      下一步  命令行解析完成后，内核需要初始化内存管理系统。下一篇文档将介绍页面分配器的初始化：内存系统初始化"
  },
  
  {
    "title": "Pintos Kernel 启动详解（八）：BSS 段初始化",
    "url": "/posts/pintos-kernel-08-bss-init/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, C语言, BSS, 链接器, 内存布局",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  BSS（Block Started by Symbol）段是程序中存放未初始化全局变量和静态变量的区域。在 pintos_init() 的第一步就是调用 bss_init() 来清零这个区域。  这是一个看似简单但极其重要的步骤——如果 BSS 没有正确清零，所有未初始化的全局变量都可能包含随机垃圾数据，导致不可预测的系统行为。    原始代码  /** Clear the \"BSS\", a segment that should be initialized to    zeros.  It isn't actually stored on disk or zeroed by the    kernel loader, so we have to zero it ourselves.     The start and end of the BSS segment is recorded by the    linker as _start_bss and _end_bss.  See kernel.lds. */ static void bss_init (void)  {   extern char _start_bss, _end_bss;   memset (&amp;_start_bss, 0, &amp;_end_bss - &amp;_start_bss); }     前置知识  程序的内存布局  一个典型的程序在内存中分为几个段：  ┌─────────────────────────────────────────────────────────────┐ │                    程序内存布局                               │ ├─────────────────────────────────────────────────────────────┤ │                                                              │ │  高地址 ↑                                                    │ │                                                              │ │  ┌──────────────┐                                           │ │  │    Stack     │  栈：局部变量、函数调用帧                   │ │  │      ↓       │  向下增长                                  │ │  ├──────────────┤                                           │ │  │              │  未使用空间                                │ │  │      ↑       │                                           │ │  │    Heap      │  堆：动态分配的内存                        │ │  ├──────────────┤                                           │ │  │    .bss      │  未初始化的全局/静态变量                   │ │  ├──────────────┤                                           │ │  │    .data     │  初始化的全局/静态变量                     │ │  ├──────────────┤                                           │ │  │   .rodata    │  只读数据（字符串常量等）                  │ │  ├──────────────┤                                           │ │  │    .text     │  程序代码                                  │ │  └──────────────┘                                           │ │                                                              │ │  低地址 ↓                                                    │ │                                                              │ └─────────────────────────────────────────────────────────────┘   .data vs .bss  // 这些变量在 .data 段 int initialized_global = 42; static int initialized_static = 100; char message[] = \"Hello\";  // 这些变量在 .bss 段 int uninitialized_global; static int uninitialized_static; char buffer[1024];  // 初始化为 0 的数组也在 .bss int zero_initialized = 0;  // 显式初始化为 0 也可能在 .bss   为什么要分开 .data 和 .bss？  关键原因：节省文件空间！  .data 段：     - 变量有初始值     - 这些初始值必须存储在可执行文件中     - 加载时原样复制到内存  .bss 段：     - 所有变量初始值都是 0     - 可执行文件中不需要存储这些 0     - 只需要记录 .bss 的大小     - 加载时分配空间并清零   文件大小对比示例  int big_array[1000000];           // 4 MB 数组  // 如果在 .data 段： // 可执行文件大小 += 4 MB（存储 1000000 个 0）  // 如果在 .bss 段： // 可执行文件大小 += 几字节（只存储大小信息）     ELF 文件格式与段  ELF 头中的段信息  ELF 文件结构：  ┌──────────────────────┐ │      ELF Header      │  文件类型、入口点等 ├──────────────────────┤ │   Program Headers    │  描述如何加载到内存 ├──────────────────────┤ │      .text           │  代码段（实际数据） ├──────────────────────┤ │      .rodata         │  只读数据（实际数据） ├──────────────────────┤ │      .data           │  数据段（实际数据） ├──────────────────────┤ │      .bss            │  ← 只有头信息，没有实际数据！ ├──────────────────────┤ │   Section Headers    │  描述各段的属性 └──────────────────────┘   .bss 段在文件中不占空间  使用 readelf 查看段信息：  $ readelf -S kernel.o  Section Headers:   [Nr] Name    Type      Address   Offset  Size    ...   ...   [10] .data   PROGBITS  c0020000  001000  000234  ...  ← 有内容   [11] .bss    NOBITS    c0020234  001234  001000  ...  ← 无内容！   ...  NOBITS 类型表示段在文件中没有数据，只有大小信息     Pintos 的内核加载过程  Loader 的限制  Pintos 的 Loader 是一个简化的引导加载器，它：     读取 ELF 头获取加载信息   将各段从磁盘复制到内存   但不会清零 .bss 段！   Loader 的工作：  磁盘上的内核 ELF 文件           内存中的内核映像 ┌────────────┐                ┌────────────┐ │ ELF Header │────读取────→   │            │ ├────────────┤                │            │ │   .text    │────复制────→   │   .text    │ ├────────────┤                ├────────────┤ │   .data    │────复制────→   │   .data    │ ├────────────┤                ├────────────┤ │            │                │   .bss     │ ← 分配了空间 │            │   （无数据）     │  (垃圾?)   │    但没有清零！ └────────────┘                └────────────┘   为什么 Loader 不清零 BSS？     简化 Loader：Loader 代码越少越好（只有 512 字节）   灵活性：让内核自己处理 BSS 初始化   历史原因：很多系统都是内核自己清零 BSS     bss_init() 详解  代码分析  static void bss_init (void)  {   extern char _start_bss, _end_bss;   memset (&amp;_start_bss, 0, &amp;_end_bss - &amp;_start_bss); }   链接器符号  extern char _start_bss, _end_bss;   这两个符号不是普通变量，而是链接器定义的符号。  在 kernel.lds.S 中定义：  SECTIONS {   ...      .bss : {     _start_bss = .;        /* BSS 开始地址 */     *(.bss)                /* 收集所有 .bss 输入段 */     *(COMMON)              /* 收集 COMMON 符号 */     _end_bss = .;          /* BSS 结束地址 */   }      ... }   符号的含义  _start_bss：BSS 段第一个字节的地址 _end_bss：BSS 段最后一个字节之后的地址  BSS 大小 = &amp;_end_bss - &amp;_start_bss   为什么用 char 类型？  extern char _start_bss, _end_bss;   这是一个技巧：     我们只关心这些符号的地址   用 char 类型可以方便地进行地址算术   &amp;_start_bss 得到 char * 类型   两个 char * 相减得到字节数   // 这样就可以计算字节数： size_t bss_size = &amp;_end_bss - &amp;_start_bss;   memset 调用  memset (&amp;_start_bss, 0, &amp;_end_bss - &amp;_start_bss);   memset 函数原型： void *memset(void *s, int c, size_t n);  参数：     &amp;_start_bss         - BSS 起始地址     0                   - 要填充的值（0）     &amp;_end_bss - &amp;_start_bss  - BSS 大小（字节）  效果：将 BSS 段的每个字节都设置为 0     执行流程可视化  flowchart TD     A[\"内核被加载到内存\"] --&gt; B[\"BSS 区域包含垃圾数据\"]     B --&gt; C[\"pintos_init() 开始\"]     C --&gt; D[\"bss_init() 被调用\"]     D --&gt; E[\"获取 _start_bss 地址\"]     E --&gt; F[\"获取 _end_bss 地址\"]     F --&gt; G[\"计算 BSS 大小\"]     G --&gt; H[\"memset 清零整个 BSS\"]     H --&gt; I[\"所有全局变量现在为 0\"]     I --&gt; J[\"继续初始化其他子系统\"]          style B fill:#f99,stroke:#333     style I fill:#9f9,stroke:#333     BSS 中的变量示例  Pintos 中的 BSS 变量  // threads/thread.c static struct list ready_list;      // 就绪队列 static struct list all_list;        // 所有线程列表 static struct thread *idle_thread;  // 空闲线程指针  // threads/palloc.c static struct pool kernel_pool;     // 内核内存池 static struct pool user_pool;       // 用户内存池  // threads/malloc.c static struct arena *arenas;        // 内存分配器区域   这些变量都在 BSS 段，如果不清零：    链表头可能指向随机地址   指针可能不是 NULL   结构体字段包含垃圾值   未清零 BSS 的后果  // 假设这是一个 BSS 变量 static struct list my_list;  // 期望：{NULL, NULL}                              // 实际：{0x12345678, 0x87654321} (垃圾)  void use_list(void) {     if (list_empty(&amp;my_list)) {   // 检查 head == tail         // 可能错误地认为列表不为空！     }          list_push_front(&amp;my_list, &amp;elem);  // 可能访问无效指针！ }     memset 的实现  Pintos 的 memset (lib/string.c)  void * memset (void *dst_, int value, size_t size)  {   unsigned char *dst = dst_;    ASSERT (dst != NULL || size == 0);      while (size-- &gt; 0)     *dst++ = value;    return dst_; }   这是一个简单的字节级实现。更优化的版本可能使用：    字对齐的操作   SIMD 指令   特殊的字符串指令（如 rep stosb）     链接器脚本详解  kernel.lds.S 的结构  /* Pintos 内核链接器脚本（简化版）*/  ENTRY(start)                    /* 入口点 */  SECTIONS {   . = LOADER_PHYS_BASE + LOADER_KERN_BASE;  /* 起始地址 */      _start = .;                   /* 内核起始 */      .start : {     *(.start)                   /* start.S 代码 */   }      .text : {     *(.text)                    /* 所有代码 */   }      .rodata : {     *(.rodata)                  /* 只读数据 */   }      .data : {     *(.data)                    /* 初始化数据 */   }      .bss : {     _start_bss = .;             /* BSS 开始标记 */     *(.bss)                     /* 未初始化数据 */     *(COMMON)                   /* COMMON 符号 */     _end_bss = .;               /* BSS 结束标记 */   }      _end = .;                     /* 内核结束 */ }   COMMON 符号是什么？  // 在 C 语言中，未初始化的全局变量（非 static） // 可能被放入 COMMON 段而不是 .bss  int global_var;    // 可能是 COMMON static int static_var;  // 一定是 .bss   COMMON 符号是为了支持多个文件定义同名变量的传统 C 行为。现代做法是将它们也收集到 .bss。    常见问题  Q1: 为什么不在 Loader 中清零 BSS？  A:    Loader 只有 512 字节空间   清零 BSS 需要知道 BSS 的确切位置和大小   这会增加 Loader 的复杂性   让内核自己处理更灵活   Q2: bss_init() 能在任何时候调用吗？  A:  不能！ 必须是第一个调用的初始化函数：    在它之前不能使用任何全局变量   很多子系统依赖全局变量为 0   甚至 printf 都可能使用全局状态   Q3: 静态局部变量在 BSS 中吗？  A: void foo(void) {     static int counter;  // 在 .bss     static int init = 5; // 在 .data }   静态局部变量的存储方式与全局变量相同，只是名字可见性不同。  Q4: 如果 BSS 特别大会怎样？  A:  memset 会花更长时间，但通常不是问题：    现代 CPU 的内存带宽很高   几 MB 的清零只需要毫秒级   内核 BSS 通常不会太大     调试技巧  查看 BSS 段信息  # 使用 nm 查看符号 nm kernel.o | grep \"_bss\" # 输出： # c0021000 B _start_bss # c0022000 B _end_bss  # 使用 size 查看段大小 size kernel.o #    text    data     bss     dec     hex filename #   40000    4000    4096   48096    bc00 kernel.o   在 GDB 中检查  (gdb) p &amp;_start_bss $1 = 0xc0021000 (gdb) p &amp;_end_bss $2 = 0xc0022000 (gdb) p &amp;_end_bss - &amp;_start_bss $3 = 4096  # 检查 BSS 是否已清零 (gdb) x/10x &amp;_start_bss 0xc0021000: 0x00000000 0x00000000 0x00000000 0x00000000     练习思考  思考题 1 如果在 bss_init() 中不小心写成： memset (&amp;_start_bss, 0, &amp;_start_bss - &amp;_end_bss);  会发生什么？   点击查看答案  参数顺序错了，计算结果是负数： ```c &amp;_start_bss - &amp;_end_bss  // 负数！  // memset 的第三个参数是 size_t（无符号） // 负数会被解释为非常大的正数 // 例如：-4096 → 0xFFFFF000（约 4GB）  // memset 会尝试清零约 4GB 内存 // 这会覆盖整个内核代码和其他数据 // 系统立即崩溃 ```    思考题 2 如果有一个全局变量初始化为 0： int zero_var = 0;  它应该在 .data 还是 .bss？编译器如何决定？   点击查看答案  这取决于编译器的优化：  1. **严格来说**：变量有初始值，应该在 .data 2. **优化后**：很多编译器会将初始化为 0 的变量放入 .bss  编译器的决定因素： - `-fno-zero-initialized-in-bss`：强制放入 .data - 默认行为：通常优化到 .bss  验证方法： ```bash gcc -c -S test.c -o test.s # 查看汇编输出中变量的段 ```    思考题 3 为什么 bss_init 要用 memset 而不是简单的循环？   点击查看答案  实际上，Pintos 的 memset 就是简单循环。但使用 memset 有好处：  1. **可读性**：意图更清晰 2. **可移植性**：memset 是标准函数 3. **潜在优化**：高质量的 libc 实现有优化版本 4. **代码复用**：memset 在其他地方也会用到  如果要手写循环： ```c for (char *p = &_start_bss; p &lt; &_end_bss; p++)     *p = 0; ```  但这不如 `memset` 简洁。      下一步  BSS 清零后，内核需要读取和解析命令行参数。下一篇文档将介绍命令行处理：命令行解析"
  },
  
  {
    "title": "Pintos Kernel 启动详解（七）：pintos_init 主函数",
    "url": "/posts/pintos-kernel-07-pintos-init/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, C语言, 内核初始化",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  pintos_init() 是 Pintos 内核的 C 语言入口点。当 start.S 完成模式切换后，它调用这个函数来完成剩余的初始化工作。  pintos_init() 负责：    初始化 BSS 段   解析命令行参数   初始化各子系统（线程、内存、中断等）   启动调度器   执行用户指定的任务   这个函数是理解 Pintos 内核结构的关键。    原始代码  /** Pintos main entry point. */ int pintos_init (void) {   char **argv;    /* Clear BSS. */     bss_init ();    /* Break command line into arguments and parse options. */   argv = read_command_line ();   argv = parse_options (argv);    /* Initialize ourselves as a thread so we can use locks,      then enable console locking. */   thread_init ();   console_init ();      /* Greet user. */   printf (\"Pintos booting with %'\"PRIu32\" kB RAM...\\n\",           init_ram_pages * PGSIZE / 1024);    /* Initialize memory system. */   palloc_init (user_page_limit);   malloc_init ();   paging_init ();    /* Segmentation. */ #ifdef USERPROG   tss_init ();   gdt_init (); #endif    /* Initialize interrupt handlers. */   intr_init ();   timer_init ();   kbd_init ();   input_init (); #ifdef USERPROG   exception_init ();   syscall_init (); #endif    /* Start thread scheduler and enable interrupts. */   thread_start ();   serial_init_queue ();   timer_calibrate ();  #ifdef FILESYS   /* Initialize file system. */   ide_init ();   locate_block_devices ();   filesys_init (format_filesys); #endif    printf (\"Boot complete.\\n\");      if (*argv != NULL) {     /* Run actions specified on kernel command line. */     run_actions (argv);   } else {     // TODO: no command line passed to kernel. Run interactively    }    /* Finish up. */   shutdown ();   thread_exit (); }     前置知识  函数签名分析  int pintos_init (void) NO_RETURN;   NO_RETURN 宏  这个宏告诉编译器这个函数永不返回：  // 在 debug.h 中定义 #define NO_RETURN __attribute__ ((noreturn))   这有助于编译器优化，并在函数意外返回时发出警告。  返回类型为 int  虽然函数不返回，但声明为返回 int 是 C 语言的惯例（类似 main 函数）。  内核的构建配置  Pintos 支持多种配置，通过预处理器宏控制：  USERPROG  // 用户程序支持（project 2+） FILESYS   // 文件系统支持（project 4） VM        // 虚拟内存支持（project 3）   这些宏影响哪些子系统被初始化。    初始化流程图  flowchart TD     subgraph \"第一阶段：基础设置\"         A[\"bss_init()&lt;br/&gt;清零 BSS 段\"]         A --&gt; B[\"read_command_line()&lt;br/&gt;解析命令行\"]         B --&gt; C[\"parse_options()&lt;br/&gt;处理选项\"]     end          subgraph \"第二阶段：核心子系统\"         C --&gt; D[\"thread_init()&lt;br/&gt;线程系统\"]         D --&gt; E[\"console_init()&lt;br/&gt;控制台\"]         E --&gt; F[\"printf()&lt;br/&gt;打印欢迎信息\"]     end          subgraph \"第三阶段：内存系统\"         F --&gt; G[\"palloc_init()&lt;br/&gt;页面分配器\"]         G --&gt; H[\"malloc_init()&lt;br/&gt;内核 malloc\"]         H --&gt; I[\"paging_init()&lt;br/&gt;永久页表\"]     end          subgraph \"第四阶段：中断和设备\"         I --&gt; J[\"intr_init()&lt;br/&gt;中断系统\"]         J --&gt; K[\"timer_init()&lt;br/&gt;定时器\"]         K --&gt; L[\"kbd_init()&lt;br/&gt;键盘\"]         L --&gt; M[\"input_init()&lt;br/&gt;输入系统\"]     end          subgraph \"第五阶段：启动调度器\"         M --&gt; N[\"thread_start()&lt;br/&gt;启动调度器\"]         N --&gt; O[\"serial_init_queue()&lt;br/&gt;串口队列\"]         O --&gt; P[\"timer_calibrate()&lt;br/&gt;定时器校准\"]     end          subgraph \"第六阶段：文件系统（可选）\"         P --&gt; Q[\"ide_init()&lt;br/&gt;IDE 驱动\"]         Q --&gt; R[\"filesys_init()&lt;br/&gt;文件系统\"]     end          subgraph \"第七阶段：执行任务\"         R --&gt; S[\"run_actions()&lt;br/&gt;执行命令\"]         S --&gt; T[\"shutdown()&lt;br/&gt;关机\"]     end          style A fill:#f9f,stroke:#333     style T fill:#9f9,stroke:#333     逐段详解  阶段一：BSS 初始化  /* Clear BSS. */   bss_init ();   什么是 BSS？  BSS（Block Started by Symbol）是程序中未初始化的全局变量区域：  int initialized = 42;     // 在 .data 段，有初始值 int uninitialized;        // 在 .bss 段，需要清零   为什么要手动清零？  C 语言标准规定：未初始化的全局/静态变量应该为 0。  但 Pintos 的内核加载过程不会自动清零 BSS：    ELF 文件中 BSS 不占空间   加载器只复制有内容的段   所以 BSS 区域可能包含随机数据   必须在使用任何全局变量之前清零 BSS！  bss_init 的实现  static void bss_init (void)  {   extern char _start_bss, _end_bss;   memset (&amp;_start_bss, 0, &amp;_end_bss - &amp;_start_bss); }   _start_bss 和 _end_bss 是链接器脚本定义的符号，标记 BSS 段的边界。    阶段二：命令行解析  /* Break command line into arguments and parse options. */ argv = read_command_line (); argv = parse_options (argv);   命令行从哪里来？  Loader 在加载内核时，将命令行参数存放在特定位置：  // loader.h 中的定义 #define LOADER_ARGS (LOADER_PARTS - LOADER_ARGS_LEN) #define LOADER_ARG_CNT (LOADER_ARGS - LOADER_ARG_CNT_LEN)  // 参数存储位置（物理地址） // 参数数量：LOADER_ARG_CNT // 参数字符串：LOADER_ARGS   read_command_line() 的工作  static char ** read_command_line (void)  {   static char *argv[LOADER_ARGS_LEN / 2 + 1];   char *p, *end;   int argc;      // 从物理地址读取参数数量   argc = *(uint32_t *) ptov (LOADER_ARG_CNT);      // 从物理地址读取参数字符串   p = ptov (LOADER_ARGS);   end = p + LOADER_ARGS_LEN;      // 解析以 null 分隔的参数   for (i = 0; i &lt; argc; i++) {     argv[i] = p;     p += strnlen (p, end - p) + 1;   }   argv[argc] = NULL;      return argv; }   ptov 宏  // 物理地址到虚拟地址的转换 #define ptov(PADDR) ((void *) (((PADDR)) + LOADER_PHYS_BASE))  // 例如： // ptov(0x1000) = 0x1000 + 0xC0000000 = 0xC0001000   parse_options() 处理的选项  -h          // 显示帮助 -q          // 完成后关机 -r          // 完成后重启 -f          // 格式化文件系统 -rs=SEED    // 随机数种子 -mlfqs      // 使用多级反馈队列调度 -ul=COUNT   // 用户内存页数限制     阶段三：线程和控制台  /* Initialize ourselves as a thread so we can use locks,    then enable console locking. */ thread_init (); console_init ();    /* Greet user. */ printf (\"Pintos booting with %'\"PRIu32\" kB RAM...\\n\",         init_ram_pages * PGSIZE / 1024);   thread_init() 的作用  将当前执行流转换为一个正式的线程：  void thread_init (void)  {   // 初始化线程系统的数据结构   lock_init (&amp;tid_lock);   list_init (&amp;ready_list);   list_init (&amp;all_list);    // 将当前执行流包装成 \"main\" 线程   initial_thread = running_thread ();   init_thread (initial_thread, \"main\", PRI_DEFAULT);   initial_thread-&gt;status = THREAD_RUNNING;   initial_thread-&gt;tid = allocate_tid (); }   为什么要初始化线程系统？  后续的初始化代码需要使用锁（lock）等同步原语。锁依赖于线程系统。  console_init() 的作用  初始化控制台输出，包括：    初始化控制台锁（防止多线程输出混乱）   设置 VGA 显示   打印欢迎信息  printf (\"Pintos booting with %'\"PRIu32\" kB RAM...\\n\",         init_ram_pages * PGSIZE / 1024);  // 例如输出： // Pintos booting with 32,768 kB RAM...   init_ram_pages 是之前在 start.S 中检测并存储的物理页数。    阶段四：内存系统  /* Initialize memory system. */ palloc_init (user_page_limit); malloc_init (); paging_init ();   palloc_init(): 页面分配器  初始化物理页面分配器，将物理内存分为两个池：  void palloc_init (size_t user_page_limit) {   // 内核池：用于内核数据结构   // 用户池：用于用户进程      // 划分物理内存   // 初始化空闲页面位图 }   malloc_init(): 内核 malloc  初始化内核的动态内存分配器：  void malloc_init (void) {   // 设置内存分配描述符   // 初始化各大小级别的空闲块列表 }   之后内核代码可以使用 malloc() 和 free()。  paging_init(): 永久页表  替换 start.S 创建的临时页表，建立永久的页表结构：  static void paging_init (void) {   uint32_t *pd, *pt;      // 分配新的页目录   pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);      // 为每个物理页创建映射   for (page = 0; page &lt; init_ram_pages; page++) {     // 分配页表（如需要）     // 创建 PTE   }      // 切换到新页目录   asm volatile (\"movl %0, %%cr3\" : : \"r\" (vtop (init_page_dir))); }     阶段五：中断系统  /* Initialize interrupt handlers. */ intr_init (); timer_init (); kbd_init (); input_init (); #ifdef USERPROG exception_init (); syscall_init (); #endif   intr_init(): 中断描述符表  设置 IDT（Interrupt Descriptor Table）：  void intr_init (void) {   // 初始化 8259A PIC   pic_init ();      // 初始化 IDT   for (i = 0; i &lt; INTR_CNT; i++)     idt[i] = make_intr_gate (intr_stubs[i], 0);      // 加载 IDTR   asm volatile (\"lidt %0\" : : \"m\" (idtr_operand));      // 初始化中断名称（用于调试）   intr_names[0] = \"#DE Divide Error\";   // ... }   timer_init(): 定时器  初始化 8254 PIT（Programmable Interval Timer）：  void timer_init (void) {   // 配置 PIT 产生 100 Hz 中断   pit_configure_channel (0, 2, TIMER_FREQ);      // 注册定时器中断处理程序   intr_register_ext (0x20, timer_interrupt, \"8254 Timer\"); }   kbd_init(): 键盘  初始化键盘控制器：  void kbd_init (void) {   // 注册键盘中断处理程序   intr_register_ext (0x21, keyboard_interrupt, \"8042 Keyboard\"); }     阶段六：启动调度器  /* Start thread scheduler and enable interrupts. */ thread_start (); serial_init_queue (); timer_calibrate ();   thread_start(): 启动抢占式调度  void thread_start (void)  {   // 创建空闲线程   struct semaphore idle_started;   sema_init (&amp;idle_started, 0);   thread_create (\"idle\", PRI_MIN, idle, &amp;idle_started);    // 启用中断！   intr_enable ();    // 等待空闲线程初始化完成   sema_down (&amp;idle_started); }   重要：intr_enable()  这是中断第一次被启用！在此之前，所有代码都是以中断禁用状态运行的。  启用中断后：    定时器中断开始触发   抢占式调度开始工作   系统变成真正的多任务   timer_calibrate(): 校准定时器  测量 CPU 速度，用于精确的延时：  void timer_calibrate (void)  {   // 测量忙等待循环的次数   // 确定每秒可以执行多少次循环   // 用于实现 timer_msleep() 等函数 }     阶段七：文件系统（可选）  #ifdef FILESYS   /* Initialize file system. */   ide_init ();   locate_block_devices ();   filesys_init (format_filesys); #endif   这部分只在 Project 4 中启用：     ide_init(): 初始化 IDE 硬盘驱动   locate_block_devices(): 扫描并识别块设备   filesys_init(): 初始化文件系统     阶段八：执行任务  printf (\"Boot complete.\\n\");  if (*argv != NULL) {   /* Run actions specified on kernel command line. */   run_actions (argv); } else {   // TODO: no command line passed to kernel. Run interactively  }  /* Finish up. */ shutdown (); thread_exit ();   run_actions(): 执行命令  根据命令行参数执行操作：  // 支持的 actions: run TEST        // 运行测试 ls              // 列出文件 cat FILE        // 显示文件内容 rm FILE         // 删除文件 extract         // 解压文件 append FILE     // 追加到文件   shutdown(): 关机  void shutdown (void) {   // 根据配置选择关机或重启   if (shutdown_type == SHUTDOWN_POWER_OFF)     shutdown_power_off ();  // ACPI 关机   else     shutdown_reboot ();      // 触发三重故障重启 }   thread_exit(): 退出  主线程退出。这通常不会被执行到，因为 shutdown() 已经停止了系统。    初始化顺序的重要性  初始化的顺序是精心设计的，有严格的依赖关系：  ┌──────────────────────────────────────────────────────────────┐ │                      依赖关系图                               │ ├──────────────────────────────────────────────────────────────┤ │                                                              │ │  bss_init      ← 所有全局变量需要先清零                        │ │      │                                                        │ │      ▼                                                        │ │  thread_init   ← printf 需要锁，锁需要线程系统                 │ │      │                                                        │ │      ▼                                                        │ │  console_init  ← printf 需要控制台初始化                      │ │      │                                                        │ │      ▼                                                        │ │  palloc_init   ← malloc 需要页面分配器                        │ │      │                                                        │ │      ▼                                                        │ │  malloc_init   ← 其他子系统可能需要 malloc                    │ │      │                                                        │ │      ▼                                                        │ │  paging_init   ← 需要 palloc 来分配页表                       │ │      │                                                        │ │      ▼                                                        │ │  intr_init     ← thread_start 需要 IDT                       │ │      │                                                        │ │      ▼                                                        │ │  timer_init    ← 调度依赖定时器中断                           │ │      │                                                        │ │      ▼                                                        │ │  thread_start  ← 启用中断，启动调度器                          │ │                                                              │ └──────────────────────────────────────────────────────────────┘     常见问题  Q1: 为什么 pintos_init 标记为 NO_RETURN？  A:    函数最后调用 shutdown() 或 thread_exit()   这两个函数都不返回   如果返回，start.S 中的无限循环会捕获   告诉编译器可以优化掉返回相关的代码   Q2: 如果在 thread_init 之前调用 printf 会怎样？  A:    printf 内部使用锁来防止输出混乱   锁需要线程系统来工作   在 thread_init 之前，锁操作会失败或产生未定义行为   系统可能会挂起或崩溃   Q3: intr_enable 之后发生了什么？  A: intr_enable() 执行后： 1. IF 标志被设置 2. 挂起的中断开始触发 3. 定时器中断每 10ms 触发一次 4. 如果时间片用完，可能发生线程切换 5. 系统变成真正的多任务环境     练习思考  思考题 1 如果调换 palloc_init 和 malloc_init 的顺序会怎样？   点击查看答案  会导致系统崩溃或未定义行为：  ``` malloc_init 需要 palloc_get_page() 来分配内存 如果 palloc 未初始化，palloc_get_page 会失败 malloc_init 无法正常完成 后续所有需要 malloc 的代码都会失败 ```    思考题 2 为什么要先 thread_init 再 console_init？   点击查看答案  因为 console_init 内部使用锁：  ```c void console_init (void) {   lock_init (&amp;console_lock);  // 这需要线程系统！   // ... } ```  锁的初始化和操作依赖于线程系统的存在。    思考题 3 如果 timer_calibrate 在中断启用之前执行会怎样？   点击查看答案  `timer_calibrate` 需要测量时间：  ```c void timer_calibrate (void) {   // ...   int64_t start = timer_ticks();  // 读取定时器   // 执行忙等待   int64_t end = timer_ticks();   // 计算经过的时间 } ```  `timer_ticks()` 返回的是中断累加的计数。 如果中断禁用，定时器中断不会触发，计数不会增加。 校准会得到错误的结果或无限循环。      下一步  pintos_init 的第一步是清零 BSS 段。下一篇文档将详细介绍 BSS 段的作用和初始化：BSS 段初始化"
  },
  
  {
    "title": "Pintos Kernel 启动详解（六）：GDT 全局描述符表",
    "url": "/posts/pintos-kernel-06-gdt/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, GDT, 分段, 保护模式",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  GDT（Global Descriptor Table，全局描述符表）是 x86 保护模式的核心数据结构之一。它定义了内存段的属性，包括基地址、大小、访问权限等。  虽然现代操作系统几乎不使用段来进行内存保护（而是依赖分页），但 GDT 仍然是必需的，因为：    CPU 切换到保护模式时需要 GDT   段寄存器必须包含有效的选择子   某些功能（如 TSS）仍然依赖 GDT   本文详细解析 Pintos 中 GDT 的结构和每个字段的含义。    原始代码  #### GDT  \t.align 8 gdt: \t.quad 0x0000000000000000\t# Null segment.  Not used by CPU. \t.quad 0x00cf9a000000ffff\t# System code, base 0, limit 4 GB. \t.quad 0x00cf92000000ffff    # System data, base 0, limit 4 GB.  gdtdesc: \t.word\tgdtdesc - gdt - 1\t# Size of the GDT, minus 1 byte. \t.long\tgdt\t\t\t        # Address of the GDT.     前置知识  分段的历史背景  8086 时代（1978年）  最初的 8086 只有 16 位寄存器，但需要寻址 1MB 内存。解决方案是分段：  物理地址 = 段基址 × 16 + 偏移  16 位段 + 16 位偏移 = 20 位地址 = 1MB   80286 和保护模式（1982年）  80286 引入了保护模式，段从简单的地址偏移变成了复杂的描述符：  实模式:           保护模式: 段寄存器 = 基址    段寄存器 = 选择子 → 指向描述符 → 包含基址+限长+属性   现代操作系统（平坦模型）  现代 OS 将所有段基址设为 0，限长设为 4GB，让段机制”透明”：  所有段: 基址=0, 限长=4GB  线性地址 = 段基址 + 偏移 = 0 + 偏移 = 偏移   真正的内存保护由分页机制完成。  GDT 的作用                       GDT                   ┌────────┐ 选择子 0x00 ────→ │ 空描述符 │  必须存在，不可使用                   ├────────┤ 选择子 0x08 ────→ │ 代码段  │  CS 使用                   ├────────┤ 选择子 0x10 ────→ │ 数据段  │  DS/SS 使用                   ├────────┤                   │  ...   │  可以有更多段                   └────────┘  CPU 通过选择子查找 GDT 中的描述符 描述符定义了段的所有属性     GDT 布局详解  整体结构  GDT 在内存中的布局：  偏移    内容                描述 ─────   ────────────────    ────────────────── 0x00    0x0000000000000000  空描述符（索引 0） 0x08    0x00cf9a000000ffff  代码段描述符（索引 1） 0x10    0x00cf92000000ffff  数据段描述符（索引 2）  总大小：3 × 8 = 24 字节   选择子与索引的关系  选择子格式:  15                 3  2  1 0 ┌────────────────────┬──┬────┐ │       索引         │TI│RPL │ └────────────────────┴──┴────┘  选择子 = 索引 × 8 + TI × 4 + RPL  例如：     SEL_KCSEG = 0x08     二进制 = 0000 0000 0000 1000     索引 = 1, TI = 0, RPL = 0          SEL_KDSEG = 0x10     二进制 = 0000 0000 0001 0000     索引 = 2, TI = 0, RPL = 0     段描述符格式  每个段描述符占 8 字节（64 位），格式非常复杂：  字节布局：    63      56 55  52 51  48 47      40 39      32  ┌─────────┬──────┬──────┬──────────┬──────────┐  │Base     │Flags │Limit │  Access  │  Base    │  │[31:24]  │      │[19:16]│  Byte   │ [23:16]  │  └─────────┴──────┴──────┴──────────┴──────────┘    31                     16 15                 0  ┌─────────────────────────┬───────────────────┐  │     Base [15:0]         │   Limit [15:0]    │  └─────────────────────────┴───────────────────┘  完整的 64 位视图：   位      内容   ─────   ────────────   0-15    Limit [15:0]     段限长低 16 位   16-31   Base [15:0]      段基址低 16 位   32-39   Base [23:16]     段基址中间 8 位   40-47   Access Byte      访问字节   48-51   Limit [19:16]    段限长高 4 位   52-55   Flags            标志位   56-63   Base [31:24]     段基址高 8 位   为什么字段分散？  这是历史遗留问题。80286 的描述符只有 6 字节，后来 80386 扩展时为了兼容性，将新字段放在了空闲位置：  80286 描述符 (48 位): ┌───────────┬───────────┬───────────┐ │ Limit[15:0] │ Base[15:0] │Base[23:16]│Access│ └───────────┴───────────┴───────────┘  80386 扩展 (64 位): ┌───────────┬───────────┬───────────┬─────┬─────┬───────────┐ │Limit[15:0]│Base[15:0] │Base[23:16]│Acces│Flags│Base[31:24]│ │           │           │           │     │Lim  │           │ └───────────┴───────────┴───────────┴─────┴─────┴───────────┘                                           ↑                                      新增字段     Access Byte 详解  Access Byte（访问字节）位于描述符的第 5 字节（位 40-47）：  Access Byte 格式：    7    6   5    4    3    2    1    0 ┌────┬───────┬────┬────┬────┬────┬────┐ │ P  │  DPL  │ S  │ E  │ DC │ RW │ A  │ └────┴───────┴────┴────┴────┴────┴────┘  P   (位 7): Present，存在位             1 = 段在内存中             0 = 段不存在（访问会产生异常）  DPL (位 5-6): Descriptor Privilege Level             00 = Ring 0（最高权限，内核）             01 = Ring 1             02 = Ring 2             03 = Ring 3（最低权限，用户）  S   (位 4): Descriptor Type             1 = 代码或数据段（常规段）             0 = 系统段（TSS、LDT 等）  E   (位 3): Executable             1 = 代码段（可执行）             0 = 数据段（不可执行）  DC  (位 2): Direction/Conforming             数据段：方向位                 0 = 向上增长（正常）                 1 = 向下增长（栈）             代码段：一致位                 0 = 非一致（需要通过门调用）                 1 = 一致（可以从低特权级调用）  RW  (位 1): Readable/Writable             代码段：可读位                 0 = 仅执行                 1 = 可执行可读             数据段：可写位                 0 = 只读                 1 = 可读写  A   (位 0): Accessed             CPU 访问过该段时自动设置为 1   Pintos 代码段的 Access Byte  0x9a = 1001 1010  P   = 1：段存在 DPL = 00：Ring 0 S   = 1：代码/数据段 E   = 1：代码段 DC  = 0：非一致 RW  = 1：可读 A   = 0：未访问  含义：Ring 0 可执行可读代码段   Pintos 数据段的 Access Byte  0x92 = 1001 0010  P   = 1：段存在 DPL = 00：Ring 0 S   = 1：代码/数据段 E   = 0：数据段 DC  = 0：向上增长 RW  = 1：可写 A   = 0：未访问  含义：Ring 0 可读写数据段     Flags 详解  Flags 字段位于描述符的位 52-55：  Flags 格式：    55   54   53   52 ┌────┬────┬────┬────┐ │ G  │D/B │ L  │AVL │ └────┴────┴────┴────┘  G   (位 55): Granularity，粒度             0 = 限长单位是字节（最大 1MB）             1 = 限长单位是 4KB（最大 4GB）  D/B (位 54): Default operation size / Big             代码段 (D)：                 0 = 16 位代码段                 1 = 32 位代码段             数据段 (B)：                 0 = 16 位栈指针（SP）                 1 = 32 位栈指针（ESP）  L   (位 53): Long mode             1 = 64 位代码段（长模式）             0 = 32 位/16 位代码段             (数据段忽略此位)  AVL (位 52): Available             系统软件可用，CPU 不使用   Pintos 的 Flags 值  0xC = 1100  G   = 1：4KB 粒度 D/B = 1：32 位 L   = 0：非 64 位 AVL = 0：未使用  与 Limit[19:16] = 0xF 组合：     完整 Flags+Limit 字节 = 0xCF     完整描述符解析  空描述符 (索引 0)  0x0000000000000000  这是必需的。CPU 规定 GDT 第一项必须是空描述符。 如果选择子为 0（空选择子），访问会产生异常。  用途： - 检测未初始化的段寄存器 - 允许某些段寄存器保持\"未使用\"状态   内核代码段 (索引 1)  0x00cf9a000000ffff  逐字节分解：     字节 0-1: 0xffff  → Limit[15:0] = 0xFFFF     字节 2-3: 0x0000  → Base[15:0] = 0x0000     字节 4:   0x00    → Base[23:16] = 0x00     字节 5:   0x9a    → Access Byte = 1001 1010     字节 6:   0xcf    → Flags(0xC) + Limit[19:16](0xF)     字节 7:   0x00    → Base[31:24] = 0x00  组合结果：     Base  = 0x00000000     Limit = 0xFFFFF × 4KB = 4GB     Access: P=1, DPL=0, S=1, E=1, RW=1     Flags: G=1, D=1  结论：32 位内核代码段，基址 0，大小 4GB   内核数据段 (索引 2)  0x00cf92000000ffff  字节 5:   0x92    → Access Byte = 1001 0010  与代码段唯一的区别是 Access Byte：     代码段: E=1 (可执行)     数据段: E=0 (数据段)  结论：32 位内核数据段，基址 0，大小 4GB     GDT 描述符 (GDTR)  gdtdesc: \t.word\tgdtdesc - gdt - 1\t# Size of the GDT, minus 1 byte. \t.long\tgdt\t\t\t        # Address of the GDT.   GDTR 格式   47                  16 15              0 ┌──────────────────────┬─────────────────┐ │  GDT 线性基地址 (32位) │  限长 (16位)    │ └──────────────────────┴─────────────────┘  限长 = GDT 大小 - 1 基地址 = GDT 起始地址   计算限长  gdtdesc - gdt - 1 = ?  gdt 定义了 3 个 .quad（每个 8 字节） 总大小 = 3 × 8 = 24 字节  限长 = 24 - 1 = 23 = 0x17  所以 gdtdesc 的内容是：     偏移 0-1: 0x0017 (限长)     偏移 2-5: gdt 的地址   LGDT 指令如何使用  lgdt gdtdesc  执行后：     GDTR.Limit = 23     GDTR.Base = gdt 的地址  CPU 现在知道 GDT 在哪里、有多大     限长（Limit）的计算  粒度位 (G) 的影响  Limit 字段是 20 位：     Limit[15:0] 在描述符低字     Limit[19:16] 在 Flags 字节  如果 G = 0（字节粒度）：     段大小 = Limit + 1（字节）     最大 = 0xFFFFF + 1 = 1MB  如果 G = 1（4KB 粒度）：     段大小 = (Limit + 1) × 4KB     最大 = (0xFFFFF + 1) × 4KB = 4GB   Pintos 的限长  Limit[19:0] = 0xFFFFF G = 1  段大小 = (0xFFFFF + 1) × 4096        = 0x100000 × 0x1000        = 0x100000000        = 4GB  所以代码段和数据段都覆盖整个 4GB 地址空间     平坦内存模型  什么是平坦模型？  平坦模型特点：     所有段基址 = 0     所有段限长 = 4GB      效果：     段:偏移 = 0 + 偏移 = 偏移     线性地址 = 偏移      段机制变得\"透明\"，就像不存在一样   为什么使用平坦模型？     简化编程：不需要管理多个段   与分页配合：分页提供更灵活的内存管理   兼容性：现代编译器默认生成平坦模型代码   性能：减少段检查开销   真正的保护靠什么？  分页提供：     - 页级权限（用户/内核）     - 页级可写/只读     - 页存在/不存在     - 独立地址空间      分段在平坦模型下只提供：     - 代码/数据区分     - Ring 级别检查     - 系统段（TSS 等）支持     完整的内存访问流程  flowchart TD     A[\"访问内存&lt;br/&gt;DS:0x12345678\"] --&gt; B[\"段选择子处理\"]     B --&gt; C[\"查找 GDT[选择子/8]\"]     C --&gt; D[\"获取描述符\"]     D --&gt; E[\"检查权限&lt;br/&gt;DPL vs CPL\"]     E --&gt; F[\"计算线性地址&lt;br/&gt;Base + Offset\"]     F --&gt; G[\"线性地址 = 0 + 0x12345678&lt;br/&gt;= 0x12345678\"]     G --&gt; H[\"分页转换\"]     H --&gt; I[\"查找页目录/页表\"]     I --&gt; J[\"计算物理地址\"]     J --&gt; K[\"访问物理内存\"]          style A fill:#f9f,stroke:#333     style K fill:#9f9,stroke:#333     常见问题  Q1: 为什么空描述符不能使用？  A: 这是 CPU 的硬件规定。用途包括：    检测未初始化的段寄存器   允许 DS、ES 等保持无效状态   某些操作（如加载 LDT）可能产生空选择子   如果访问空选择子，CPU 产生 #GP（通用保护异常）。  Q2: Ring 0/3 是什么？  A: x86 有 4 个特权级（Ring 0-3）：  Ring 0: 内核态，最高权限 Ring 1: 未使用（某些虚拟化场景） Ring 2: 未使用 Ring 3: 用户态，最低权限  大多数 OS 只使用 Ring 0 和 Ring 3   Q3: 一致代码段有什么用？  A: 一致（Conforming）代码段允许低特权级代码调用而不改变特权级：  非一致段：     Ring 3 → Ring 0 必须通过调用门      一致段：     Ring 3 可以直接调用 Ring 0 的一致代码     但运行时仍是 Ring 3 特权级      用途：提供共享库代码，不需要特权切换   Q4: 为什么数据段需要设置为可写？  A: 如果数据段只读：    任何写操作都会产生 #GP 异常   局部变量（在栈上）无法创建   任何 mov 到内存都会失败   实际上，栈也使用 SS 数据段，必须可写。    GDT 的扩展  Pintos 初始 GDT 只有 3 项，但后面会扩展：  userprog/gdt.c 中的完整 GDT  // 完整的 GDT（后续添加） static uint64_t gdt[SEL_CNT];  // SEL_NULL  = 0x00  空选择子 // SEL_KCSEG = 0x08  内核代码段 // SEL_KDSEG = 0x10  内核数据段 // SEL_UCSEG = 0x1B  用户代码段 (RPL=3) // SEL_UDSEG = 0x23  用户数据段 (RPL=3) // SEL_TSS   = 0x28  任务状态段     练习思考  思考题 1 如果把 DPL 改为 3（Ring 3），内核代码还能正常运行吗？   点击查看答案  能运行，但会产生安全问题：  ``` DPL 检查规则：     CPL &lt;= DPL 才能访问  如果 DPL = 3：     Ring 3 用户程序可以访问这些段     用户可以直接执行内核代码！      这完全破坏了内核保护 ```  所以内核段必须是 DPL = 0。    思考题 2 为什么需要分开的代码段和数据段，不能用一个段？   点击查看答案  主要原因：  1. **执行权限不同**：    - 代码段需要 E=1（可执行）    - 数据段需要 E=0（不可执行）     2. **CPU 强制区分**：    - CS 只能加载代码段选择子    - DS/SS 只能加载数据段选择子    - 尝试加载错误类型会产生 #GP  3. **安全性**：    - 防止数据被当作代码执行    - 防止代码被修改  即使基址和限长相同，也需要两个描述符。    思考题 3 如果限长设置为 2GB 而不是 4GB 会怎样？   点击查看答案  ``` Limit = 0x7FFFF (而不是 0xFFFFF) G = 1  段大小 = (0x7FFFF + 1) × 4KB = 2GB  效果：     只有低 2GB 地址可访问     访问 0x80000000 以上地址会产生 #GP      对 Pintos 的影响：     内核链接到 0xC0000000     这个地址超过 2GB     内核无法正常运行！ ```  所以必须设置限长为 4GB 以覆盖高地址。      下一步  我们已经详细了解了 GDT 和保护模式。现在，CPU 成功调用了 pintos_init() 函数。下一篇文档将开始介绍 C 语言的内核初始化：pintos_init 主函数"
  },
  
  {
    "title": "Pintos Kernel 启动详解（五）：保护模式切换",
    "url": "/posts/pintos-kernel-05-protected-mode/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, 保护模式, GDT, CR0",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  这是整个启动过程中最关键的转折点：从 16 位实模式切换到 32 位保护模式。这个过程涉及：     禁用中断（避免切换过程中被打断）   加载 GDT（全局描述符表）   设置 CR0 寄存器（启用保护模式和分页）   执行远跳转（刷新 CS 段寄存器）   重新加载段寄存器   调整栈指针并调用 C 函数   完成这些步骤后，CPU 将运行在 32 位保护模式下，可以访问 4GB 地址空间并使用现代操作系统特性。    原始代码  #### Switch to protected mode.  # First, disable interrupts.  We won't set up the IDT until we get # into C code, so any interrupt would blow us away.  \tcli  # Protected mode requires a GDT, so point the GDTR to our GDT. # We need a data32 prefix to ensure that all 32 bits of the GDT # descriptor are loaded (default is to load only 24 bits). # The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit # relocations.  \tdata32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000  # Then we turn on the following bits in CR0: #    PE (Protect Enable): this turns on protected mode. #    PG (Paging): turns on paging. #    WP (Write Protect): if unset, ring 0 code ignores #       write-protect bits in page tables (!). #    EM (Emulation): forces floating-point instructions to trap. #       We don't support floating point.  \tmovl %cr0, %eax \torl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax \tmovl %eax, %cr0  # We're now in protected mode in a 16-bit segment.  The CPU still has # the real-mode code segment cached in %cs's segment descriptor.  We # need to reload %cs, and the easiest way is to use a far jump. # Because we're not running in a 32-bit segment the data32 prefix is # needed to jump to a 32-bit offset in the target segment.  \tdata32 ljmp $SEL_KCSEG, $1f  # We're now in protected mode in a 32-bit segment. # Let the assembler know.  \t.code32  # Reload all the other segment registers and the stack pointer to # point into our new GDT.  1:\tmov $SEL_KDSEG, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %fs \tmov %ax, %gs \tmov %ax, %ss \taddl $LOADER_PHYS_BASE, %esp \tmovl $0, %ebp\t\t\t# Null-terminate main()'s backtrace  #### Call pintos_init().  \tcall pintos_init  # pintos_init() shouldn't ever return.  If it does, spin.  1:\tjmp 1b     前置知识  实模式 vs 保护模式                 特性       实模式       保护模式                       地址宽度       20 位（1MB）       32 位（4GB）                 寄存器大小       16 位       32 位                 内存保护       无       有（通过段和页）                 分页       不支持       支持                 多任务       不支持       支持                 段寻址       段:偏移       选择子:偏移           切换步骤概览  flowchart TD     A[\"16 位实模式\"] --&gt; B[\"cli: 禁用中断\"]     B --&gt; C[\"lgdt: 加载 GDT\"]     C --&gt; D[\"设置 CR0.PE/PG/WP/EM\"]     D --&gt; E[\"远跳转到 32 位段\"]     E --&gt; F[\"重新加载段寄存器\"]     F --&gt; G[\"调整栈指针\"]     G --&gt; H[\"call pintos_init\"]     H --&gt; I[\"32 位保护模式\"]          style A fill:#f99,stroke:#333     style I fill:#9f9,stroke:#333   GDT（全局描述符表）  GDT 是保护模式的核心数据结构，定义了内存段的属性：  GDT 结构：      ┌─────────────────┐  索引 0     │   空描述符       │  (必须为 0)     ├─────────────────┤  索引 1 (选择子 0x08)     │  内核代码段      │  SEL_KCSEG     ├─────────────────┤  索引 2 (选择子 0x10)     │  内核数据段      │  SEL_KDSEG     └─────────────────┘   段选择子格式   15                 3  2  1 0 ┌────────────────────┬──┬────┐ │       索引         │TI│RPL │ └────────────────────┴──┴────┘  索引：GDT 中的描述符索引 TI：表指示器（0=GDT, 1=LDT） RPL：请求特权级（0-3）  SEL_KCSEG = 0x08 = 0000 0000 0000 1000     索引 = 1, TI = 0, RPL = 0  SEL_KDSEG = 0x10 = 0000 0000 0001 0000     索引 = 2, TI = 0, RPL = 0     逐行详解  第 1 行：禁用中断  \tcli   CLI = Clear Interrupt Flag  这条指令清除 FLAGS 寄存器中的 IF（Interrupt Flag）位，禁用可屏蔽中断。  为什么要禁用中断？  如果不禁用中断，可能发生：  1. 正在加载 GDT 时发生中断 2. 中断处理需要有效的 IDT（中断描述符表） 3. 我们还没设置 IDT！ 4. CPU 会尝试从无效位置读取中断处理程序 5. 系统崩溃  所以必须先禁用中断，等 IDT 设置好后再启用   FLAGS 寄存器中的 IF 位  FLAGS 寄存器（部分）：  位:  11 10  9  8  7  6  5  4  3  2  1  0     ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐     │OF│DF│IF│TF│SF│ZF│ 0│AF│ 0│PF│ 1│CF│     └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘                  ↑             IF = 0 时，禁止可屏蔽中断             IF = 1 时，允许可屏蔽中断     第 2 行：加载 GDT  \tdata32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000   这是一条复杂的指令，让我们拆解它。  LGDT 指令  LGDT（Load Global Descriptor Table Register）将 GDT 的位置和大小加载到 GDTR 寄存器。  GDTR 寄存器格式   47                  16 15              0 ┌──────────────────────┬─────────────────┐ │    GDT 基地址 (32位)  │  GDT 限长 (16位) │ └──────────────────────┴─────────────────┘  限长 = GDT 大小 - 1（字节） 基地址 = GDT 在内存中的线性地址   data32 和 addr32 前缀  在 16 位实模式下：     - 默认操作数大小是 16 位     - 默认地址大小是 16 位      lgdt 需要读取 6 字节的 GDT 描述符（2 + 4 字节） 但在 16 位模式下默认只读取 5 字节（2 + 3 字节）  data32：使用 32 位操作数大小 addr32：使用 32 位地址大小  这样才能正确读取完整的 48 位 GDT 描述符   地址计算  gdtdesc - LOADER_PHYS_BASE - 0x20000  gdtdesc 的虚拟地址在链接时确定，类似于：     gdtdesc_virtual = LOADER_PHYS_BASE + 0x20000 + offset      要得到物理地址：     物理地址 = 虚拟地址 - LOADER_PHYS_BASE              = offset + 0x20000               但我们需要相对于当前 DS 的偏移：     DS = 0x2000     DS 基址 = 0x2000 × 16 = 0x20000          需要的偏移 = 物理地址 - DS 基址                = (offset + 0x20000) - 0x20000                = offset                 完整公式：     偏移 = gdtdesc - LOADER_PHYS_BASE - 0x20000     第 3-5 行：设置 CR0  \tmovl %cr0, %eax \torl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax \tmovl %eax, %cr0   读取当前 CR0  movl %cr0, %eax   不能直接修改 CR0，必须先读取、修改、再写回。  设置标志位  orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax   CR0_PE = 0x00000001  (位 0)  Protection Enable CR0_EM = 0x00000004  (位 2)  FP Emulation CR0_WP = 0x00010000  (位 16) Write Protect CR0_PG = 0x80000000  (位 31) Paging  组合值：     0x00000001   | 0x00000004   | 0x00010000   | 0x80000000   ─────────────     0x80010005   各标志位的作用                 标志       作用                       PE       启用保护模式。这是最关键的位。                 PG       启用分页。需要 PE=1 才能设置。                 WP       写保护。内核也要遵守页表的写保护标志。                 EM       浮点仿真。浮点指令会产生异常，因为 Pintos 不支持浮点。           写回 CR0  movl %eax, %cr0   执行这条指令的瞬间，CPU 切换到保护模式并启用分页！  但是有个问题…  CPU 缓存了段寄存器的内容！  切换前：     CS = 0x2000（实模式段值）     CS 缓存 = 16 位代码段属性  切换后：     CR0.PE = 1（保护模式）     但 CS 缓存还是旧的！      CPU 现在处于一个奇怪的状态：     - 保护模式已启用     - 但 CS 仍包含实模式属性      必须通过远跳转刷新 CS！     第 6 行：远跳转到 32 位段  \tdata32 ljmp $SEL_KCSEG, $1f   远跳转（Long Jump）  远跳转同时改变 CS 和 EIP：  ljmp $selector, $offset  效果：     CS = selector     EIP = offset     同时刷新 CS 缓存   data32 前缀  我们仍在 16 位代码段中执行。data32 前缀允许使用 32 位的偏移值。  目标地址  $SEL_KCSEG = 0x08（内核代码段选择子） $1f = 标签 \"1:\" 的地址（向前查找）  跳转后：     CS = 0x08（指向 GDT 中的内核代码段描述符）     EIP = 标签 1 的偏移   为什么这能工作？  GDT 中的内核代码段描述符设置：     基地址 = 0     限长 = 4GB     属性 = 32 位代码段  所以：     线性地址 = 段基址 + 偏移 = 0 + EIP = EIP      因为分页已启用且我们有恒等映射：     物理地址 = 线性地址 = EIP  代码继续正常执行！     第 7-8 行：切换到 32 位汇编  \t.code32  1:   .code32 指令  告诉汇编器：从现在开始生成 32 位代码。这不是 CPU 指令，只是汇编器指令。  标签 1:  这是远跳转的目标。从这里开始，我们在真正的 32 位保护模式下运行。    第 9-14 行：重新加载段寄存器  1:\tmov $SEL_KDSEG, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %fs \tmov %ax, %gs \tmov %ax, %ss   为什么要重新加载？  CS 已经通过远跳转更新了。 但其他段寄存器（DS, ES, FS, GS, SS）仍然包含实模式的值！  这些寄存器的缓存还保存着实模式的属性。 必须用新的保护模式选择子重新加载它们。   SEL_KDSEG = 0x10  这是内核数据段的选择子，指向 GDT 第 2 项：  GDT[2] = 内核数据段描述符     基地址 = 0     限长 = 4GB     属性 = 可读写数据段   加载过程  不能直接 mov $immediate, %ds 必须通过通用寄存器中转：  mov $SEL_KDSEG, %ax  # AX = 0x10 mov %ax, %ds         # DS = 0x10，同时加载描述符到 DS 缓存 mov %ax, %es         # 同理 ...     第 15 行：调整栈指针  \taddl $LOADER_PHYS_BASE, %esp   为什么要调整 ESP？  之前：ESP = 0xF000（物理地址）  内核代码被链接到虚拟地址 LOADER_PHYS_BASE + 0x20000 = 0xC0020000 内核期望栈在高地址空间  需要将栈指针也调整到高地址：     新 ESP = 0xF000 + 0xC0000000 = 0xC000F000  这是栈的虚拟地址 通过页表映射到物理地址 0xF000   内存视图  物理内存:                      虚拟内存:                                 0x0000F000 ┌───────┐          0xC000F000 ┌───────┐            │  栈   │    ←───→            │  栈   │            └───────┘                     └───────┘                                 栈在物理地址 0xF000 但我们通过虚拟地址 0xC000F000 访问它 页表将 0xC000F000 映射到 0x0000F000     第 16 行：清除基指针  \tmovl $0, %ebp\t\t\t# Null-terminate main()'s backtrace   什么是 backtrace？  调试时，我们可能想要查看函数调用链（backtrace）：  main()   ↳ pintos_init()     ↳ thread_init()       ↳ 当前位置  backtrace 通过 EBP 链来追踪：     每个函数的栈帧有：     [局部变量]     [保存的 EBP]  ← 当前 EBP 指向这里     [返回地址]     [参数]   为什么设置 EBP = 0？  pintos_init() 是第一个 C 函数 它没有\"调用者\" 如果 backtrace 代码继续追踪，可能读到垃圾  设置 EBP = 0 告诉调试器：     \"这是调用链的终点，不要继续追踪了\"     第 17 行：调用 C 函数  \tcall pintos_init   历史性时刻！  这是第一次从汇编调用 C 函数。从这里开始，内核主要用 C 语言运行。  call 指令的效果  call pintos_init  等价于：     push 下一条指令地址（返回地址）     jmp pintos_init   pintos_init 在哪里？  pintos_init 定义在 init.c 中，是内核的 C 语言入口点。    第 18-19 行：无限循环（以防万一）  1:\tjmp 1b   为什么需要这个？  pintos_init() 正常情况下不应该返回。如果它返回了，说明出了问题。  这个无限循环确保：    系统不会继续执行随机内存   CPU 保持忙碌但不做任何危险操作     GDT 定义详解  代码末尾定义了 GDT：  #### GDT  \t.align 8 gdt: \t.quad 0x0000000000000000\t# Null segment.  Not used by CPU. \t.quad 0x00cf9a000000ffff\t# System code, base 0, limit 4 GB. \t.quad 0x00cf92000000ffff    # System data, base 0, limit 4 GB.  gdtdesc: \t.word\tgdtdesc - gdt - 1\t# Size of the GDT, minus 1 byte. \t.long\tgdt\t\t\t# Address of the GDT.   GDT 对齐  .align 8   GDT 应该在 8 字节边界对齐以获得最佳性能。  段描述符格式  每个段描述符 8 字节：  字节:   7      6      5      4      3      2      1      0       ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐       │Base  │Flags │Limit │Access│      Base [23:0]    │Limit │       │[31:24]│+Lim  │[19:16]│     │                     │[15:0]│       └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘  Base: 段基地址（分散在多处） Limit: 段限长（分散在两处） Flags: G(粒度), D/B(默认大小), L(64位), AVL Access: P(存在), DPL(特权级), S(类型), Type   解析 0x00cf9a000000ffff（代码段）  0x00cf9a000000ffff  按字节分解：     [7] = 0x00  Base[31:24] = 0x00     [6] = 0xcf  Flags + Limit[19:16]                 Flags = 0xc = 1100                     G = 1 (4KB 粒度)                     D = 1 (32 位)                 Limit[19:16] = 0xf     [5] = 0x9a  Access byte = 1001 1010                     P = 1 (存在)                     DPL = 00 (ring 0)                     S = 1 (代码/数据段)                     Type = 1010 (可执行,可读)     [4] = 0x00  Base[23:16] = 0x00     [3:2] = 0x0000  Base[15:0] = 0x0000     [1:0] = 0xffff  Limit[15:0] = 0xffff  完整值：     Base = 0x00000000     Limit = 0xfffff (加上 G=1，实际 limit = 4GB)     32 位代码段，DPL=0，可执行可读   解析 0x00cf92000000ffff（数据段）  与代码段类似，只是 Access byte = 0x92 = 1001 0010     Type = 0010 (可读写数据段)   GDT 描述符（gdtdesc）  gdtdesc: \t.word\tgdtdesc - gdt - 1\t# Size of the GDT, minus 1 byte. \t.long\tgdt\t\t\t        # Address of the GDT.   gdtdesc 结构：  偏移 0-1: 限长 = 24 - 1 = 23 (3 个描述符 × 8 字节 - 1) 偏移 2-5: 基地址 = gdt 的地址  这正是 LGDT 指令期望的格式     完整流程图  flowchart TD     subgraph \"实模式（16位）\"         A[\"cli&lt;br/&gt;禁用中断\"] --&gt; B[\"lgdt&lt;br/&gt;加载 GDT\"]         B --&gt; C[\"movl %cr0, %eax&lt;br/&gt;读取 CR0\"]         C --&gt; D[\"orl PE|PG|WP|EM&lt;br/&gt;设置标志位\"]         D --&gt; E[\"movl %eax, %cr0&lt;br/&gt;写入 CR0\"]         E --&gt; F[\"ljmp SEL_KCSEG&lt;br/&gt;远跳转\"]     end          F --&gt; G[\"保护模式切换点\"]          subgraph \"保护模式（32位）\"         G --&gt; H[\"mov SEL_KDSEG, %ax&lt;br/&gt;设置选择子\"]         H --&gt; I[\"重新加载所有段寄存器&lt;br/&gt;DS, ES, FS, GS, SS\"]         I --&gt; J[\"addl LOADER_PHYS_BASE, %esp&lt;br/&gt;调整栈指针\"]         J --&gt; K[\"movl $0, %ebp&lt;br/&gt;清除 backtrace\"]         K --&gt; L[\"call pintos_init&lt;br/&gt;进入 C 代码\"]     end          style A fill:#f99,stroke:#333     style L fill:#9f9,stroke:#333     关键时刻的 CPU 状态  ═══════════════════════════════════════════════════════════════════              执行 movl %eax, %cr0 之前 ═══════════════════════════════════════════════════════════════════ 模式:       16 位实模式 CR0:        0x????????（各种位清零） CS:         0x2000（实模式段地址） EIP:        某个低地址偏移 分页:       禁用 GDTR:       已加载指向新 GDT  ═══════════════════════════════════════════════════════════════════              执行 movl %eax, %cr0 之后，ljmp 之前 ═══════════════════════════════════════════════════════════════════ 模式:       保护模式（但 CS 缓存还是 16 位！） CR0.PE:     1（保护模式启用） CR0.PG:     1（分页启用） CS:         0x2000（旧值，缓存中是 16 位属性） EIP:        继续执行 状态:       ⚠️ 不稳定！必须立即执行远跳转！  ═══════════════════════════════════════════════════════════════════              执行 ljmp 之后 ═══════════════════════════════════════════════════════════════════ 模式:       32 位保护模式 CR0.PE:     1 CR0.PG:     1 CS:         0x08（内核代码段选择子）             缓存: 32 位代码段，DPL=0，基址=0 EIP:        标签 1 的虚拟地址 DS,ES,SS:   还是旧的实模式值  ═══════════════════════════════════════════════════════════════════              重新加载段寄存器之后 ═══════════════════════════════════════════════════════════════════ 所有段寄存器: 加载了正确的保护模式选择子 ESP:        0xC000F000（高地址虚拟栈） EBP:        0（backtrace 终点） 状态:       ✓ 完全进入 32 位保护模式，可以调用 C 函数 ═══════════════════════════════════════════════════════════════════     常见问题  Q1: 为什么要同时启用 PE 和 PG？  A: 可以分开启用，但 Pintos 选择一步到位。同时启用需要确保：    页表已经正确设置（我们已经做了）   恒等映射存在（代码可以继续执行）   分开启用会需要更多代码，没有必要。  Q2: 如果没有执行远跳转会怎样？  A: CPU 会继续使用缓存的旧段属性。这可能导致：    指令解码错误（16 位 vs 32 位）   地址计算错误   不可预测的行为   最终崩溃   远跳转是刷新 CS 缓存的唯一方法。  Q3: 为什么内核代码段基址是 0？  A: 现代操作系统使用”平坦内存模型”：  平坦模型：     所有段基址 = 0     所有段限长 = 4GB     段:偏移 = 0 + 偏移 = 偏移      效果：     线性地址 = 偏移     分页负责真正的内存保护和地址转换     段机制基本被绕过   这简化了编程模型，内存保护完全由分页机制处理。  Q4: CR0.WP 有什么用？  A: WP（Write Protect）确保内核也要遵守页表中的写保护位：  如果 WP = 0：     Ring 0 代码可以写入任何页，忽略只读标志     危险！可能意外覆盖只读数据或代码      如果 WP = 1：     Ring 0 也必须遵守页表的写保护     写只读页会产生页错误     更安全，可以捕获内核 bug     练习思考  思考题 1 如果在设置 CR0.PE 后、执行远跳转前发生 NMI（不可屏蔽中断），会怎样？   点击查看答案  NMI 不受 IF 标志影响，`cli` 无法阻止它。  如果发生 NMI： 1. CPU 尝试查找 IDT 中的处理程序 2. 我们还没设置 IDT 3. CPU 可能读到垃圾地址 4. 跳转到随机位置 5. 系统崩溃  这是一个竞态条件，但 NMI 极少发生（通常只在硬件错误时）。 实际上，这个窗口只有几条指令，风险很低。  更健壮的实现可以在切换前设置一个临时 IDT。    思考题 2 为什么 call pintos_init 能正常工作？函数地址不是链接到高地址吗？   点击查看答案  是的，`pintos_init` 链接到类似 0xC00XXXXX 的高地址。  但这正是为什么需要高地址映射！  ``` call pintos_init 的过程：  1. 链接器将 pintos_init 的地址放入 call 指令    例如：call 0xC0021000  2. call 执行：    - push 返回地址    - jmp 0xC0021000  3. CPU 访问虚拟地址 0xC0021000  4. 分页单元查找：    - 页目录索引 = 0xC0021000 &gt;&gt; 22 = 768    - 页表索引 = (0xC0021000 &gt;&gt; 12) &amp; 0x3FF = 33    - 物理地址 = 0x00021000  5. 代码从物理地址 0x21000 执行    这正是 pintos_init 所在的位置！ ```  高地址映射让这一切透明地工作。    思考题 3 如果 GDT 放在会被覆盖的内存位置会怎样？   点击查看答案  GDT 必须在整个系统运行期间保持有效。  如果 GDT 被覆盖： 1. 段寄存器已经加载了描述符缓存 2. 短期内可能没问题 3. 但如果进行任务切换或重新加载段寄存器 4. CPU 会从被覆盖的 GDT 读取垃圾 5. 系统崩溃  Pintos 的 GDT 放在 `.start` 段中，与内核代码一起，不会被随意覆盖。  在更复杂的系统中，GDT 通常在初始化后被复制到一个永久、受保护的位置。      下一步  我们已经成功切换到保护模式并调用了 pintos_init()。下一篇文档将详细介绍 GDT 的结构和段描述符的各个字段：GDT 全局描述符表"
  },
  
  {
    "title": "Pintos Kernel 启动详解（四）：临时页表创建",
    "url": "/posts/pintos-kernel-04-page-tables/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, 分页, 页表",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  在切换到保护模式并启用分页之前，必须先创建页表结构。这部分代码在实模式下创建一个临时的页目录和页表，用于映射前 64MB 的物理内存。  这个临时页表有两个重要特点：    恒等映射：虚拟地址等于物理地址（用于切换过程）   高地址映射：从 0xC0000000 开始的地址也映射到物理内存（内核将在这里运行）     原始代码  #### Create temporary page directory and page table and set page #### directory base register.  # Create page directory at 0xf000 (60 kB) and fill with zeroes. \tmov $0xf00, %ax \tmov %ax, %es \tsubl %eax, %eax \tsubl %edi, %edi \tmovl $0x400, %ecx \trep stosl  # Add PDEs to point to page tables for the first 64 MB of RAM. # Also add identical PDEs starting at LOADER_PHYS_BASE. # See [IA32-v3a] section 3.7.6 \"Page-Directory and Page-Table Entries\" # for a description of the bits in %eax.  \tmovl $0x10007, %eax \tmovl $0x11, %ecx \tsubl %edi, %edi 1:\tmovl %eax, %es:(%di) \tmovl %eax, %es:LOADER_PHYS_BASE &gt;&gt; 20(%di) \taddw $4, %di \taddl $0x1000, %eax \tloop 1b  # Set up page tables for one-to-map linear to physical map for the # first 64 MB of RAM. # See [IA32-v3a] section 3.7.6 \"Page-Directory and Page-Table Entries\" # for a description of the bits in %eax.  \tmovw $0x1000, %ax \tmovw %ax, %es \tmovl $0x7, %eax \tmovl $0x4000, %ecx \tsubl %edi, %edi 1:\tmovl %eax, %es:(%di) \taddw $4, %di \taddl $0x1000, %eax \tloop 1b  # Set page directory base register.  \tmovl $0xf000, %eax \tmovl %eax, %cr3     前置知识  x86 分页机制  x86 分页使用两级页表结构（在非 PAE 模式下）：  32 位虚拟地址分解：   31        22 21        12 11         0 ┌───────────┬────────────┬────────────┐ │  PDE 索引  │  PTE 索引   │  页内偏移   │ │  (10 位)   │  (10 位)    │  (12 位)   │ └───────────┴────────────┴────────────┘  地址转换过程： 1. 用高 10 位索引页目录，找到页表地址 2. 用中间 10 位索引页表，找到物理页框地址 3. 加上低 12 位偏移，得到最终物理地址   页目录和页表的布局  页目录（Page Directory）:     - 包含 1024 个 PDE（Page Directory Entry）     - 每个 PDE 4 字节     - 总大小 = 1024 × 4 = 4096 字节 = 1 页     - 每个 PDE 指向一个页表  页表（Page Table）:     - 包含 1024 个 PTE（Page Table Entry）     - 每个 PTE 4 字节     - 总大小 = 1024 × 4 = 4096 字节 = 1 页     - 每个 PTE 映射一个 4KB 物理页  一个页目录可以映射的内存：     1024 PDEs × 1024 PTEs × 4KB = 4GB   页目录项（PDE）格式   31                    12 11  9 8 7 6 5 4 3 2 1 0 ┌────────────────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ │    页表物理地址[31:12]   │ AVL │G│S│0│A│D│W│U│W│P│ └────────────────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘                               │ │ │   │ │ │ │ │ │                               │ │ │   │ │ │ │ │ └─ P: Present (存在位)                               │ │ │   │ │ │ │ └─── R/W: Read/Write                               │ │ │   │ │ │ └───── U/S: User/Supervisor                               │ │ │   │ │ └─────── PWT: Page Write-Through                               │ │ │   │ └───────── PCD: Page Cache Disable                               │ │ │   └─────────── A: Accessed                               │ │ └─────────────── PS: Page Size (4MB页)                               │ └───────────────── G: Global                               └─────────────────── AVL: Available   页表项（PTE）格式  与 PDE 类似，但地址部分指向物理页框：   31                    12 11  9 8 7 6 5 4 3 2 1 0 ┌────────────────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ │    物理页地址[31:12]     │ AVL │G│0│D│A│C│W│U│W│P│ └────────────────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘   Pintos 的内存映射策略  Pintos 创建两套映射：  1. 恒等映射（Identity Mapping）:    虚拟地址 0x00000000 - 0x03FFFFFF → 物理地址 0x00000000 - 0x03FFFFFF    用于模式切换时代码可以继续执行  2. 高地址映射:    虚拟地址 0xC0000000 - 0xC3FFFFFF → 物理地址 0x00000000 - 0x03FFFFFF    内核代码链接到这个地址范围  两种映射指向相同的物理内存！     逐行详解  第 1-5 行：清零页目录  # Create page directory at 0xf000 (60 kB) and fill with zeroes. \tmov $0xf00, %ax \tmov %ax, %es \tsubl %eax, %eax \tsubl %edi, %edi \tmovl $0x400, %ecx \trep stosl   页目录位置选择  选择 0xF000 (60 KB) 的原因：    在内核 (0x20000) 之前   在栈之下（栈从 0xF000 向下增长，但我们现在重用这块空间）   页对齐（必须是 4KB 边界）   设置 ES 段  mov $0xf00, %ax mov %ax, %es   ES = 0x0F00 物理基址 = 0x0F00 × 16 = 0xF000  后续使用 ES:DI 寻址： ES:DI = 0x0F00:0x0000 = 物理地址 0xF000   清零 EAX 和 EDI  subl %eax, %eax    # EAX = 0（要存储的值） subl %edi, %edi    # EDI = 0（目标偏移）   使用 sub reg, reg 比 mov $0, reg 节省空间。  设置计数并执行  movl $0x400, %ecx  # ECX = 1024（双字数量） rep stosl          # 重复存储 EAX 到 ES:DI   rep stosl 的工作原理：  while (ECX != 0) {     ES:[DI] = EAX      # 存储 4 字节     DI += 4            # 递增（因为前面执行了 cld）     ECX -= 1           # 减少计数 }  结果：从 ES:0 开始的 1024 × 4 = 4096 字节被清零 即整个页目录被清零     第 6-13 行：填充页目录项  # Add PDEs to point to page tables for the first 64 MB of RAM. # Also add identical PDEs starting at LOADER_PHYS_BASE.  \tmovl $0x10007, %eax \tmovl $0x11, %ecx \tsubl %edi, %edi 1:\tmovl %eax, %es:(%di) \tmovl %eax, %es:LOADER_PHYS_BASE &gt;&gt; 20(%di) \taddw $4, %di \taddl $0x1000, %eax \tloop 1b   初始 PDE 值 0x10007  0x10007 = 0001 0000 0000 0000 0111 (二进制)  解析：     地址部分 [31:12] = 0x10 = 0x10000 &gt;&gt; 12     第一个页表位于物理地址 0x10000 (64 KB)          标志位：     位 0 (P)   = 1：页表存在     位 1 (R/W) = 1：可写     位 2 (U/S) = 1：用户可访问     其他位     = 0   为什么需要 17 个 PDE？  movl $0x11, %ecx   # 0x11 = 17   每个 PDE 映射 4 MB：     1 PDE → 1 页表 → 1024 PTE → 1024 × 4KB = 4MB  映射 64 MB 需要：     64 MB ÷ 4 MB = 16 个 PDE  但代码设置 17 个？让我们验证：     实际上是 16 + 1 = 17，可能是为了包含边界     或者代码作者考虑了对齐问题      更正：0x11 = 17，但循环前 ECX 已经减 1 实际上 loop 会执行 17 次  64 MB = 16 个 4MB 区块，需要 16 个页表 但代码可能故意多设置一个以留余量   双重映射的实现  1:\tmovl %eax, %es:(%di) \tmovl %eax, %es:LOADER_PHYS_BASE &gt;&gt; 20(%di)   两条 movl 指令实现双重映射：  1. movl %eax, %es:(%di)    写入低地址映射的 PDE    例如：PDE[0] 映射虚拟地址 0x00000000-0x003FFFFF  2. movl %eax, %es:LOADER_PHYS_BASE &gt;&gt; 20(%di)    写入高地址映射的 PDE    LOADER_PHYS_BASE = 0xC0000000    0xC0000000 &gt;&gt; 20 = 0xC00        0xC00 是什么？    页目录偏移 = (虚拟地址 &gt;&gt; 22) × 4    0xC0000000 &gt;&gt; 22 = 0x300 = 768 (十进制)    偏移 = 768 × 4 = 3072 = 0xC00        所以这写入 PDE[768+n]   页目录布局图  页目录（位于 0xF000）:  索引    偏移     指向页表        映射的虚拟地址范围 ────    ────     ────────        ────────────────── 0       0x000    0x10000         0x00000000-0x003FFFFF 1       0x004    0x11000         0x00400000-0x007FFFFF 2       0x008    0x12000         0x00800000-0x00BFFFFF ... 15      0x03C    0x1F000         0x03C00000-0x03FFFFFF 16      0x040    0x20000         0x04000000-0x043FFFFF  ... (中间全是 0，表示未映射) ...  768     0xC00    0x10000         0xC0000000-0xC03FFFFF  ← 高地址映射 769     0xC04    0x11000         0xC0400000-0xC07FFFFF ... 783     0xC3C    0x1F000         0xC3C00000-0xC3FFFFFF 784     0xC40    0x20000         0xC4000000-0xC43FFFFF   循环过程  addw $4, %di       # DI += 4（移动到下一个 PDE） addl $0x1000, %eax # EAX += 0x1000（下一个页表地址） loop 1b            # ECX--; if(ECX!=0) goto 1   每次迭代：     DI 增加 4（下一个 PDE 偏移）     EAX 的地址部分增加 0x1000（下一个页表地址）      页表地址序列：     0x10000, 0x11000, 0x12000, ..., 0x20000     第 14-22 行：填充页表  # Set up page tables for one-to-map linear to physical map for the # first 64 MB of RAM.  \tmovw $0x1000, %ax \tmovw %ax, %es \tmovl $0x7, %eax \tmovl $0x4000, %ecx \tsubl %edi, %edi 1:\tmovl %eax, %es:(%di) \taddw $4, %di \taddl $0x1000, %eax \tloop 1b   页表位置  movw $0x1000, %ax movw %ax, %es      # ES = 0x1000   ES:0 = 0x1000:0 = 物理地址 0x10000 (64 KB) 页表从 0x10000 开始，紧接在页目录之后   初始 PTE 值  movl $0x7, %eax   0x7 = 0000 0111 (二进制)  解析：     地址部分 [31:12] = 0（第一个物理页）          标志位：     位 0 (P)   = 1：页存在     位 1 (R/W) = 1：可写     位 2 (U/S) = 1：用户可访问      第一个 PTE 映射物理地址 0x00000   PTE 数量  movl $0x4000, %ecx   # 0x4000 = 16384   为什么是 16384？  64 MB ÷ 4 KB = 16384 页 每页需要一个 PTE 所以需要 16384 个 PTE  16384 × 4 字节 = 65536 字节 = 64 KB 16384 ÷ 1024 = 16 个页表   填充循环  1:\tmovl %eax, %es:(%di)   # 存储 PTE \taddw $4, %di            # 下一个 PTE \taddl $0x1000, %eax      # 下一个物理页地址 \tloop 1b   每次迭代：     存储当前 PTE     DI += 4     EAX 的地址增加 0x1000 (4 KB)  PTE 值序列：     0x00000007 → 映射物理页 0x00000     0x00001007 → 映射物理页 0x01000     0x00002007 → 映射物理页 0x02000     ...     0x03FFF007 → 映射物理页 0x03FFF000 (64MB - 4KB)     第 23-25 行：设置 CR3  # Set page directory base register.  \tmovl $0xf000, %eax \tmovl %eax, %cr3   CR3 寄存器  CR3（也叫 PDBR - Page Directory Base Register）存储页目录的物理地址。  CR3 寄存器格式：   31                    12 11        5 4 3 2  0 ┌────────────────────────┬──────────┬─┬─┬────┐ │   页目录物理地址[31:12]  │ Reserved │P│P│    │ │                        │          │C│W│Ign │ │                        │          │D│T│    │ └────────────────────────┴──────────┴─┴─┴────┘  PCD: Page-level Cache Disable PWT: Page-level Write-Through   设置效果  movl $0xf000, %eax movl %eax, %cr3   将 0xF000 写入 CR3，告诉 CPU 页目录在物理地址 0xF000。  注意：此时分页还未启用（CR0.PG = 0），所以这只是准备工作。    内存布局图  创建页表后的内存布局：      0x0F000 ┌─────────────────────┐ ← 页目录 (4KB)             │ PDE[0]   → 0x10000  │   映射 0x00000000             │ PDE[1]   → 0x11000  │   映射 0x00400000             │ ...                 │             │ PDE[16]  → 0x20000  │   映射 0x04000000             │ ...                 │   (未使用)             │ PDE[768] → 0x10000  │   映射 0xC0000000             │ PDE[769] → 0x11000  │   映射 0xC0400000             │ ...                 │             │ PDE[784] → 0x20000  │   映射 0xC4000000     0x10000 ├─────────────────────┤ ← 页表 0 (4KB)             │ PTE[0]   → 0x00000  │             │ PTE[1]   → 0x01000  │             │ ...                 │             │ PTE[1023]→ 0x3FF000 │     0x11000 ├─────────────────────┤ ← 页表 1 (4KB)             │ ...                 │     ...     │                     │     0x20000 ├─────────────────────┤ ← 页表 16 (4KB) + 内核开始             │ Pintos Kernel Code  │             │ ...                 │     地址转换示例  示例：访问虚拟地址 0xC0001234  步骤 1：解析虚拟地址     0xC0001234 = 1100 0000 0000 0000 0001 0010 0011 0100          PDE 索引 = 高 10 位 = 11 0000 0000 = 768     PTE 索引 = 中 10 位 = 00 0000 0001 = 1       偏移     = 低 12 位 = 0010 0011 0100 = 0x234  步骤 2：查找 PDE     页目录地址 = CR3 = 0xF000     PDE 地址 = 0xF000 + 768×4 = 0xF000 + 0xC00 = 0xFC00     PDE[768] = 0x10007     页表地址 = 0x10000  步骤 3：查找 PTE     PTE 地址 = 0x10000 + 1×4 = 0x10004     PTE[1] = 0x1007     物理页地址 = 0x1000  步骤 4：计算物理地址     物理地址 = 0x1000 + 0x234 = 0x1234  结论：虚拟地址 0xC0001234 → 物理地址 0x00001234     完整流程图  flowchart TD     subgraph \"阶段 1：清零页目录\"         A1[\"ES = 0x0F00&lt;br/&gt;指向 0xF000\"] --&gt; A2[\"EAX = 0, EDI = 0\"]         A2 --&gt; A3[\"ECX = 1024\"]         A3 --&gt; A4[\"rep stosl&lt;br/&gt;清零 4KB\"]     end          subgraph \"阶段 2：填充 PDE\"         A4 --&gt; B1[\"EAX = 0x10007&lt;br/&gt;首个页表地址+标志\"]         B1 --&gt; B2[\"ECX = 17\"]         B2 --&gt; B3[\"循环：写入 PDE[n] 和 PDE[n+768]\"]         B3 --&gt; B4{\"ECX = 0?\"}         B4 --&gt;|否| B3         B4 --&gt;|是| C1     end          subgraph \"阶段 3：填充 PTE\"         C1[\"ES = 0x1000&lt;br/&gt;指向 0x10000\"] --&gt; C2[\"EAX = 0x7&lt;br/&gt;首个物理页+标志\"]         C2 --&gt; C3[\"ECX = 16384\"]         C3 --&gt; C4[\"循环：写入 PTE\"]         C4 --&gt; C5{\"ECX = 0?\"}         C5 --&gt;|否| C4         C5 --&gt;|是| D1     end          subgraph \"阶段 4：设置 CR3\"         D1[\"movl $0xf000, %eax\"]         D1 --&gt; D2[\"movl %eax, %cr3\"]         D2 --&gt; D3[\"CR3 指向页目录&lt;br/&gt;准备启用分页\"]     end          style A1 fill:#f9f,stroke:#333     style D3 fill:#9f9,stroke:#333     常见问题  Q1: 为什么需要两套映射？  A: 这是模式切换的关键技巧：  切换到保护模式 + 分页后，下一条指令的获取：  如果只有高地址映射：     EIP 还在低地址（如 0x20100）     但 0x20100 没有映射     → 页错误，系统崩溃！  有了恒等映射：     EIP = 0x20100     查页表：0x20100 → 物理 0x20100     → 正常执行      然后跳转到高地址代码后，可以移除恒等映射   Q2: 为什么页目录和页表必须 4KB 对齐？  A: 因为 PDE 和 CR3 中的地址字段只存储高 20 位：  PDE 格式：     [31:12] = 页表地址的高 20 位     [11:0]  = 标志位      这意味着地址必须是 4096 (2^12) 的倍数   Q3: 创建页表后为什么还能继续在实模式下运行？  A: 页表只是内存中的数据结构。在 CR0.PG = 0 时，CPU 完全忽略 CR3 和页表。只有当启用分页后，这些结构才会生效。  Q4: 为什么不使用 4MB 大页？  A: x86 支持 4MB 页（通过 PDE 的 PS 位），可以简化页表结构。但：    4MB 页是可选特性，不是所有 CPU 都支持   4KB 页提供更细粒度的内存保护   教学目的使用标准页更容易理解     练习思考  思考题 1 如果我们要映射 128MB 而不是 64MB，需要修改哪些地方？   点击查看答案  需要修改：  1. 内存检测代码中的上限：    ```plaintext    cmp $0x20000, %eax   # 改为 128 MB    ```  2. PDE 数量：    ```plaintext    movl $0x21, %ecx     # 32+1 = 33 个 PDE    ```  3. PTE 数量：    ```plaintext    movl $0x8000, %ecx   # 32768 个 PTE    ```  4. 确保页表区域不与内核冲突：    128MB = 32 个页表 × 4KB = 128KB 页表空间    从 0x10000 到 0x30000，可能与内核重叠！    需要重新规划内存布局。    思考题 2 rep stosl 执行时如果被中断会怎样？   点击查看答案  在实模式下： - 中断可能发生 - CPU 会保存当前状态（包括 ECX、EDI） - 中断处理后恢复执行 - `rep stosl` 继续从断点执行  但在 Pintos 启动代码中： - 我们还没设置 IDT - 中断发生会导致不可预测行为 - 但通常 BIOS 已经禁用了大多数中断 - 后面很快会执行 `cli` 显式禁用中断    思考题 3 为什么低地址映射从 PDE[0] 开始，而高地址映射从 PDE[768] 开始？   点击查看答案  这由虚拟地址决定：  ``` 虚拟地址 0x00000000：     PDE 索引 = 0x00000000 &gt;&gt; 22 = 0     所以从 PDE[0] 开始  虚拟地址 0xC0000000 (LOADER_PHYS_BASE)：     PDE 索引 = 0xC0000000 &gt;&gt; 22 = 768     所以从 PDE[768] 开始  0xC0000000 &gt;&gt; 20 = 0xC00 是偏移量（字节），不是索引 0xC00 / 4 = 768 才是索引 ```  代码中使用 `&gt;&gt; 20` 而不是 `&gt;&gt; 22` 是因为它直接计算字节偏移，用于加到 DI 上。      下一步  临时页表已经创建完成，CR3 也已设置。现在万事俱备，可以切换到保护模式并启用分页了。下一篇文档将介绍这个关键步骤：保护模式切换"
  },
  
  {
    "title": "Pintos Kernel 启动详解（三）：A20 地址线启用",
    "url": "/posts/pintos-kernel-03-a20-gate/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, A20, 键盘控制器",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  A20 地址线问题是 x86 架构最著名的历史包袱之一。由于早期 IBM PC 的兼容性设计，地址线 A20 在系统启动时被禁用，导致无法访问 1MB 以上的内存。  本节代码通过键盘控制器（8042）启用 A20 地址线，为访问扩展内存做准备。    原始代码  #### Enable A20.  Address line 20 is tied low when the machine boots, #### which prevents addressing memory about 1 MB.  This code fixes it.  # Poll status register while busy.  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b  # Send command for writing output port.  \tmovb $0xd1, %al \toutb %al, $0x64  # Poll status register while busy.  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b  # Enable A20 line.  \tmovb $0xdf, %al \toutb %al, $0x60  # Poll status register while busy.  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b     前置知识  A20 地址线的历史  故事背景：1981年的 IBM PC  最初的 IBM PC 使用 Intel 8088 CPU，有 20 根地址线（A0-A19），可以寻址 2^20 = 1MB 内存。  地址回绕特性  在 8088 上，当程序访问超过 1MB 的地址时，地址会”回绕”：  1MB = 0x100000 访问 0x100000 实际访问 0x00000 访问 0x100001 实际访问 0x00001 ...  这是因为第 21 位（A20）不存在，被忽略   一些早期程序（包括某些 DOS 程序）依赖这个回绕行为！  80286 的问题  1982年的 Intel 80286 有 24 根地址线（A0-A23），可以寻址 16MB。但如果 A20 总是有效，那些依赖回绕的旧程序就会崩溃。  IBM 的”解决方案”  IBM 的工程师想出了一个”天才”的方法：  通过键盘控制器（8042芯片）的一个空闲引脚来控制 A20！  默认情况下，A20 被强制拉低（等于0） 这样地址就会像 8088 一样回绕 需要访问高内存时，通过键盘控制器启用 A20   这个设计一直保留到现代 x86 系统中，成为了著名的历史包袱。  A20 对内存访问的影响  A20 禁用时的地址映射：  物理地址（期望）    实际访问地址 ────────────────    ────────────── 0x000000            0x000000    (正常) 0x0FFFFF            0x0FFFFF    (正常，1MB-1) 0x100000            0x000000    (回绕！) 0x100001            0x000001    (回绕！) 0x1FFFFF            0x0FFFFF    (回绕！) 0x200000            0x000000    (再次回绕！)  A20 启用后： 所有地址正常访问，不再回绕   8042 键盘控制器  8042（或兼容芯片）是 PC 中的键盘控制器，但它也被赋予了一些额外的功能，包括控制 A20 线。  端口地址                 端口       读取时       写入时                       0x60       输出缓冲区（数据）       输入缓冲区（数据/命令参数）                 0x64       状态寄存器       命令寄存器           状态寄存器 (端口 0x64 读取)  位 7  6  5  4  3  2  1  0    │  │  │  │  │  │  │  │    │  │  │  │  │  │  │  └─ OBF: 输出缓冲区满（数据可读）    │  │  │  │  │  │  └──── IBF: 输入缓冲区满（控制器忙）    │  │  │  │  │  └─────── 系统标志    │  │  │  │  └────────── 命令/数据（0=数据，1=命令）    │  │  │  └───────────── 键盘解锁    │  │  └──────────────── 辅助设备输出缓冲区满    │  └─────────────────── 超时错误    └────────────────────── 奇偶错误   我们关心的是位 1 (IBF)：    IBF = 0：控制器空闲，可以发送命令   IBF = 1：控制器忙，需要等待     逐行详解  第 1-3 行：等待控制器空闲（第一次）  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b   这是一个轮询循环  flowchart TD     A[\"1: inb $0x64, %al&lt;br/&gt;读取状态寄存器\"] --&gt; B[\"testb $0x2, %al&lt;br/&gt;测试位1 (IBF)\"]     B --&gt; C{\"IBF = 1?&lt;br/&gt;控制器忙?\"}     C --&gt;|是| A     C --&gt;|否| D[\"退出循环&lt;br/&gt;控制器空闲\"]   指令详解                 指令       说明                       inb $0x64, %al       从端口 0x64 读取一个字节到 AL                 testb $0x2, %al       测试 AL 的位 1（与 0x2 进行 AND 操作）                 jnz 1b       如果结果非零（位1=1），跳转回标签 1           testb 指令  testb $0x2, %al  效果：计算 AL AND 0x02，设置标志位，不保存结果  0x02 = 0000 0010 (只有位1为1)  示例：     AL = 0x03 = 0000 0011     0x02      = 0000 0010     AND 结果  = 0000 0010 = 0x02 (非零)     ZF = 0 (Zero Flag)          AL = 0x01 = 0000 0001     0x02      = 0000 0010     AND 结果  = 0000 0000 = 0x00 (零)     ZF = 1 (Zero Flag)     第 4-5 行：发送”写输出端口”命令  \tmovb $0xd1, %al \toutb %al, $0x64   命令 0xD1  向端口 0x64 写入 0xD1 告诉键盘控制器：     “接下来写入 0x60 端口的数据应该被当作输出端口的新值”   输出端口的结构  8042 的输出端口包含几个控制位：  输出端口 (通过命令 0xD0 读取，0xD1 写入):  位 7  6  5  4  3  2  1  0    │  │  │  │  │  │  │  │    │  │  │  │  │  │  │  └─ 系统复位（0=复位）    │  │  │  │  │  │  └──── A20 Gate（1=启用）← 我们要设置这个！    │  │  │  │  │  └─────── 未定义    │  │  │  │  └────────── 未定义    │  │  │  └───────────── 输出缓冲区满中断    │  │  └──────────────── 输入缓冲区空中断    │  └─────────────────── 键盘时钟    └────────────────────── 键盘数据     第 6-8 行：等待控制器空闲（第二次）  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b   与第一次相同的等待循环。必须等待控制器处理完 0xD1 命令后才能发送数据。    第 9-10 行：写入启用 A20 的值  \tmovb $0xdf, %al \toutb %al, $0x60   为什么是 0xDF？  0xDF = 1101 1111  位分析：     位 0 = 1：不复位系统     位 1 = 1：启用 A20！     位 2 = 1：未定义，保持为 1     位 3 = 1：未定义，保持为 1     位 4 = 1：启用输出缓冲区满中断     位 5 = 1：启用输入缓冲区空中断     位 6 = 1：键盘时钟高     位 7 = 1：键盘数据高   简而言之：设置所有位为 1，特别是位 1 来启用 A20。  注意端口变化  命令发送到端口 0x64 数据发送到端口 0x60  这是 8042 的标准协议     第 11-13 行：等待控制器空闲（第三次）  1:\tinb $0x64, %al \ttestb $0x2, %al \tjnz 1b   最后一次等待，确保 A20 启用命令被处理完毕。    完整流程图  flowchart TD     subgraph \"第一阶段：等待空闲\"         A1[\"读取状态&lt;br/&gt;inb $0x64, %al\"] --&gt; A2{\"IBF=1?\"}         A2 --&gt;|是| A1         A2 --&gt;|否| B1     end          subgraph \"第二阶段：发送命令\"         B1[\"发送命令 0xD1&lt;br/&gt;outb %al, $0x64\"]     end          subgraph \"第三阶段：等待空闲\"         B1 --&gt; C1[\"读取状态&lt;br/&gt;inb $0x64, %al\"] --&gt; C2{\"IBF=1?\"}         C2 --&gt;|是| C1         C2 --&gt;|否| D1     end          subgraph \"第四阶段：启用A20\"         D1[\"发送数据 0xDF&lt;br/&gt;outb %al, $0x60\"]     end          subgraph \"第五阶段：等待完成\"         D1 --&gt; E1[\"读取状态&lt;br/&gt;inb $0x64, %al\"] --&gt; E2{\"IBF=1?\"}         E2 --&gt;|是| E1         E2 --&gt;|否| F1[\"A20 已启用！\"]     end          style A1 fill:#f9f,stroke:#333     style F1 fill:#9f9,stroke:#333     I/O 端口操作详解  IN 指令  inb $port, %al    # 从 port 读取 1 字节到 AL inw $port, %ax    # 从 port 读取 2 字节到 AX inl $port, %eax   # 从 port 读取 4 字节到 EAX   OUT 指令  outb %al, $port   # 将 AL 写入 port outw %ax, $port   # 将 AX 写入 port outl %eax, $port  # 将 EAX 写入 port   端口 vs 内存  内存访问：     mov (%ebx), %eax    # 读取内存     mov %eax, (%ebx)    # 写入内存  端口访问：     inb $port, %al      # 读取端口     outb %al, $port     # 写入端口  端口是独立的地址空间，不是内存映射！ x86 有 65536 个 I/O 端口（0x0000 - 0xFFFF）     其他启用 A20 的方法  通过键盘控制器不是唯一的方法。以下是几种替代方案：  方法 2：BIOS INT 15h  # 使用 BIOS 服务启用 A20 mov $0x2401, %ax int $0x15   更简单，但并非所有 BIOS 都支持。  方法 3：Fast A20 Gate  # 通过系统控制端口 A（端口 0x92） inb $0x92, %al orb $0x02, %al outb %al, $0x92   更快，但可能导致某些系统出问题。  方法 4：键盘控制器命令 0xDF  # 直接命令启用 A20 mov $0xdf, %al outb %al, $0x64   某些键盘控制器支持这种简化方法。  Pintos 为什么选择当前方法？     兼容性：这是最标准的方法，几乎所有 PC 都支持   可靠性：正确处理了等待控制器空闲   完整性：设置了输出端口的所有相关位     验证 A20 是否启用  启用 A20 后，可以通过以下方式验证：  # 验证 A20：比较 0x000000 和 0x100000 处的内容 # 如果 A20 禁用，它们会映射到同一位置  mov $0, %ax mov %ax, %es            # ES = 0 mov $0xFFFF, %ax mov %ax, %fs            # FS = 0xFFFF  # 在 ES:0 (物理 0x000000) 写入值 movl $0x12345678, %es:0  # 从 FS:0x10 (物理 0x100000) 读取 # FS:0x10 = 0xFFFF * 16 + 0x10 = 0x100000 movl %fs:0x10, %eax  # 比较 cmp $0x12345678, %eax je a20_disabled         # 如果相同，A20 仍禁用   Pintos 没有这个验证代码，假设启用成功。    常见问题  Q1: 为什么 A20 用键盘控制器控制？  A: 纯粹是历史原因。当 IBM 设计 PC/AT 时，需要一种方式来控制 A20，而键盘控制器碰巧有一个空闲的输出引脚。使用现有硬件比添加新芯片便宜。这个”临时”解决方案一直沿用至今。  Q2: 现代系统还需要启用 A20 吗？  A: 是的！现代 x86 CPU 和主板仍然模拟这个行为以保持兼容性。BIOS 启动时 A20 默认禁用。不过，许多 BIOS 会在启用保护模式之前自动启用 A20。  Q3: 如果不启用 A20 就切换到保护模式会怎样？  A: 系统会表现出奇怪的行为：    访问奇数 MB 的内存会回绕到偶数 MB   例如：访问 3MB 位置实际访问 2MB 位置   内核可能会覆盖自己的代码或数据   通常导致系统崩溃   Q4: 轮询循环会不会无限循环？  A: 在正常工作的硬件上不会。键盘控制器通常在几微秒内处理完命令。如果控制器真的卡住了，系统会挂起，这是硬件故障的表现。    技术细节补充  8042 命令表（部分）                 命令       功能                       0x20       读取命令字节                 0x60       写入命令字节                 0xD0       读取输出端口                 0xD1       写入输出端口                 0xDD       禁用 A20                 0xDF       启用 A20                 0xFE       系统复位（脉冲）           时序考虑  8042 键盘控制器的大致时序：  命令/数据写入后，控制器需要处理时间 典型的处理时间：10-100 微秒  轮询循环确保： 1. 不在控制器忙时发送数据 2. 给控制器足够时间处理上一个命令     练习思考  思考题 1 为什么要轮询三次而不是两次？能不能去掉最后一次轮询？   点击查看答案  三次轮询的原因： 1. 第一次：确保可以发送 0xD1 命令 2. 第二次：确保 0xD1 命令被处理，可以发送数据 3. 第三次：确保 0xDF 数据被处理完成  理论上可以去掉最后一次轮询，因为后续代码不会立即使用键盘控制器。但是： - 留着更安全，确保 A20 完全启用 - 如果后面代码依赖 A20，不等待可能导致竞态条件  保守的做法是保留所有轮询。    思考题 2 如果键盘控制器不存在或损坏，代码会怎样？   点击查看答案  可能的情况： 1. **控制器不存在**：读取 0x64 可能返回 0xFF（所有位为1），包括 IBF 位。代码会进入无限循环。  2. **控制器损坏**：取决于损坏方式。可能：    - 无限循环    - A20 启用失败    - 产生异常  3. **虚拟化环境**：虚拟机通常正确模拟 8042，或者默认启用 A20。  实际上，没有键盘控制器的系统很少见。更稳健的代码会： - 设置超时计数器 - 尝试多种 A20 启用方法 - 在失败时报告错误    思考题 3 0xDF 中哪些位是必须设置的，哪些是可选的？   点击查看答案  必须设置的位： - 位 0 = 1：防止系统复位 - 位 1 = 1：启用 A20  可能重要的位： - 位 6、7：键盘时钟和数据，应保持为 1  理论上，最小值可以是 0x03（只设置位 0 和位 1）。  但使用 0xDF（所有位为 1 除了位 5）是更安全的选择，因为： - 保持键盘正常工作 - 不改变其他可能重要的设置 - 是广泛测试过的值      下一步  A20 地址线已启用，现在我们可以访问超过 1MB 的内存了。但在切换到保护模式之前，还需要创建临时页表来支持分页。下一篇文档将介绍：临时页表创建"
  },
  
  {
    "title": "Pintos Kernel 启动详解（二）：内存大小检测",
    "url": "/posts/pintos-kernel-02-memory-detection/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, BIOS, 内存检测",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  在设置好段寄存器后，内核需要知道系统有多少物理内存。这个信息对后续的内存管理至关重要：    决定可以创建多少页表   决定可以分配多少物理页面   决定内存池的大小   由于此时仍在实模式下运行，我们可以使用 BIOS 提供的服务来获取内存信息。    原始代码  #### Get memory size, via interrupt 15h function 88h (see [IntrList]), #### which returns AX = (kB of physical memory) - 1024.  This only #### works for memory sizes &lt;= 65 MB, which should be fine for our #### purposes.  We cap memory at 64 MB because that's all we prepare #### page tables for, below.  \tmovb $0x88, %ah \tint $0x15 \taddl $1024, %eax\t# Total kB memory \tcmp $0x10000, %eax\t# Cap at 64 MB \tjbe 1f \tmov $0x10000, %eax 1:\tshrl $2, %eax\t\t# Total 4 kB pages \taddr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000     前置知识  BIOS 中断服务  BIOS（Basic Input/Output System）提供了许多通过软件中断调用的服务：                 中断号       功能类别                       INT 10h       视频服务                 INT 13h       磁盘服务                 INT 15h       系统服务（包括内存检测）                 INT 16h       键盘服务           INT 15h, AH=88h：扩展内存大小  这是一个古老但简单的内存检测方法：  输入：     AH = 88h  输出：     AX = 扩展内存大小（以 KB 为单位）          这是 1MB 以上的内存量          CF = 0 表示成功     CF = 1 表示错误   “扩展内存” 是什么？  PC 内存布局的历史包袱：      0x00000 - 0x9FFFF    常规内存 (640 KB)      ← \"基本内存\"     0xA0000 - 0xFFFFF    系统保留 (384 KB)      ← VGA、ROM 等     ─────────────────────────────────────────     0x100000 以上         扩展内存              ← INT 15h/88h 返回这部分  早期 PC 只有 1MB 内存，其中只有 640KB 可用（著名的 640KB 限制）。 后来的扩展内存需要特殊方式访问。   为什么这个方法只支持 65MB？  INT 15h/88h 返回的是 16 位值（AX 寄存器）：    最大返回值：0xFFFF = 65535   单位是 KB   65535 KB ≈ 64 MB（扩展内存）   加上 1MB 基本内存 ≈ 65 MB 总内存   对于更大的内存，需要使用更复杂的检测方法（如 INT 15h/E820h），但 Pintos 选择了简单的方法。    逐行详解  第 1 行：设置功能号  \tmovb $0x88, %ah   指令分析                 部分       含义                       movb       移动字节（8位）                 $0x88       立即数 0x88（功能号）                 %ah       AX 寄存器的高 8 位           AX 寄存器的结构         AX (16 位)     ┌─────┬─────┐     │ AH  │ AL  │     │(高8)│(低8)│     └─────┴─────┘      示例：AX = 0x1234       AH = 0x12       AL = 0x34   BIOS 中断通常使用 AH 来指定功能号，AL 或整个 AX 来传递参数或返回值。    第 2 行：调用 BIOS 中断  \tint $0x15   软件中断的工作原理  flowchart TD     A[\"执行 int $0x15\"] --&gt; B[\"CPU 保存当前状态\"]     B --&gt; C[\"查找中断向量表&lt;br/&gt;地址 = 0x15 × 4 = 0x54\"]     C --&gt; D[\"跳转到 BIOS 中断处理程序\"]     D --&gt; E[\"BIOS 检测内存\"]     E --&gt; F[\"设置 AX = 扩展内存 KB\"]     F --&gt; G[\"执行 IRET 返回\"]     G --&gt; H[\"CPU 恢复状态&lt;br/&gt;继续执行下一条指令\"]   BIOS 返回后 AX 的含义  假设系统有 32 MB RAM：  总内存 = 32 MB = 32768 KB  扩展内存 = 总内存 - 1024 KB = 31744 KB  BIOS 返回：AX = 31744 = 0x7C00     第 3 行：加上基本内存  \taddl $1024, %eax\t# Total kB memory   为什么加 1024？  BIOS 只返回 1MB 以上的内存（扩展内存）。要得到总内存，需要加上第一个 1MB：  总内存 (KB) = 扩展内存 (KB) + 1024 KB  为什么是 1024 而不是 1MB (1048576)? 因为单位已经是 KB，1MB = 1024 KB   为什么使用 addl 而不是 addw？  addl $1024, %eax    # 32 位加法，操作 EAX addw $1024, %ax     # 16 位加法，操作 AX   虽然在实模式下，但我们想要 32 位的结果以支持更大的值。 使用 EAX（32位）可以避免溢出问题。  注意：在 16 位实模式下使用 32 位操作数会自动添加操作数大小前缀（0x66）。    第 4-6 行：限制最大内存为 64MB  \tcmp $0x10000, %eax\t# Cap at 64 MB \tjbe 1f \tmov $0x10000, %eax 1:   为什么限制在 64MB？     页表大小限制：Pintos 只准备了映射 64MB 的页表   简化设计：更大的内存需要更复杂的页表管理   教学目的：64MB 对教学操作系统来说足够了   代码逻辑详解  0x10000 (十进制 65536) = 64 MB (以 KB 为单位)      64 MB = 64 × 1024 KB = 65536 KB = 0x10000 KB  代码流程：          if (EAX &gt; 0x10000) {      # cmp + jbe         EAX = 0x10000;        # mov     }     # 1: 标签   指令详解                 指令       含义                       cmp $0x10000, %eax       计算 EAX - 0x10000，设置标志位，不保存结果                 jbe 1f       Jump if Below or Equal（如果 ≤ 则跳转）1f 表示”向前找标签 1”                 mov $0x10000, %eax       将 64MB 值存入 EAX                 1:       本地标签（数字标签可以重复使用）           GAS 数字标签  1:      # 标签定义 jmp 1f  # 向前（forward）跳转到下一个 1: jmp 1b  # 向后（backward）跳转到上一个 1:     第 7 行：转换为页数  \tshrl $2, %eax\t\t# Total 4 kB pages   为什么右移 2 位？  EAX 当前值 = 总内存 (KB)  要得到 4KB 页面的数量：     页数 = 总内存 (KB) ÷ 4  ÷ 4 等价于右移 2 位：     EAX &gt;&gt; 2 = EAX ÷ 4  示例：     32 MB = 32768 KB     页数 = 32768 ÷ 4 = 8192 页          二进制: 0x8000 &gt;&gt; 2 = 0x2000     十进制: 32768 &gt;&gt; 2 = 8192 ✓   为什么页面大小是 4KB？  4KB (4096 字节) 是 x86 分页的标准页面大小。这个大小是硬件决定的：    页表项使用 10 位索引   页内偏移使用 12 位   2^12 = 4096 = 4KB     第 8 行：存储结果  \taddr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000   这是最复杂的一行，让我们拆解它。  目标变量 init_ram_pages  在 start.S 末尾定义了这个变量：  .globl init_ram_pages init_ram_pages: \t.long 0   这是一个全局变量，后面 C 代码会用它来知道有多少物理内存页。  地址计算的问题  问题在于 init_ram_pages 的地址是链接时的虚拟地址，而我们现在运行在实模式下需要物理地址。  链接器设置：     init_ram_pages 的虚拟地址 = LOADER_PHYS_BASE + 0x20000 + 偏移                               = 0xC0000000 + 0x20000 + 偏移      实际物理位置：     内核加载在 0x20000     所以 init_ram_pages 的物理地址 = 0x20000 + 偏移  要得到相对于内核起始的偏移：     偏移 = 虚拟地址 - LOADER_PHYS_BASE - 0x20000   示意图  虚拟地址空间（链接时）：          0xC0020000 ┌─────────────────────┐  ← 内核虚拟起始                │    .start 段        │                │    start:           │                │    ...              │                │    init_ram_pages   │  ← 假设这里是 0xC0020XXX                └─────────────────────┘  物理地址空间（实际运行）：      0x00020000 ┌─────────────────────┐  ← 内核物理起始                │    .start 段        │                │    start:           │                │    ...              │                │    init_ram_pages   │  ← 物理地址 0x00020XXX                └─────────────────────┘  转换公式：     物理地址 = 虚拟地址 - LOADER_PHYS_BASE      相对于内核起始的偏移：     偏移 = 虚拟地址 - LOADER_PHYS_BASE - 0x20000   addr32 前缀  addr32 movl %eax, ...   在 16 位实模式下，默认地址大小是 16 位。addr32 前缀告诉 CPU 使用 32 位地址计算。  这是必要的，因为：    目标地址计算可能超过 16 位   我们需要访问内核数据区   最终效果  执行后，init_ram_pages 变量被设置为系统的物理页面数。  // 在 C 代码中可以这样使用： extern uint32_t init_ram_pages;  printf(\"System has %u pages of RAM (%u MB)\\n\",         init_ram_pages,         init_ram_pages * 4 / 1024);     完整流程图  flowchart TD     A[\"movb $0x88, %ah&lt;br/&gt;设置功能号\"] --&gt; B[\"int $0x15&lt;br/&gt;调用 BIOS\"]     B --&gt; C[\"AX = 扩展内存 KB\"]     C --&gt; D[\"addl $1024, %eax&lt;br/&gt;加上 1MB\"]     D --&gt; E{\"EAX &gt; 64MB?\"}     E --&gt;|是| F[\"mov $0x10000, %eax&lt;br/&gt;限制为 64MB\"]     E --&gt;|否| G[\"shrl $2, %eax&lt;br/&gt;转换为页数\"]     F --&gt; G     G --&gt; H[\"存储到 init_ram_pages\"]          style A fill:#f9f,stroke:#333     style H fill:#9f9,stroke:#333     数值示例  让我们用具体数字走一遍流程：  示例 1：32MB 系统  初始：系统有 32 MB 物理内存  1. int $0x15 返回：    AX = 32768 - 1024 = 31744 KB  2. addl $1024, %eax：    EAX = 31744 + 1024 = 32768 KB  3. cmp $0x10000, %eax：    32768 &lt; 65536，不跳转  4. 等等...32768 &lt; 65536 应该跳转！    让我重新计算...        32768 KB = 32 MB    65536 KB = 64 MB    32 MB &lt; 64 MB ✓    所以会跳过 mov $0x10000, %eax  5. shrl $2, %eax：    EAX = 32768 &gt;&gt; 2 = 8192 页  结果：init_ram_pages = 8192   示例 2：128MB 系统  初始：系统有 128 MB 物理内存  1. int $0x15 返回：    但是！INT 15h/88h 最多只能返回 65535...        128 MB - 1 MB = 127 MB = 130048 KB    这超过了 16 位最大值 65535！        BIOS 可能返回 65535（饱和值）  2. addl $1024, %eax：    EAX = 65535 + 1024 = 66559 KB  3. cmp $0x10000, %eax：    66559 &gt; 65536，不跳转  4. mov $0x10000, %eax：    EAX = 65536 KB (64 MB)  5. shrl $2, %eax：    EAX = 65536 &gt;&gt; 2 = 16384 页  结果：init_ram_pages = 16384（被限制在 64MB）     为什么不用更现代的内存检测？  INT 15h/E820h 是更现代的内存检测方法，它可以：    检测任意大小的内存   报告内存区域的类型（可用、保留、ACPI等）   处理内存空洞   但 Pintos 选择 INT 15h/88h 因为：     简单：一条中断调用，一个返回值   足够：64MB 对教学目的已经足够   可靠：这个方法在所有 x86 系统上都支持   代码短：引导代码空间宝贵     常见问题  Q1: 如果系统内存小于 1MB 会怎样？  A: 在现代系统中不太可能发生。但如果发生：    BIOS 可能返回 0 或错误   代码会计算出很小的页数   系统可能无法正常运行   Q2: 为什么使用 KB 而不是字节作为单位？  A: 历史原因。这个 BIOS 接口是为早期 PC 设计的，当时 KB 是合适的单位。如果用字节，16 位寄存器只能表示 64KB。  Q3: 内存大小信息后面怎么使用？  A: 在 init.c 的 pintos_init() 中：  printf (\"Pintos booting with %'\"PRIu32\" kB RAM...\\n\",         init_ram_pages * PGSIZE / 1024);  // 用于初始化物理页面分配器 palloc_init (user_page_limit);   Q4: 为什么要在实模式下获取内存大小？  A: 因为 BIOS 服务只能在实模式下使用。一旦切换到保护模式，就不能再调用 BIOS 了。    其他内存检测方法  供参考，这是更复杂但更强大的 E820 方法：  # INT 15h/E820h - 获取系统内存映射 # 输入: #   EAX = 0xE820 #   EBX = 继续值（第一次调用为 0） #   ECX = 缓冲区大小 #   EDX = 签名 'SMAP' (0x534D4150) #   ES:DI = 缓冲区指针 # 输出: #   EAX = 'SMAP' #   EBX = 下一次调用的继续值（0 表示结束） #   ECX = 实际写入字节数 #   缓冲区包含内存区域描述符   这个方法可以完整描述系统的内存布局，包括哪些区域可用、哪些被保留。    练习思考  思考题 1 如果我们不限制内存在 64MB，需要做哪些额外的工作？   点击查看答案  需要做的工作包括： 1. **更多页表**：每 4MB 需要一个页表（1024 × 4KB = 4MB），64MB 以上需要更多页表 2. **更大的页目录**：可能需要多级页表 3. **修改临时页表创建代码**：当前代码只创建映射 64MB 的页表 4. **可能需要更多的栈空间**：页表创建需要更多内存访问  简单地提高上限不够，还需要相应增加后面创建的页表数量。    思考题 2 为什么 addl $1024, %eax 而不是 addw $1024, %ax？   点击查看答案  虽然 BIOS 返回的值在 AX 中（16位），但我们想要处理完整的 32 位值：  1. 加上 1024 后可能超过 16 位最大值 65535 2. 后面的比较和右移操作需要 32 位精度 3. 使用 EAX 可以避免溢出和符号扩展问题  例如：如果 BIOS 返回 65535，加上 1024 得到 66559，这超过了 16 位范围。    思考题 3 init_ram_pages 的地址计算 init_ram_pages - LOADER_PHYS_BASE - 0x20000 如果计算错误会发生什么？   点击查看答案  后果很严重：  1. 如果写入地址太低（如中断向量表区域）：    - 可能覆盖 BIOS 数据    - 后续的 BIOS 调用可能失败  2. 如果写入地址在内核代码区域：    - 可能覆盖内核指令    - 导致系统崩溃或不可预测的行为  3. 如果写入地址太高：    - 可能写入不存在的内存    - 在某些系统上可能被忽略，在其他系统上可能出错  这就是为什么这行代码需要非常精确的地址计算。      下一步  现在我们知道了系统有多少内存，但还有一个问题：历史遗留的 A20 地址线问题限制了我们只能访问 1MB 内存。下一篇文档将介绍如何启用 A20 地址线：A20 地址线启用"
  },
  
  {
    "title": "Pintos Kernel 启动详解（一）：start.S 概述与段寄存器设置",
    "url": "/posts/pintos-kernel-01-start-overview/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, x86, 实模式",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  当 Loader 完成内核加载后，它会跳转到内核的入口点 start。这个入口点位于 start.S 文件中，是内核的第一段代码。  start.S 的主要任务是：    初始化段寄存器   获取系统内存大小   启用 A20 地址线   创建临时页表   切换到保护模式   启用分页   跳转到 C 语言的 pintos_init() 函数   本文档详细介绍文件的开头部分和段寄存器的初始化。    原始代码  #include \"threads/loader.h\"  #### Kernel startup code.  #### The loader (in loader.S) loads the kernel at physical address #### 0x20000 (128 kB) and jumps to \"start\", defined here.  This code #### switches from real mode to 32-bit protected mode and calls #### pintos_init().  /* Flags in control register 0. */ #define CR0_PE 0x00000001      /* Protection Enable. */ #define CR0_EM 0x00000004      /* (Floating-point) Emulation. */ #define CR0_PG 0x80000000      /* Paging. */ #define CR0_WP 0x00010000      /* Write-Protect enable in kernel mode. */  \t.section .start  # The following code runs in real mode, which is a 16-bit code segment. \t.code16  .func start .globl start start:  # The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000, # but we should initialize the other segment registers.  \tmov $0x2000, %ax \tmov %ax, %ds \tmov %ax, %es  # Set string instructions to go upward. \tcld     前置知识  Loader 完成后的状态  当 Loader 跳转到 start 时，系统处于以下状态：  ┌─────────────────────────────────────────────────────────────────┐ │                    Loader 跳转后的 CPU 状态                       │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  CPU 模式: 16 位实模式                                           │ │                                                                  │ │  段寄存器:                                                       │ │    CS = 0x2000  (代码段，由远跳转设置)                            │ │    SS = 0x0000  (栈段)                                           │ │    DS = ?       (数据段，未初始化)                                │ │    ES = ?       (附加段，未初始化)                                │ │                                                                  │ │  栈指针:                                                         │ │    ESP = 0xF000  (栈顶在 60KB 处)                                │ │                                                                  │ │  当前执行地址:                                                   │ │    CS:IP = 0x2000:0000                                           │ │    物理地址 = 0x2000 × 16 + 0 = 0x20000 (128KB)                  │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘   内核在内存中的位置  内存布局 (实模式视角):      0x00000 ┌─────────────────────┐             │    中断向量表        │ 1 KB     0x00400 ├─────────────────────┤             │    BIOS 数据区       │     0x00500 ├─────────────────────┤             │                     │             │    可用内存          │             │                     │     0x07C00 ├─────────────────────┤             │    Loader 代码       │ 512 字节     0x07E00 ├─────────────────────┤             │                     │             │    可用内存          │             │                     │     0x0F000 ├─────────────────────┤             │    栈空间 ↓         │ 向下增长             │    （栈顶在此）       │     0x20000 ├─────────────────────┤  ← 内核加载位置！             │                     │             │    Pintos 内核       │             │    start.S 在这里    │             │                     │             └─────────────────────┘   为什么内核加载到 0x20000？  选择 128KB (0x20000) 作为内核加载位置的原因：     避开低端内存：低端内存包含中断向量表和 BIOS 数据   足够的栈空间：在内核之前有足够的空间给栈使用   对齐考虑：128KB 是一个整齐的地址   避开 BIOS 保留区域：某些 BIOS 在特定区域存放临时数据     逐行详解  第 1 行：包含头文件  #include \"threads/loader.h\"   这是什么？  这是 C 预处理器指令（不是汇编指令），用于包含头文件。在汇编之前，预处理器会将 loader.h 的内容插入到这里。  loader.h 中定义了什么？  /* 来自 loader.h 的重要定义 */  #define LOADER_BASE 0x7c00      /* Loader 的物理地址 */ #define LOADER_END  0x7e00      /* Loader 结束地址 */  #define LOADER_KERN_BASE 0x20000       /* 内核加载地址 (128 kB) */ #define LOADER_PHYS_BASE 0xc0000000    /* 内核虚拟地址基址 (3 GB) */  /* GDT 选择子 */ #define SEL_NULL        0x00    /* 空选择子 */ #define SEL_KCSEG       0x08    /* 内核代码段选择子 */ #define SEL_KDSEG       0x10    /* 内核数据段选择子 */   为什么汇编文件可以用 #include？  因为 GCC 工具链会先用 C 预处理器处理 .S 文件（注意大写的 S），然后再传给汇编器。小写的 .s 文件则不会经过预处理。    第 2-9 行：注释和 CR0 常量定义  #### Kernel startup code.  #### The loader (in loader.S) loads the kernel at physical address #### 0x20000 (128 kB) and jumps to \"start\", defined here.  This code #### switches from real mode to 32-bit protected mode and calls #### pintos_init().  /* Flags in control register 0. */ #define CR0_PE 0x00000001      /* Protection Enable. */ #define CR0_EM 0x00000004      /* (Floating-point) Emulation. */ #define CR0_PG 0x80000000      /* Paging. */ #define CR0_WP 0x00010000      /* Write-Protect enable in kernel mode. */   CR0 寄存器是什么？  CR0 是 x86 的第一个控制寄存器（Control Register 0），它包含控制 CPU 操作模式的重要标志位：  CR0 寄存器结构（32位）:   31 30 29 28 ... 18 17 16 15 ... 5  4  3  2  1  0 ┌──┬──┬──┬──────────┬──┬──────────┬──┬──┬──┬──┬──┐ │PG│CD│NW│ Reserved │WP│ Reserved │NE│ET│TS│EM│MP│PE│ └──┴──┴──┴──────────┴──┴──────────┴──┴──┴──┴──┴──┘                  位       名称       含义                       PE (0)       Protection Enable       1 = 启用保护模式                 EM (2)       Emulation       1 = 浮点指令会产生异常                 WP (16)       Write Protect       1 = 内核也遵守页面写保护                 PG (31)       Paging       1 = 启用分页             第 10 行：段定义  \t.section .start   这是什么？  这是一个汇编器指令，告诉汇编器将接下来的代码放入名为 .start 的段（section）中。  为什么需要单独的 .start 段？  在链接时，链接器脚本 (kernel.lds.S) 会确保 .start 段被放在内核的最开始位置：  /* 来自 kernel.lds.S 的片段 */ SECTIONS {     . = LOADER_PHYS_BASE + LOADER_KERN_BASE;          _start = .;          .start : {         *(.start)       /* start.S 的代码放在这里 */     }          .text : {         *(.text)        /* 其他代码 */     }     ... }   这确保了 Loader 跳转到 0x20000 时，执行的就是 start 函数。    第 11-12 行：指定 16 位代码  # The following code runs in real mode, which is a 16-bit code segment. \t.code16   为什么需要 .code16？  CPU 启动时处于 16 位实模式。如果我们不告诉汇编器，它可能会生成 32 位指令，导致 CPU 错误解释代码。  例子：mov 指令的区别  同一条指令在不同模式下的机器码：  指令: mov $0x2000, %ax  16 位模式: B8 00 20        (3 字节) 32 位模式: 66 B8 00 20     (4 字节，有 66 前缀)  如果在 16 位模式下执行 32 位编码，CPU 会错误地解释后面的字节！     第 13-16 行：函数声明  .func start .globl start start:   .func start  这是 GAS（GNU 汇编器）的调试指令，标记函数的开始。它帮助调试器（如 GDB）识别函数边界。  .globl start  将 start 符号声明为全局可见，这样：    其他文件可以引用这个符号   链接器可以看到它   Loader 可以跳转到它   start:  这是 start 函数的标签（入口点）。当 Loader 执行跳转指令后，CPU 会从这里开始执行。    第 17-21 行：初始化数据段寄存器  # The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000, # but we should initialize the other segment registers.  \tmov $0x2000, %ax \tmov %ax, %ds \tmov %ax, %es   Loader 留下的状态  注释说明了 Loader 跳转时的寄存器状态：    CS = 0x2000：代码段，由 Loader 的远跳转设置   SS = 0x0000：栈段，Loader 之前设置的   ESP = 0xF000：栈指针，指向 60KB   DS 和 ES：未初始化！   为什么要设置 DS 和 ES 为 0x2000？  内存访问时的地址计算：  当代码访问数据时（如 mov (%bx), %ax），CPU 使用 DS:     物理地址 = DS × 16 + 偏移  如果 DS = 0x2000：     物理地址 = 0x2000 × 16 + 偏移 = 0x20000 + 偏移  这意味着偏移量 0 指向内核开始处， 与代码段 CS = 0x2000 一致！   为什么不能直接 mov $0x2000, %ds？  x86 不允许将立即数直接移动到段寄存器。必须先通过通用寄存器中转：  # 错误！不允许 mov $0x2000, %ds  # 正确：通过 AX 中转 mov $0x2000, %ax mov %ax, %ds   设置后的状态图  设置前：                           设置后： ┌─────────────────────┐           ┌─────────────────────┐ │  CS = 0x2000  ✓     │           │  CS = 0x2000  ✓     │ │  SS = 0x0000  ✓     │           │  SS = 0x0000  ✓     │ │  DS = ????    ✗     │    →      │  DS = 0x2000  ✓     │ │  ES = ????    ✗     │           │  ES = 0x2000  ✓     │ │  ESP = 0xF000 ✓     │           │  ESP = 0xF000 ✓     │ └─────────────────────┘           └─────────────────────┘  现在所有数据访问都会正确指向内核所在的内存区域     第 22-23 行：设置字符串方向  # Set string instructions to go upward. \tcld   cld 指令是什么？  CLD = CLear Direction flag（清除方向标志）  它清除 FLAGS 寄存器中的 DF（Direction Flag）位。  DF 标志的作用  DF 控制字符串指令（如 rep movsb, rep stosb）的方向：                 DF 值       方向       效果                       0 (CLD)       向上（递增）       SI/DI 每次操作后加 1                 1 (STD)       向下（递减）       SI/DI 每次操作后减 1           为什么要清除 DF？  示例：rep stosl 填充内存  假设：ES:DI = 目标地址, ECX = 次数, EAX = 要填充的值  如果 DF = 0（清除）:     内存地址:  [0] [1] [2] [3] [4] ...     填充顺序:   ①   ②   ③   ④   ⑤     (从低地址到高地址)  如果 DF = 1（设置）:     内存地址:  ... [4] [3] [2] [1] [0]     填充顺序:       ⑤   ④   ③   ②   ①     (从高地址到低地址)   后面的代码会用 rep stosl 来清零页表，需要确保方向是向上的。  BIOS 不保证 DF 的值  BIOS 可能会以任意状态离开 DF 标志，所以我们必须显式设置它。这是一个良好的编程习惯。    内存映射详解  在这个阶段，内存布局如下：  ┌─────────────────────────────────────────────────────────────────┐ │                      实模式内存布局                               │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  物理地址          内容                段:偏移 表示               │ │  ─────────────────────────────────────────────────────────────  │ │                                                                  │ │  0x00000-0x003FF   中断向量表           0000:0000 - 0000:03FF    │ │  0x00400-0x004FF   BIOS 数据区          0000:0400 - 0000:04FF    │ │  0x00500-0x07BFF   可用内存             0000:0500 - 0000:7BFF    │ │  0x07C00-0x07DFF   Loader (512字节)     0000:7C00 - 0000:7DFF    │ │  0x07E00-0x0EFFF   可用内存             0000:7E00 - 0000:EFFF    │ │                    ↑                                             │ │                    栈向下增长                                     │ │  0x0F000           栈顶 (ESP)           0000:F000                │ │  0x0F000-0x0FFFF   将用作临时页目录      0F00:0000 - 0F00:0FFF   │ │  0x10000-0x1FFFF   将用作临时页表        1000:0000 - ...         │ │                                                                  │ │  0x20000           内核入口点 (start)   2000:0000                │ │  0x20000-...       Pintos 内核代码      2000:0000 - ...         │ │                                                                  │ │  ...                                                             │ │                                                                  │ │  0xA0000-0xBFFFF   VGA 显存              A000:0000 - ...         │ │  0xC0000-0xFFFFF   BIOS ROM 区域         C000:0000 - ...         │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘     执行流程图  flowchart TD     A[\"Loader 远跳转到 0x2000:0000\"] --&gt; B[\"start: 标签\"]     B --&gt; C[\"mov $0x2000, %ax\"]     C --&gt; D[\"mov %ax, %ds&lt;br/&gt;设置数据段\"]     D --&gt; E[\"mov %ax, %es&lt;br/&gt;设置附加段\"]     E --&gt; F[\"cld&lt;br/&gt;清除方向标志\"]     F --&gt; G[\"继续执行：&lt;br/&gt;获取内存大小\"]          style A fill:#f9f,stroke:#333     style G fill:#9f9,stroke:#333     常见问题  Q1: 为什么 Loader 不设置好所有段寄存器？  A: 主要有两个原因：     空间限制：Loader 只有 512 字节，每条指令都很宝贵   职责分离：Loader 的任务是加载内核并跳转，不需要关心内核的运行环境   Q2: ES 段寄存器什么时候会用到？  A: ES 主要用于字符串操作的目标地址：  # movsb: 从 DS:SI 复制到 ES:DI rep movsb  # stosb: 将 AL 存储到 ES:DI rep stosb   后面创建页表时会大量使用 rep stosl。  Q3: 为什么不设置 FS 和 GS？  A: 在 16 位实模式下，FS 和 GS 段寄存器很少使用。代码只用到 DS（数据访问）和 ES（字符串操作目标），所以不需要设置其他段寄存器。  Q4: 如果忘记设置 DS 会怎样？  A: 后果不可预测！DS 可能包含任意值：  假设 DS 碰巧是 0x1234:          当代码尝试读取内核中的数据时：     物理地址 = 0x1234 × 16 + 偏移 = 0x12340 + 偏移          这会读取完全错误的内存位置！     最好情况：读到垃圾数据     最坏情况：系统崩溃     练习思考  思考题 1 如果将 DS 设置为 0 而不是 0x2000，会发生什么？代码还能正常工作吗？   点击查看答案  如果 DS = 0，那么数据访问的物理地址计算会是： ``` 物理地址 = 0 × 16 + 偏移 = 偏移 ```  这意味着偏移 0x1000 会指向物理地址 0x1000，而不是内核中的数据。  内核数据实际在 0x20000 开始的地方，所以访问会指向完全错误的位置（可能是中断向量表或 BIOS 数据），导致系统行为异常。    思考题 2 为什么栈指针 ESP 被设置为 0xF000（60KB）而不是更高的地址？   点击查看答案  几个原因： 1. 0xF000 在内核（0x20000）之前，给栈留出足够空间 2. 0xF000-0xFFFF 区域后面会被用作临时页目录 3. 栈向下增长，从 0xF000 开始可以使用 0x0500 到 0xF000 的空间（约 58KB） 4. 避开低端内存中的中断向量表和 BIOS 数据    思考题 3 如果在一个已经运行的系统中执行 std（设置方向标志），会有什么影响？   点击查看答案  设置 DF 后，所有字符串操作会从高地址向低地址进行。这会导致：  1. 标准库函数（如 `memcpy`、`memset`）可能出错 2. 缓冲区操作方向相反 3. 如果代码假设 DF=0，会产生难以调试的 bug  这就是为什么 x86 调用约定规定：**进入函数时 DF 必须为 0**。 每个函数如果修改了 DF，必须在返回前恢复它。      下一步  段寄存器设置完成后，内核需要知道系统有多少内存。下一篇文档将介绍如何使用 BIOS 中断来获取内存大小：内存大小检测"
  },
  
  {
    "title": "Pintos Kernel 启动详解（零）：系列概述",
    "url": "/posts/pintos-kernel-00-overview/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 内核, x86",
    "date": "2026-01-22 00:00:00 +0800",
    "content": "概述  这是一个针对 Pintos 操作系统内核启动代码的详细分析文档系列，力求用简单易懂的方式解释每一个概念和代码片段。  本系列是 Loader 系列的延续——Loader 将内核加载到内存后，跳转到内核的入口点 start（位于 start.S），接着内核开始自己的初始化过程，最终调用 C 语言编写的 pintos_init() 函数。    从 Loader 到 Kernel 的过渡  ┌─────────────────────────────────────────────────────────────────┐ │                        引导过程流程                               │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │   BIOS                                                          │ │     │                                                            │ │     ▼                                                            │ │   loader.S (0x7C00)     ← 实模式 (16-bit)                        │ │     │ 加载内核到 0x20000                                          │ │     │ 跳转到 start                                               │ │     ▼                                                            │ │   start.S (0x20000)     ← 实模式 → 保护模式 (32-bit)              │ │     │ 获取内存大小                                               │ │     │ 启用 A20 地址线                                            │ │     │ 设置临时页表                                               │ │     │ 切换到保护模式                                              │ │     │ 启用分页                                                   │ │     │ 调用 pintos_init()                                         │ │     ▼                                                            │ │   init.c:pintos_init()  ← C 语言内核主函数                        │ │     │ 初始化 BSS 段                                              │ │     │ 解析命令行参数                                              │ │     │ 初始化线程系统                                              │ │     │ 初始化内存系统                                              │ │     │ 初始化中断系统                                              │ │     │ 启动调度器                                                 │ │     │ 执行用户任务                                               │ │     ▼                                                            │ │   正常运行...                                                    │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘     文档列表  本系列包含以下文档：  Part 1: start.S 汇编启动代码                 序号       主题       简介                       1       start.S 概述与初始段寄存器设置       内核入口点和基本环境设置                 2       内存大小检测       使用 BIOS 中断获取物理内存大小                 3       A20 地址线启用       解决历史遗留的 1MB 内存限制                 4       临时页表创建       创建页目录和页表实现虚拟内存映射                 5       保护模式切换       从 16 位实模式切换到 32 位保护模式                 6       GDT 全局描述符表       GDT 的结构和作用详解           Part 2: init.c 内核初始化                 序号       主题       简介                       7       pintos_init 主函数       内核 C 语言入口和初始化流程                 8       BSS 段初始化       清零未初始化的全局变量区域                 9       命令行解析       读取和解析内核启动参数                 10       内存系统初始化       palloc 和 malloc 内存分配器初始化                 11       永久页表建立       替换临时页表建立完整的虚拟内存映射                 12       线程系统初始化       初始化线程调度器和主线程                 13       中断系统初始化       IDT、PIC 和中断处理框架                 14       设备初始化       定时器、键盘、串口等设备初始化                 15       启动完成与任务执行       启动调度器并执行用户指定的任务             阅读顺序  建议按照文档编号顺序阅读，因为：     文档按执行顺序组织：代码是按顺序执行的，文档也按这个顺序排列   概念层层递进：后面的文档会引用前面介绍的概念   从汇编到 C：先理解底层汇编代码，再学习 C 语言初始化   如果你已经阅读过 Loader 系列，可以直接从本系列开始。如果没有，建议先阅读 Loader 系列了解引导过程。    每个文档的结构  每个文档都包含以下部分：     概述：本部分代码的作用和重要性   原始代码：完整的源代码   前置知识：理解代码所需的背景知识   逐行详解：每一行代码的详细解释   图解/流程图：可视化的执行过程和数据结构   常见问题：FAQ 解答常见疑惑   练习思考：帮助加深理解的思考题     先决知识  阅读这些文档前，最好了解：  必须了解    Loader 系列文档：了解引导过程和实模式基础   C 语言基础：函数、指针、结构体   十六进制：内存地址的表示   基本计算机概念    内存和 CPU 的关系   程序如何执行   堆栈的概念   可选但有帮助    x86 汇编语言基础   虚拟内存的基本概念   操作系统原理     核心概念速览  实模式 vs 保护模式                 特性       实模式       保护模式                       位宽       16 位       32 位                 最大内存       1 MB       4 GB                 内存保护       无       有                 多任务支持       无       有                 地址模型       段:偏移       线性地址 + 分页           关键内存地址                 地址       内容                       0x7C00       Loader 加载位置                 0x20000 (128KB)       内核加载位置                 0xC0000000 (3GB)       内核虚拟地址基址                 0xF000 (60KB)       初始栈顶/临时页目录           关键寄存器                 寄存器       用途                       CR0       控制寄存器，包含 PE（保护模式）、PG（分页）位                 CR3       页目录基址寄存器                 GDTR       全局描述符表寄存器                 IDTR       中断描述符表寄存器             术语表                 术语       解释                       GDT       全局描述符表，定义内存段                 IDT       中断描述符表，定义中断处理程序                 PDE       页目录项                 PTE       页表项                 A20       地址线 20，启用后可访问超过 1MB 的内存                 BSS       未初始化数据段，程序启动时需要清零                 PIC       可编程中断控制器                 TSS       任务状态段             相关文件  汇编文件    src/threads/start.S - 内核汇编入口点   src/threads/intr-stubs.S - 中断桩代码   C 源文件    src/threads/init.c - 内核主初始化函数   src/threads/thread.c - 线程管理   src/threads/interrupt.c - 中断处理   src/threads/palloc.c - 页面分配器   src/threads/malloc.c - 内核内存分配器   头文件    src/threads/loader.h - 引导相关常量   src/threads/thread.h - 线程结构定义   src/threads/vaddr.h - 虚拟地址操作宏   src/threads/pte.h - 页表项操作宏     学习建议     边读边画：画出内存布局和执行流程图   对照代码：打开源文件对照阅读   动手调试：使用 GDB 单步执行，观察寄存器和内存变化   做笔记：记录自己的理解和疑问   多问为什么：理解每行代码存在的原因     调试技巧  使用 GDB 调试内核启动  # 在 Pintos 目录下 pintos --gdb -- run &lt;test&gt;  # 在另一个终端 pintos-gdb kernel.o (gdb) target remote localhost:1234 (gdb) break start (gdb) continue   有用的 GDB 命令  # 查看寄存器 info registers  # 查看内存 x/10x 0x20000  # 查看页表 monitor info pg  # 单步执行 stepi     下一步  准备好了吗？让我们开始第一篇文档：start.S 概述与初始段寄存器设置！"
  },
  
  {
    "title": "Pintos Loader.S 详解（十）：数据结构定义",
    "url": "/posts/pintos-loader-10-data-structures/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  loader.S 的末尾定义了一些重要的数据结构，包括命令行参数区域、分区表区域和引导签名。这些结构使 512 字节的引导扇区符合 BIOS 规范，并允许外部工具（如 pintos 命令）与引导加载程序通信。    原始代码  #### Command-line arguments and their count. #### This is written by the `pintos' utility and read by the kernel. #### The loader itself does not do anything with the command line. \t.org LOADER_ARG_CNT - LOADER_BASE \t.fill LOADER_ARG_CNT_LEN, 1, 0  \t.org LOADER_ARGS - LOADER_BASE \t.fill LOADER_ARGS_LEN, 1, 0  #### Partition table. \t.org LOADER_PARTS - LOADER_BASE \t.fill LOADER_PARTS_LEN, 1, 0  #### Boot-sector signature for BIOS inspection. \t.org LOADER_SIG - LOADER_BASE \t.word 0xaa55     前置知识  .org 指令  .org 是汇编器指令，用于设置位置计数器（location counter）。  .org 100        # 从偏移 100 开始放置后续代码/数据   如果当前位置小于指定值，汇编器会填充字节（默认是 0）。  .fill 指令  .fill 用于填充指定数量的字节。  .fill count, size, value # count: 重复次数 # size: 每次填充的字节数 # value: 填充的值   例如： .fill 10, 1, 0    # 填充 10 个字节，每个都是 0 .fill 5, 2, 0xFF  # 填充 5 个双字节，每个都是 0x00FF   loader.h 中的常量  #define LOADER_BASE 0x7c00      // 加载器基地址 #define LOADER_END  0x7e00      // 加载器结束地址 (0x7c00 + 512)  #define LOADER_SIG_LEN 2        // 签名长度 #define LOADER_PARTS_LEN 64     // 分区表长度 #define LOADER_ARGS_LEN 128     // 命令行参数长度 #define LOADER_ARG_CNT_LEN 4    // 参数计数长度  // 计算各部分地址 #define LOADER_SIG (LOADER_END - LOADER_SIG_LEN)           // 0x7dfe #define LOADER_PARTS (LOADER_SIG - LOADER_PARTS_LEN)       // 0x7dbe #define LOADER_ARGS (LOADER_PARTS - LOADER_ARGS_LEN)       // 0x7d3e #define LOADER_ARG_CNT (LOADER_ARGS - LOADER_ARG_CNT_LEN)  // 0x7d3a     引导扇区布局  偏移      地址        大小    内容 ────────────────────────────────────────────────────── 0x000    0x7c00      314    引导代码                             (实际大小可能不同) ...      ...         ...    (未使用空间) 0x1ba    0x7d3a      4      命令行参数数量 0x1be    0x7d3e      128    命令行参数字符串 0x23e    0x7dbe      64     分区表 (4 × 16 字节) 0x27e    0x7dfe      2      引导签名 (0xAA55) ──────────────────────────────────────────────────────                      512    总计   图形表示：      0x7c00                                           0x7e00     ┌────────────────────────────────────────────────┐     │                                                │     │              引导代码                           │     │           (约 314 字节)                         │     │                                                │     ├────────────────────────────────────────────────┤ 0x7d3a     │         命令行参数数量 (4 字节)                 │     ├────────────────────────────────────────────────┤ 0x7d3e     │                                                │     │          命令行参数 (128 字节)                  │     │                                                │     ├────────────────────────────────────────────────┤ 0x7dbe     │  分区表项 1 (16 字节)                          │     ├────────────────────────────────────────────────┤     │  分区表项 2 (16 字节)                          │     ├────────────────────────────────────────────────┤     │  分区表项 3 (16 字节)                          │     ├────────────────────────────────────────────────┤     │  分区表项 4 (16 字节)                          │     ├────────────────────────────────────────────────┤ 0x7dfe     │    引导签名 0xAA55 (2 字节)                    │     └────────────────────────────────────────────────┘ 0x7e00     逐部分详解  第一部分：命令行参数数量  \t.org LOADER_ARG_CNT - LOADER_BASE \t.fill LOADER_ARG_CNT_LEN, 1, 0   计算：    LOADER_ARG_CNT = 0x7d3a   LOADER_BASE = 0x7c00   偏移 = 0x7d3a - 0x7c00 = 0x13a = 314   作用：    存储命令行参数的数量（32 位整数）   由 pintos 工具写入   内核在启动时读取   示例： 如果命令行是: pintos -- run alarm-multiple 参数数量 = 3 (\"run\", \"alarm-multiple\", 可能还有其他)     第二部分：命令行参数字符串  \t.org LOADER_ARGS - LOADER_BASE \t.fill LOADER_ARGS_LEN, 1, 0   计算：    LOADER_ARGS = 0x7d3e   偏移 = 0x7d3e - 0x7c00 = 0x13e = 318   作用：    存储命令行参数字符串（最多 128 字节）   格式：null 分隔的字符串序列   示例： \"run\\0alarm-multiple\\0-q\\0\"  内存布局: 0x7d3e: 'r' 'u' 'n' '\\0' 'a' 'l' 'a' 'r' 'm' '-' ...   限制：    最大 128 字节   超出部分会被截断     第三部分：分区表  \t.org LOADER_PARTS - LOADER_BASE \t.fill LOADER_PARTS_LEN, 1, 0   计算：    LOADER_PARTS = 0x7dbe   偏移 = 0x7dbe - 0x7c00 = 0x1be = 446   这是标准 MBR 分区表的位置！  分区表结构：                 偏移       大小       内容                       446       16       分区表项 1                 462       16       分区表项 2                 478       16       分区表项 3                 494       16       分区表项 4           每个分区表项：                 偏移       大小       内容                       0       1       启动标志                 1       3       CHS 起始                 4       1       分区类型                 5       3       CHS 结束                 8       4       LBA 起始                 12       4       扇区总数           为什么用 .fill 而不是真实数据？     分区表由磁盘工具（如 fdisk）写入   引导加载程序只需要预留空间   .fill 64, 1, 0 初始化为全零（无分区）     第四部分：引导签名  \t.org LOADER_SIG - LOADER_BASE \t.word 0xaa55   计算：    LOADER_SIG = 0x7dfe   偏移 = 0x7dfe - 0x7c00 = 0x1fe = 510   这是最关键的！  0xAA55 签名的意义：  位置 510: 0x55 位置 511: 0xAA  作为 16 位字（小端序）读取: 0xAA55   BIOS 在加载引导扇区后检查这个签名：    如果是 0xAA55：有效的引导扇区，跳转执行   如果不是：无效，尝试其他启动设备   历史背景：  这个签名从 IBM PC 时代就开始使用（1981年），沿用至今。    工作流程  磁盘镜像创建  flowchart LR     A[\"编译 loader.S\"] --&gt; B[\"loader.o\"]     B --&gt; C[\"loader.bin&lt;br/&gt;(512 字节)\"]     C --&gt; D[\"创建磁盘镜像\"]     D --&gt; E[\"pintos 工具&lt;br/&gt;写入命令行参数\"]     E --&gt; F[\"磁盘工具&lt;br/&gt;写入分区表\"]   引导过程  flowchart TD     A[\"BIOS 加载扇区 0&lt;br/&gt;到 0x7c00\"] --&gt; B[\"BIOS 检查 0x7dfe&lt;br/&gt;处的签名\"]     B --&gt; C{签名是 0xAA55?}     C --&gt;|是| D[\"跳转到 0x7c00\"]     C --&gt;|否| E[\"尝试其他启动设备\"]     D --&gt; F[\"引导代码读取&lt;br/&gt;分区表 (0x7dbe)\"]     F --&gt; G[\"找到 Pintos 分区\"]     G --&gt; H[\"加载内核\"]     H --&gt; I[\"内核读取命令行参数&lt;br/&gt;(0x7d3a, 0x7d3e)\"]     pintos 工具如何写入参数  pintos 是一个 Perl 脚本，用于启动 Pintos。它会：     打开磁盘镜像文件   定位到偏移 0x1ba (LOADER_ARG_CNT - 0x7c00)   写入参数数量（4 字节）   定位到偏移 0x1be (LOADER_ARGS - 0x7c00)   写入参数字符串（最多 128 字节）   伪代码：  # 打开磁盘镜像 open(DISK, \"+&lt;\", $disk_image);  # 写入参数数量 seek(DISK, 0x1ba, SEEK_SET); print DISK pack(\"V\", $arg_count);  # V = 32位小端  # 写入参数字符串 seek(DISK, 0x1be, SEEK_SET); print DISK join(\"\\0\", @args);     内核如何读取参数  在 threads/init.c 中：  // 参数数量 extern uint32_t init_ram_pages;  // 不是这个，只是示例  // 实际上，内核通过固定地址读取： // 参数数量在 0x7d3a // 参数字符串在 0x7d3e   内核可以通过这些参数来：    决定运行哪个测试   设置调试选项   配置系统参数     空间计算  总空间: 512 字节  引导签名:     2 字节 分区表:       64 字节 命令行参数:   128 字节 参数数量:     4 字节 ────────────────────── 数据区总计:   198 字节  可用于代码:   512 - 198 = 314 字节   这就是为什么引导加载程序的代码必须非常紧凑！    验证布局  可以用 hexdump 或 xxd 验证：  # 查看引导签名 xxd -s 510 -l 2 pintos.dsk # 应该显示: 55 aa  # 查看分区表 xxd -s 446 -l 64 pintos.dsk  # 查看命令行参数 xxd -s 314 -l 4 pintos.dsk   # 参数数量 xxd -s 318 -l 128 pintos.dsk # 参数字符串     常见问题  Q1: 如果代码超过 314 字节会怎样？  汇编器会报错，因为 .org 会尝试回退位置计数器（这是不允许的）。  Q2: 为什么命令行参数在引导代码和分区表之间？  这是 Pintos 特有的设计。传统 MBR 不包含命令行参数。Pintos 在保持 MBR 兼容性的同时，利用未使用的空间传递参数。  Q3: 引导加载程序为什么不使用这些参数？  引导加载程序的任务很简单：加载内核。命令行参数是给内核用的，告诉它该做什么。  Q4: 如果没有分区表会怎样？  代码会打印 “Not found” 并调用 INT 18h。分区表全零等于没有有效分区。  Q5: 0xAA55 有什么特殊含义？  没有深层含义，只是 IBM 在 1981 年选择的一个容易识别的模式：    55 = 01010101   AA = 10101010 这种交替的位模式容易检测硬件错误。     扩展思考：为什么是 512 字节？  历史原因：     早期软盘使用 512 字节扇区   这成为事实标准   硬盘沿用了这个大小   BIOS 被设计为加载一个扇区   现代发展：     高级格式（AF）硬盘使用 4096 字节物理扇区   但逻辑上仍模拟 512 字节扇区   UEFI 可以加载更大的引导程序     练习思考          如果要将命令行参数扩展到 256 字节，需要修改哪些地方？           为什么分区表正好在偏移 446 处？（提示：MBR 规范）           如果把引导签名改成其他值（如 0x1234），会发生什么？           能否在不修改 loader.S 的情况下，通过磁盘编辑器改变命令行参数？           如果引导代码需要更多空间，有什么解决方案？（提示：两阶段引导）        练习答案   点击查看答案 1       扩展命令行参数到 256 字节需要修改：             修改 loader.h：         #define LOADER_ARGS_LEN 256     // 原来是 128                       重新计算地址：         LOADER_SIG = 0x7dfe               // 不变 LOADER_PARTS = 0x7dbe             // 不变 LOADER_ARGS = 0x7dbe - 256 = 0x7cbe  // 改变 LOADER_ARG_CNT = 0x7cbe - 4 = 0x7cba // 改变                       问题：                    命令行参数会从 0x7cba 开始           引导代码从 0x7c00 开始           只剩 0x7cba - 0x7c00 = 186 字节给代码！           当前代码约 314 字节，会冲突！                       解决方案：                    缩短代码           使用两阶段引导           将参数存储在其他位置（如内存中）                             点击查看答案 2       分区表在偏移 446 的原因是 MBR 规范：             MBR 标准布局：         偏移 0-445:   引导代码（446 字节） 偏移 446-509: 分区表（64 字节） 偏移 510-511: 签名（2 字节）                       计算：         512 - 2(签名) - 64(分区表) = 446                       为什么分区表是 64 字节：                    4 个主分区 × 16 字节/分区 = 64 字节           这是 IBM PC 原始设计                       Pintos 的特殊处理：                    利用了引导代码后面的空间存储命令行参数           但分区表位置仍然符合标准，保持兼容性                             点击查看答案 3       如果把引导签名改成 0x1234，BIOS 会拒绝引导：             BIOS 的检查过程： ```                    读取磁盘第一个扇区到 0x7C00           检查偏移 510-511 处的值           如果是 0xAA55，跳转执行           如果不是，尝试下一个启动设备 ```                       如果签名是 0x1234：                    BIOS 认为这不是有效的引导扇区           不会跳转到 0x7C00 执行           尝试其他启动设备（CD、USB 等）           或者显示 “No bootable device found”                       0xAA55 的字节序：         内存地址 510: 0x55 内存地址 511: 0xAA                  这是小端字节序（little-endian）              为什么选择 0xAA55：                    0x55 = 01010101           0xAA = 10101010           交替的位模式容易检测硬件错误           IBM 1981 年原始设计                             点击查看答案 4       可以通过磁盘编辑器修改命令行参数：             定位参数位置：         参数数量: 偏移 0x13a (314) 参数字符串: 偏移 0x13e (318)                       使用十六进制编辑器：         # 查看当前值 xxd -s 314 -l 132 pintos.dsk     # 使用 dd 修改 echo -n \"new args\" | dd of=pintos.dsk bs=1 seek=318 conv=notrunc     # 修改参数数量 printf '\\x02\\x00\\x00\\x00' | dd of=pintos.dsk bs=1 seek=314 conv=notrunc                       更方便的方式：                    Pintos 的 pintos 命令会自动处理这些           手动修改主要用于调试                       注意：                    字符串必须以 null 终止           不能超过 128 字节           参数数量要与字符串匹配                             点击查看答案 5       如果引导代码需要更多空间，可以使用两阶段引导：             两阶段引导原理： ``` 阶段 1: MBR (512 字节)                    基本初始化           加载阶段 2 到内存           跳转到阶段 2                   阶段 2: 更大的引导加载程序                    可以跨越多个扇区           复杂的内核加载逻辑           文件系统支持 ```                       GRUB 的实现：                    Stage 1: 446 字节的 MBR 代码           Stage 1.5: 嵌入在 MBR 和第一个分区之间           Stage 2: 完整的 GRUB 核心                       Pintos 可能的修改：         # 阶段 1: 加载阶段 2 mov $0x8000, %ax    # 加载到 0x80000 mov %ax, %es mov $1, %ebx        # 从扇区 1 开始 mov $10, %cx        # 读 10 个扇区 (5KB) .load_loop:     call read_sector     add $0x20, %ax     inc %bx     loop .load_loop ljmp $0x8000, $0    # 跳转到阶段 2               UEFI 替代：                    现代系统使用 UEFI 而不是 BIOS           UEFI 可以直接加载大型 EFI 应用程序           不受 512 字节限制                              总结：loader.S 完整布局  地址范围          大小      内容 ───────────────────────────────────────────────── 0x7c00-0x7d39    314       引导代码                            - 初始化                            - 串口配置                            - 扫描分区                            - 加载内核                            - 跳转                            - 辅助函数 (puts, putc, read_sector) ───────────────────────────────────────────────── 0x7d3a-0x7d3d    4         命令行参数数量 ───────────────────────────────────────────────── 0x7d3e-0x7dbd    128       命令行参数字符串 ───────────────────────────────────────────────── 0x7dbe-0x7dfd    64        分区表 (4 × 16 字节) ───────────────────────────────────────────────── 0x7dfe-0x7dff    2         引导签名 (0xAA55) ─────────────────────────────────────────────────                  512       总计     这是 loader.S 分析系列的最后一部分。希望这些文档能帮助你理解 Pintos 引导加载程序的工作原理！  系列文档索引     初始化 - 段寄存器和栈的设置   串口配置 - 配置串口用于调试输出   扫描硬盘分区 - 寻找 Pintos 内核分区   加载内核 - 将内核从磁盘读取到内存   跳转到内核 - 从 ELF 头读取入口地址并跳转   错误处理 - 处理各种启动失败情况   puts 函数 - 巧妙的字符串打印实现   putc 函数 - 字符输出和自修改代码   read_sector 函数 - 使用 BIOS 扩展读取磁盘   数据结构 - 引导扇区末尾的数据定义（本文档）"
  },
  
  {
    "title": "Pintos Loader.S 详解（九）：read_sector 函数",
    "url": "/posts/pintos-loader-09-read-sector/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  read_sector 函数是引导加载程序的核心功能之一，负责从磁盘读取一个扇区（512 字节）到内存。它使用 BIOS 的扩展读取功能（Extended Read），支持 LBA 寻址，可以访问大于 8GB 的硬盘。    原始代码  #### Sector read subroutine.  Takes a drive number in DL (0x80 = hard #### disk 0, 0x81 = hard disk 1, ...) and a sector number in EBX, and #### reads the specified sector into memory at ES:0000.  Returns with #### carry set on error, clear otherwise.  Preserves all #### general-purpose registers.  read_sector: \tpusha \tsub %ax, %ax \tpush %ax\t\t\t# LBA sector number [48:63] \tpush %ax\t\t\t# LBA sector number [32:47] \tpush %ebx\t\t\t# LBA sector number [0:31] \tpush %es\t\t\t# Buffer segment \tpush %ax\t\t\t# Buffer offset (always 0) \tpush $1\t\t\t\t# Number of sectors to read \tpush $16\t\t\t# Packet size \tmov $0x42, %ah\t\t\t# Extended read \tmov %sp, %si\t\t\t# DS:SI -&gt; packet \tint $0x13\t\t\t# Error code in CF \tpopa\t\t\t\t# Pop 16 bytes, preserve flags popa_ret: \tpopa \tret\t\t\t\t# Error code still in CF     前置知识  磁盘寻址方式  历史上有两种主要的磁盘寻址方式：  CHS（Cylinder-Head-Sector）寻址        柱面 (Cylinder)          │     ┌────┼────┐     │ ┌──┼──┐ │     磁头 (Head)     │ │  │  │ │     ↓     │ │  │  │ │   ┌───┐     │ │  ●──┼─┼───│ H0│  扇区 (Sector)     │ │  │  │ │   ├───┤     │ │  │  │ │   │ H1│     │ └──┼──┘ │   └───┘     └────┼────┘      柱面：同一半径的所有磁道   磁头：选择哪个盘面   扇区：磁道上的具体位置   CHS 的限制：    柱面: 10 位 (0-1023)   磁头: 8 位 (0-255)   扇区: 6 位 (1-63)   最大: 1024 × 256 × 63 × 512 = 8.4 GB   LBA（Logical Block Addressing）寻址  扇区 0    扇区 1    扇区 2    ...    扇区 N ┌────────┬────────┬────────┬─────┬────────┐ │   0    │   1    │   2    │ ... │   N    │ └────────┴────────┴────────┴─────┴────────┘      扇区从 0 开始连续编号   简单直观   48 位 LBA 支持 128 PB   BIOS INT 13h 扩展  为了支持 LBA 和大硬盘，BIOS 提供了扩展磁盘服务：                 AH 值       功能                       0x41       检查扩展是否支持                 0x42       扩展读取（我们使用这个）                 0x43       扩展写入                 0x44       验证扇区                 0x48       获取驱动器参数           DAP（Disk Address Packet）  扩展读取使用一个叫 DAP 的数据结构来指定参数：  偏移  大小  内容 ──────────────────────────── 0     1    数据包大小（16 或 24） 1     1    保留（必须为 0） 2     2    要读取的扇区数 4     2    缓冲区偏移 6     2    缓冲区段 8     8    起始 LBA 扇区号（64 位）     逐行详解  第 1 行：保存寄存器  read_sector: \tpusha   保存所有通用寄存器。函数承诺不修改调用者的寄存器。    第 2-8 行：在栈上构建 DAP  \tsub %ax, %ax \tpush %ax\t\t\t# LBA sector number [48:63] \tpush %ax\t\t\t# LBA sector number [32:47] \tpush %ebx\t\t\t# LBA sector number [0:31] \tpush %es\t\t\t# Buffer segment \tpush %ax\t\t\t# Buffer offset (always 0) \tpush $1\t\t\t\t# Number of sectors to read \tpush $16\t\t\t# Packet size   这段代码在栈上构建 DAP 结构。由于栈是向下增长的，我们按逆序压入字段。  逐条分析：          sub %ax, %ax：AX = 0，用于后续的零值      push %ax (两次)：            压入 LBA 的高 32 位（位 32-63）       这里总是 0，因为我们不访问超大硬盘           push %ebx：            EBX 包含要读取的扇区号（LBA 位 0-31）       注意这是 32 位压栈           push %es：            缓冲区的段地址       调用者已经设置好了           push %ax：            缓冲区偏移 = 0       总是从段的开始读取           push $1：            读取 1 个扇区           push $16：            DAP 大小 = 16 字节           栈上的 DAP 结构：        高地址    ┌─────────────┐    │   pusha 的  │    │   寄存器    │    ├─────────────┤    │  LBA[48:63] │ = 0    ├─────────────┤    │  LBA[32:47] │ = 0    ├─────────────┤    │  LBA[0:31]  │ = EBX (扇区号)    ├─────────────┤    │   段地址    │ = ES    ├─────────────┤    │   偏移      │ = 0    ├─────────────┤    │   扇区数    │ = 1    ├─────────────┤    │   大小      │ = 16      ← SP 指向这里    └─────────────┘       低地址     第 9-11 行：调用 BIOS 扩展读取  \tmov $0x42, %ah\t\t\t# Extended read \tmov %sp, %si\t\t\t# DS:SI -&gt; packet \tint $0x13\t\t\t# Error code in CF   mov $0x42, %ah：    选择扩展读取功能   mov %sp, %si：    让 SI 指向栈顶（DAP 的开始）   BIOS 通过 DS:SI 访问 DAP   由于 DS = 0，DS:SI = 0:SP = 栈上的 DAP   int $0x13：    调用 BIOS 磁盘服务   参数：            AH = 0x42（扩展读取）       DL = 驱动器号（调用者设置）       DS:SI = DAP 地址           返回值：    CF = 0：成功   CF = 1：失败，AH = 错误码     第 12 行：清理 DAP  \tpopa\t\t\t\t# Pop 16 bytes, preserve flags   这是一个巧妙的技巧！  popa 正常用于恢复寄存器，但这里用它来弹出 16 字节的 DAP：    DAP 大小 = 16 字节   popa 弹出 16 字节   正好清理了 DAP   关键：popa 不影响标志寄存器，所以 CF（进位标志）保持 BIOS 设置的值。  寄存器会变吗？  会！popa 把 DAP 的数据当作寄存器值弹出。但没关系，因为：    下一条 popa 会恢复正确的寄存器值   这只是一个清理技巧     第 13-14 行：恢复寄存器并返回  popa_ret: \tpopa \tret\t\t\t\t# Error code still in CF   popa：    恢复最初 pusha 保存的寄存器   ret：    返回调用者   CF 仍然包含 BIOS 的返回状态   popa_ret 标签：    这个标签被 putc 函数共享使用（见前一节）     内存和栈的变化  调用前  参数: - DL = 0x80 (硬盘 0) - EBX = 100 (扇区号) - ES = 0x2000 (目标段)  栈:    [返回地址]  ← SP   执行后  结果: - ES:0000 (即 0x20000) 包含扇区 100 的内容 - CF = 0 (成功) 或 1 (失败) - 所有寄存器恢复原值     DAP 字段详解                 字段       大小       Pintos 中的值       说明                       大小       1 字节       16       DAP 结构大小                 保留       1 字节       0       必须为 0（和大小字段一起压入）                 扇区数       2 字节       1       只读 1 个扇区                 偏移       2 字节       0       缓冲区偏移                 段       2 字节       ES       缓冲区段                 LBA       8 字节       EBX       扇区号（只用低 32 位）           为什么 LBA 是 64 位？  虽然 Pintos 只用 32 位（最大 2TB），但 BIOS 接口是 64 位的，所以高 32 位用 0 填充。    错误处理  常见错误码（AH 中返回）                 错误码       含义                       0x00       成功                 0x01       无效命令                 0x02       地址标记未找到                 0x04       扇区未找到                 0x05       重置失败                 0x07       驱动器参数活动失败                 0x09       DMA 越界                 0x0A       坏扇区标志                 0x10       ECC 数据错误                 0x20       控制器失败                 0x40       寻道失败                 0x80       超时                 0xAA       驱动器未就绪                 0xBB       未定义错误           调用者如何检查错误  call read_sector jc error_handler        # 如果 CF=1，跳转到错误处理 # 成功，继续...     为什么在栈上构建 DAP？  替代方案 1：静态分配  # 静态 DAP .data dap:     .byte 16        # 大小     .byte 0         # 保留     .word 1         # 扇区数     .word 0         # 偏移     .word 0         # 段 (需要填充)     .long 0         # LBA (需要填充)     .long 0   问题：    浪费 16 字节宝贵的代码空间   需要额外代码填充可变字段   替代方案 2：代码中嵌入  mov $dap, %si # ...填充 dap... int $0x13   问题：    仍然浪费空间   代码更复杂   Pintos 方案  在栈上动态构建 DAP：    不占用额外代码空间   参数（ES, EBX）已经在寄存器中   用 popa 清理，不需要手动调整 SP     两个 popa 的解释  read_sector:     pusha                   # (1) 保存寄存器，16 字节     ...     push ...                # 构建 DAP，16 字节     push ...     int $0x13     popa                    # (2) 弹出 DAP，16 字节 popa_ret:     popa                    # (3) 恢复寄存器，16 字节     ret   栈的变化：  调用后:     [DAP 16字节]     [寄存器 16字节]     [返回地址]  第一个 popa 后:     [寄存器 16字节]     [返回地址]  第二个 popa 后:     [返回地址]   ← 正确状态！     常见问题  Q1: 为什么用扩展读取而不是传统 INT 13h？  传统 INT 13h（AH=02h）使用 CHS 寻址，限制 8.4GB。扩展读取支持 LBA，可以访问任意大小的硬盘。  Q2: 如果 BIOS 不支持扩展读取怎么办？  非常老的 BIOS 可能不支持。但自从 1990 年代中期以来，几乎所有 BIOS 都支持。Pintos 假设支持。  Q3: 为什么每次只读一个扇区？     简单   兼容性好   512 字节代码空间限制   对于 Pintos 来说足够快   Q4: 能否读取多个连续扇区？  可以，只需修改 DAP 的扇区数字段。但需要：    确保缓冲区足够大   某些 BIOS 有单次传输限制   Q5: popa 把 DAP 弹到寄存器里，不会出问题吗？  不会，因为紧接着的第二个 popa 会恢复正确的寄存器值。第一个 popa 只是一个清理 16 字节的技巧。    性能考虑  每扇区一次 BIOS 调用  读取 100 个扇区: - Pintos: 100 次 INT 13h - 优化版: 可能只需 1-2 次  每次 INT 13h 调用开销: - 中断处理 - 模式切换（如果在保护模式） - BIOS 初始化   对于引导加载程序，这种开销是可接受的。  传输速率  受限于：    硬盘物理速度   BIOS 效率   PIO 模式（没有 DMA）   典型速率：几 MB/s（足够引导）    练习思考          如果要读取 2 个扇区，需要修改哪里？缓冲区需要多大？           为什么 push $16 后紧跟的字节被设为 0？（提示：DAP 结构）           如果 EBX 超过 32 位能表示的范围（约 2TB），会发生什么？           能否用 add $16, %sp 代替第一个 popa 来清理 DAP？有什么区别？           为什么 popa_ret 标签被两个函数共享？        练习答案   点击查看答案 1       读取 2 个扇区的修改：      read_two_sectors:     pusha     sub %ax, %ax     push %ax            # LBA [48:63]     push %ax            # LBA [32:47]     push %ebx           # LBA [0:31]     push %es            # 缓冲区段     push %ax            # 缓冲区偏移 = 0     push $2             # 扇区数 = 2 ← 修改这里     push $16            # 包大小 = 16     mov $0x42, %ah     mov %sp, %si     int $0x13     popa     popa     ret       缓冲区大小：            2 个扇区 × 512 字节 = 1024 字节 = 1KB       ES:0x0000 到 ES:0x03FF           注意：            某些 BIOS 对单次传输有限制（通常 127 扇区）       缓冲区不能跨越 64KB 段边界             点击查看答案 2       DAP 结构的第二个字节必须为 0：      DAP 结构：     偏移 0: 包大小 (16 或 24) 偏移 1: 保留 (必须为 0) 偏移 2: 扇区数 ...           代码分析：     push $16            # 压入 16 位即时数       压入 16 位数到栈时：            低字节 = 16 = 0x10（包大小）       高字节 = 0（保留字段，正好为 0！）           内存布局：     栈顶 → [10] [00] [01] [00] ...           │    │    └────┴ 扇区数 = 1           │    └─ 保留 = 0 ✓           └─ 包大小 = 16           这是一个巧妙的副作用，节省了一次 push 操作。        点击查看答案 3       如果需要访问超过 2TB 的扇区，当前代码会失败：             问题分析：                    EBX 是 32 位，最大值 2^32 - 1           2^32 × 512 字节 = 2TB           DAP 的 LBA 字段是 64 位，支持更大                       代码限制：         push %ax      # LBA [48:63] = 0 push %ax      # LBA [32:47] = 0 push %ebx     # LBA [0:31] = 扇区号                     只使用了低 32 位           高 32 位始终为 0                       解决方案：         # 使用 64 位 LBA push %ecx     # LBA 高 32 位 push %ebx     # LBA 低 32 位 # ECX:EBX 合起来是 64 位扇区号               实际情况：                    Pintos 的磁盘远小于 2TB           在引导阶段不需要 64 位 LBA           简化代码是合理的                             点击查看答案 4       add $16, %sp 与 popa 的区别：      # 方案 A: 使用 popa popa                # 1 字节  # 方案 B: 使用 add add $16, %sp        # 4 字节 (83 C4 10 或 81 C4 10 00)       比较：                                 方面           popa           add $16, %sp                                           字节数           1           3-4                             寄存器           修改所有通用寄存器           只修改 SP                             标志           不影响           不影响                           为什么 popa 更好：            节省 2-3 字节       不影响标志寄存器（CF 保持不变）       虽然修改了寄存器，但紧接着的第二个 popa 会恢复正确的值             点击查看答案 5       popa_ret 被 putc 和 read_sector 共享的原因：             两个函数都以相同方式结束：         # putc 和 read_sector 的结尾 popa    # 恢复寄存器 ret     # 返回               节省代码空间：                    共享 2 条指令           节省 2-3 字节                       实现方式：         putc:     pusha     # ... 操作 ...     jmp popa_ret    # 跳转到共享代码     # 或者直接掉落到 popa_ret  read_sector:     pusha     # ... 操作 ...     popa            # 清理 DAP popa_ret:     popa            # 恢复寄存器     ret               代码组织：                    putc 和 read_sector 物理上相邻           putc 的结尾自然掉落到 popa_ret           巧妙的代码布局                              代码复习  完整的 read_sector 函数，带详细注释：  # 读取一个磁盘扇区到内存 # 参数: #   DL = 驱动器号 (0x80 = 第一个硬盘) #   EBX = LBA 扇区号 #   ES:0 = 目标缓冲区 # 返回: #   CF = 0 成功, CF = 1 失败 # 保留所有通用寄存器  read_sector:     pusha                       # 保存所有寄存器      # 在栈上构建 DAP (Disk Address Packet)     sub %ax, %ax     push %ax                    # LBA [48:63] = 0     push %ax                    # LBA [32:47] = 0     push %ebx                   # LBA [0:31] = 扇区号     push %es                    # 缓冲区段     push %ax                    # 缓冲区偏移 = 0     push $1                     # 扇区数 = 1     push $16                    # 包大小 = 16 字节      mov $0x42, %ah              # 扩展读取     mov %sp, %si                # DS:SI -&gt; DAP     int $0x13                   # 调用 BIOS      popa                        # 弹出 DAP (16 字节)                                 # 注意: 不影响 CF  popa_ret:     popa                        # 恢复寄存器     ret                         # CF 包含结果     下一部分  最后，我们来看 loader.S 末尾的数据结构定义。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（八）：putc 函数",
    "url": "/posts/pintos-loader-08-putc-function/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  putc 函数负责将单个字符输出到两个目标：VGA 显示器和串口。它包含一些有趣的技巧，比如自修改代码和自动换行处理。    原始代码  #### Character output subroutine.  Prints the character in AL to the #### VGA display and serial port 0, using BIOS services (see #### [IntrList]).  Preserves all general-purpose registers. #### #### If called upon to output a carriage return, this subroutine #### automatically supplies the following line feed.  putc:\tpusha  1:\tsub %bh, %bh\t\t\t# Page 0. \tmov $0x0e, %ah\t\t\t# Teletype output service. \tint $0x10  \tmov $0x01, %ah\t\t\t# Serial port output service. \tsub %dx, %dx\t\t\t# Serial port 0. 2:\tint $0x14\t\t\t# Destroys AH. \ttest $0x80, %ah\t\t\t# Output timed out? \tjz 3f \tmovw $0x9090, 2b\t\t# Turn \"int $0x14\" above into NOPs.  3: \tcmp $'\\r', %al \tjne popa_ret \tmov $'\\n', %al \tjmp 1b  popa_ret: \tpopa \tret\t\t\t\t# Error code still in CF     前置知识  VGA 文本模式  在文本模式下，VGA 可以显示 80×25 的字符网格。BIOS 提供了简单的输出服务。  ┌────────────────────────────────────────┐ │ 行 0:  Hello, Pintos!                  │ │ 行 1:  Loading...                      │ │ 行 2:                                  │ │ ...                                    │ │ 行 24:                                 │ └────────────────────────────────────────┘       80 列   BIOS 视频服务（INT 10h）                 AH 值       功能                       0x00       设置视频模式                 0x02       设置光标位置                 0x03       获取光标位置                 0x0E       Teletype 输出（我们使用这个）                 0x13       写字符串           BIOS 串口服务（INT 14h）                 AH 值       功能                       0x00       初始化串口                 0x01       发送字符（我们使用这个）                 0x02       接收字符                 0x03       获取状态           什么是自修改代码？  自修改代码是指程序在运行时修改自己的机器码。这是一种古老但有效的技术，可以：    优化性能   节省空间   实现特殊功能   在现代系统中通常避免使用（安全原因），但在引导加载程序中仍然有用。    逐行详解  第 1 行：保存所有寄存器  putc:\tpusha   pusha（Push All）将所有 8 个通用寄存器压入栈：    顺序：AX, CX, DX, BX, SP, BP, SI, DI   共 16 字节   为什么保存所有寄存器？     BIOS 中断可能修改任何寄存器   调用者期望寄存器不变   pusha 比单独 push 每个寄存器更节省空间     第 2-4 行：VGA 输出  1:\tsub %bh, %bh\t\t\t# Page 0. \tmov $0x0e, %ah\t\t\t# Teletype output service. \tint $0x10   sub %bh, %bh：    BH = 0，选择视频页面 0   VGA 可以有多个页面，但我们只用第一个   mov $0x0e, %ah：    AH = 0x0E，选择 “Teletype output” 服务   这个服务会自动处理光标移动和滚动   int $0x10：    调用 BIOS 视频服务   AL 中的字符被显示在当前光标位置   光标自动前进   INT 10h, AH=0Eh 的参数：                 寄存器       内容                       AH       0x0E（功能号）                 AL       要显示的字符                 BH       页面号（通常 0）                 BL       前景色（图形模式下使用）           Teletype 输出的特点：    自动处理 \\r（回车）、\\n（换行）、\\b（退格）   自动滚动屏幕   自动换行     第 5-7 行：串口输出  \tmov $0x01, %ah\t\t\t# Serial port output service. \tsub %dx, %dx\t\t\t# Serial port 0. 2:\tint $0x14\t\t\t# Destroys AH.   mov $0x01, %ah：    AH = 0x01，选择 “发送字符” 服务   sub %dx, %dx：    DX = 0，选择串口 0（COM1）   2:：    这是一个局部标签，用于后面的自修改代码   int $0x14：    调用 BIOS 串口服务   将 AL 中的字符发送到串口   INT 14h, AH=01h 的参数：                 寄存器       内容                       AH       0x01（功能号）                 AL       要发送的字符                 DX       串口号（0-3）           返回值：    AH 的位 7 如果为 1，表示超时错误     第 8-10 行：超时处理和自修改代码  \ttest $0x80, %ah\t\t\t# Output timed out? \tjz 3f \tmovw $0x9090, 2b\t\t# Turn \"int $0x14\" above into NOPs.   test $0x80, %ah：    测试 AH 的位 7   如果位 7 = 1，表示串口输出超时   jz 3f：    如果没有超时（位 7 = 0），跳到标签 3 继续   movw $0x9090, 2b：    这是自修改代码！   将 0x9090 写入标签 2: 的位置   0x90 是 NOP（No Operation）指令的操作码   0x9090 = 两个 NOP，刚好覆盖 int $0x14（CD 14，2 字节）   自修改代码详解：  修改前:                修改后: 2: int $0x14          2: nop    (CD 14)               nop                          (90 90)   为什么要这样做？  如果串口不存在或故障，每次尝试输出都会超时。通过把 int $0x14 改成 NOP：    后续调用不再尝试串口输出   避免反复超时等待   大大加快输出速度   这安全吗？  在引导加载程序环境中是安全的：    单处理器   代码在 RAM 中（不是 ROM）   没有代码签名或保护     第 11-15 行：自动换行处理  3: \tcmp $'\\r', %al \tjne popa_ret \tmov $'\\n', %al \tjmp 1b   cmp $'\\r', %al：    比较 AL 和回车符（0x0D）   jne popa_ret：    如果不是回车符，跳到结束   mov $'\\n', %al 和 jmp 1b：    如果是回车符，追加一个换行符   跳回标签 1，再次执行输出   为什么要这样做？  不同系统使用不同的行结束符：    Unix/Linux: \\n（LF，换行）   Mac (旧): \\r（CR，回车）   Windows: \\r\\n（CRLF）   通过自动在 \\r 后添加 \\n，确保在各种终端上都能正确换行。  \\r 和 \\n 的区别：  \\r (回车): 光标移到行首 \\n (换行): 光标移到下一行  单独 \\r:        单独 \\n:        \\r\\n 组合: Hello           Hello           Hello World           Hello           World      ^World         ^      光标在 W       World 覆盖了 Hello     第 16-18 行：返回  popa_ret: \tpopa \tret\t\t\t\t# Error code still in CF   popa：    恢复之前保存的所有寄存器   顺序相反：DI, SI, BP, (跳过 SP), BX, DX, CX, AX   ret：    返回调用者   “Error code still in CF” 注释：  popa 和 ret 都不会修改标志寄存器。如果之前的操作设置了进位标志（如磁盘读取失败），它仍然保持。这个标签被 read_sector 函数共享使用。    执行流程图  flowchart TD     A[\"putc: 保存寄存器&lt;br/&gt;(pusha)\"] --&gt; B[\"VGA 输出&lt;br/&gt;(INT 10h)\"]     B --&gt; C[\"串口输出&lt;br/&gt;(INT 14h)\"]     C --&gt; D{超时?}     D --&gt;|否| F{是回车 '\\\\r'?}     D --&gt;|是| E[\"自修改代码&lt;br/&gt;禁用串口输出\"]     E --&gt; F     F --&gt;|否| G[\"恢复寄存器&lt;br/&gt;(popa)\"]     F --&gt;|是| H[\"AL = '\\\\n'&lt;br/&gt;再输出一次\"]     H --&gt; B     G --&gt; I[ret]     自修改代码深入分析  机器码变化  原始代码: 地址    机器码    汇编 0x...   CD 14     int $0x14  修改后: 地址    机器码    汇编 0x...   90 90     nop; nop   为什么用两个 NOP？     int $0x14 是 2 字节指令（CD 14）   需要用 2 字节来覆盖   90 是单字节 NOP 指令   所以用两个 NOP (90 90)   自修改代码的风险                 风险       说明       在这里是否适用？                       多核同步问题       其他核可能执行旧代码       否（单核引导）                 指令缓存问题       CPU 缓存可能有旧指令       可能，但 8086/8088 无缓存                 安全问题       可被恶意利用       否（引导代码不受保护）                 可维护性差       代码难以理解       是，但空间受限时值得             双输出的好处  同时输出到 VGA 和串口有多个好处：  ┌─────────────────────────────────────────────────────────┐ │                        计算机                          │ │  ┌─────────────┐                    ┌─────────────┐   │ │  │   CPU       │                    │   串口      │───┼──► 调试终端 │  │   运行      │ ──────────────────►│   COM1      │   │ │  │   putc      │        │           └─────────────┘   │ │  └─────────────┘        │                              │ │                         ▼           ┌─────────────┐   │ │                    ┌─────────────┐  │   显示器    │   │ │                    │   VGA       │──┤             │   │ │                    │   控制器    │  └─────────────┘   │ │                    └─────────────┘                     │ └─────────────────────────────────────────────────────────┘   使用场景：     本地调试：直接看显示器   远程调试：通过串口连接另一台电脑   日志记录：串口输出可以重定向到文件   无头服务器：没有显示器时用串口     常见问题  Q1: 如果 VGA 也出错怎么办？  代码没有检查 VGA 输出错误。通常 VGA 输出不会失败（除非硬件彻底坏了）。  Q2: 为什么不用更高级的 VGA 函数？  INT 10h AH=0Eh（Teletype）是最简单、最兼容的选择。更高级的函数可能需要更多参数或不是所有 BIOS 都支持。  Q3: 串口禁用后能重新启用吗？  不能。自修改代码永久地将 int $0x14 改成了 NOP。要重新启用，需要重新启动。  Q4: 为什么把标签放在 int $0x14 之前？  2:\tint $0x14           # 标签 2 在这 \ttest $0x80, %ah \t... \tmovw $0x9090, 2b    # 修改标签 2 处的代码   标签必须精确地指向要修改的指令。2b 表示”向后（backward）找标签 2”。  Q5: popa 为什么不恢复 SP？  popa 会跳过 SP 的恢复，因为：    SP 在 pusha/popa 期间一直在变化   恢复 pusha 时的 SP 值会导致栈混乱   x86 的设计就是这样     性能分析  超时的代价  如果串口每次都超时：  每个字符: - VGA 输出: ~微秒级 - 串口超时: ~毫秒级（取决于 BIOS）  假设 1000 个字符: - 没有超时: ~秒级完成 - 每次超时: 可能需要几秒   通过自修改代码禁用串口后，性能回到正常水平。  空间效率  pusha/popa vs 单独 push/pop：                 方法       指令       字节数                       pusha       1 条       1 字节                 8 个 push       8 条       8 字节           节省 7 字节！    练习思考          如果要支持不同颜色的文本输出，需要如何修改代码？           自修改代码在现代 CPU 上可能有什么问题？（提示：考虑指令缓存）           为什么 \\r 后面自动加 \\n，而不是在源代码中直接写 \\r\\n？           如果串口输出成功后又开始超时，会发生什么？           能否用条件跳转代替自修改代码？有什么优缺点？        练习答案   点击查看答案 1       支持不同颜色需要修改 INT 10h 调用：      # 新的 putc 函数，支持颜色 # AL = 字符，BL = 颜色属性 putc_color:     pusha          # VGA 输出     mov $0x0e, %ah          # Teletype 输出     mov $0, %bh             # 页面 0     # BL 已包含颜色     int $0x10          # ... 串口输出 ...       颜色属性字节：     位 7:   闪烁 位 6-4: 背景色 (0-7) 位 3:   高亮度 位 2-0: 前景色 (0-7)  示例： 0x07 = 白字黑底（默认） 0x04 = 红字黑底 0x0C = 亮红字黑底 0x1F = 白字蓝底           注意：Teletype 输出 (AH=0Eh) 在文本模式下不一定支持颜色，可能需要使用 AH=09h（写字符和属性）。        点击查看答案 2       自修改代码在现代 CPU 上的问题：             指令缓存不一致：                    现代 CPU 有独立的指令缓存 (I-Cache) 和数据缓存 (D-Cache)           修改代码写入 D-Cache           I-Cache 可能仍然包含旧代码           结果：执行的可能是旧代码！                       解决方案：         # 修改代码后刷新缓存 movw $0x9090, 2b wbinvd              # 写回并无效化缓存 # 或者 cpuid               # 序列化指令               在引导阶段为什么没问题：                    实模式下，很多老 CPU 没有缓存           这段代码很短，可能全部在 L1 缓存行内           写入同一缓存行可能触发自动刷新           BIOS/引导环境通常缓存配置简单                       现代最佳实践：                    避免自修改代码           使用条件跳转或函数指针                             点击查看答案 3       \\r 后自动加 \\n 的原因：             节省字符串空间：                    每次写 \\r\\n 需要 2 字节           如果有 5 个换行，节省 5 字节           在 512 字节限制下很有价值                       历史原因：                    \\r (CR) = 回车，光标移到行首           \\n (LF) = 换行，光标移到下一行           在老式电传打字机上是两个独立操作           DOS/Windows 使用 \\r\\n           Unix/Linux 只使用 \\n                       代码逻辑：         cmp $'\\r', %al      # 是回车吗？ jne popa_ret        # 不是，返回 mov $'\\n', %al      # 是，改为换行 jmp 1b              # 再输出一次          这样写 \\r 就自动变成 \\r\\n。                    点击查看答案 4       如果串口输出成功后又开始超时，串口输出已经被禁用，不会再尝试！      原因：            自修改代码是永久性的       int $0x14 已经被改成 nop nop       后续所有调用都不会执行串口输出           场景分析：     时间线： 1. 输出 'P' - 串口正常 2. 输出 'i' - 串口正常 3. 串口线被拔掉 4. 输出 'n' - 超时，禁用串口 5. 输出 't','o','s' - 只有 VGA，没有串口 6. 串口重新连接 7. 输出后续字符 - 仍然没有串口（已被永久禁用）           这是设计折衷：            优点：避免反复超时耗时       缺点：不能自动恢复       对于引导过程，这是可接受的             点击查看答案 5       用条件跳转代替自修改代码：      # 使用标志变量的版本 serial_disabled: .byte 0    # 标志：0=启用, 1=禁用  putc:     pusha          # VGA 输出...          # 检查串口是否禁用     cmpb $0, serial_disabled     jne skip_serial          # 尝试串口输出     mov $0x01, %ah     sub %dx, %dx     int $0x14     test $0x80, %ah     jz skip_serial     movb $1, serial_disabled  # 设置禁用标志      skip_serial:     # ... 继续 ...       比较：                                 方面           自修改代码           条件跳转                                           代码大小           较小           较大（需要存储标志）                             每次开销           0 条指令（NOP）           2-3 条指令（cmp + jne）                             可读性           差           好                             可恢复性           不能           可以清除标志                             缓存安全           可能有问题           安全                             现代性           不推荐           推荐                           在 512 字节限制下，自修改代码是合理的选择。         代码复习  完整的 putc 函数，带详细注释：  # 输出单个字符到 VGA 和串口 # 参数: AL = 要输出的字符 # 保留所有通用寄存器 # 如果输出 '\\r'，自动追加 '\\n'  putc:     pusha                       # 保存所有寄存器  1:  sub %bh, %bh                # VGA 页面 0     mov $0x0e, %ah              # Teletype 输出     int $0x10                   # BIOS 视频服务      mov $0x01, %ah              # 串口发送     sub %dx, %dx                # 串口 0 (COM1) 2:  int $0x14                   # BIOS 串口服务     test $0x80, %ah             # 检查超时     jz 3f                       # 没超时，继续     movw $0x9090, 2b            # 超时！禁用串口输出  3:  cmp $'\\r', %al              # 是回车符？     jne popa_ret                # 不是，返回     mov $'\\n', %al              # 是，追加换行     jmp 1b                      # 再输出一次  popa_ret:     popa                        # 恢复所有寄存器     ret     下一部分  read_sector 函数是最后一个重要的辅助函数，负责从磁盘读取扇区。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（七）：puts 函数",
    "url": "/posts/pintos-loader-07-puts-function/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  puts 是一个非常巧妙的字符串打印函数。它的独特之处在于：字符串不是通过参数传递，而是直接跟在 call 指令后面。这种设计极大地节省了代码空间。    原始代码  #### Print string subroutine.  To save space in the loader, this #### subroutine takes its null-terminated string argument from the #### code stream just after the call, and then returns to the byte #### just after the terminating null.  This subroutine preserves all #### general-purpose registers.  puts:\txchg %si, %ss:(%esp) \tpush %ax next_char: \tmov %cs:(%si), %al \tinc %si \ttest %al, %al \tjz 1f \tcall putc \tjmp next_char 1:\tpop %ax \txchg %si, %ss:(%esp) \tret     调用方式  普通的字符串打印函数通常这样调用：  # 传统方式（需要额外存储字符串地址） mov $string_addr, %si call print_string ... string_addr: .string \"Hello\"   但 Pintos 的 puts 这样调用：  # Pintos 方式（字符串紧跟在 call 后面） call puts .string \"Hello\" # 执行完后，直接从这里继续   优势：    不需要单独存储字符串地址   代码更紧凑   字符串和调用点在一起，更易读     前置知识  call 指令的工作原理  当执行 call puts 时：     压栈返回地址：将下一条指令的地址压入栈   跳转：跳转到 puts 函数   执行前:                      执行 call 后:                               代码:                        栈: ┌─────────────┐              ┌─────────────┐ │ call puts   │              │ 返回地址    │ ← ESP ├─────────────┤ ← 返回地址   ├─────────────┤ │ \"Hello\"     │              │   ...       │ ├─────────────┤              └─────────────┘ │ 下一指令    │               └─────────────┘                 关键点：返回地址指向的是字符串的开始，不是下一条真正的指令！  栈帧结构          高地址    ┌─────────────┐    │    ...      │    ├─────────────┤    │  返回地址   │ ← ESP 指向这里（SS:ESP）    └─────────────┘         低地址   xchg 指令  xchg 指令交换两个操作数的值：  xchg %si, %ss:(%esp) # 等价于: temp = %si %si = [SS:ESP] [SS:ESP] = temp     逐行详解  第 1 行：获取字符串地址  puts:\txchg %si, %ss:(%esp)   这做了什么？  交换 SI 寄存器和栈顶的值（返回地址）。  执行前：    SI = 某个值（需要保存）   [SS:ESP] = 返回地址（指向字符串）   执行后：    SI = 返回地址（现在指向字符串）   [SS:ESP] = 原来的 SI 值（已保存）   为什么用 xchg？  一石二鸟：    把返回地址（字符串地址）加载到 SI   同时保存原来的 SI 值（放到栈上）   为什么是 %ss:(%esp) 而不是 (%esp)？  在实模式下，默认栈操作使用 SS 段。为了明确和安全，显式写出 %ss:。    第 2 行：保存 AX  \tpush %ax   保存 AX 寄存器，因为后面要用它来处理字符。函数承诺”保留所有通用寄存器”。  栈状态：    ┌─────────────┐    │ 原来的 AX   │ ← ESP    ├─────────────┤    │ 原来的 SI   │    └─────────────┘     第 3-4 行：读取字符  next_char: \tmov %cs:(%si), %al \tinc %si   mov %cs:(%si), %al：    从 CS:SI 地址读取一个字节   存入 AL 寄存器   为什么用 CS 段？  字符串在代码中（紧跟 call 指令后），所以在代码段（CS）内。  inc %si：    SI 加 1，指向下一个字符     第 5-6 行：检查字符串结束  \ttest %al, %al \tjz 1f   test %al, %al：    执行 AL AND AL   只设置标志位，不保存结果   如果 AL = 0，零标志 ZF = 1   jz 1f：    Jump if Zero：如果 ZF = 1，跳转到标签 1:   1f 表示向前（forward）找标签 1   遇到 null 终止符时结束循环   为什么用 test 而不是 cmp $0, %al？                 指令       机器码       字节数                       test %al, %al       84 C0       2                 cmp $0, %al       3C 00       2           字节数相同，但 test 是更常见的惯用法。    第 7-8 行：打印字符并循环  \tcall putc \tjmp next_char   call putc：调用字符打印函数（稍后详解）  jmp next_char：跳回循环开始，处理下一个字符    第 9-10 行：恢复寄存器  1:\tpop %ax \txchg %si, %ss:(%esp)   pop %ax：恢复原来的 AX 值  xchg %si, %ss:(%esp)：    交换 SI 和栈顶的值   SI 恢复为原来的值   栈顶变成新的返回地址（字符串结束后的位置）   这是关键！ 现在栈顶的返回地址指向字符串的 null 终止符之后——也就是真正的下一条指令。    第 11 行：返回  \tret   从栈中弹出返回地址并跳转。由于栈顶已经被更新为字符串之后的地址，所以会正确返回到调用者的下一条指令。    执行过程详解  假设有以下代码：          call puts msg:    .string \"Hi\" next:   mov $1, %ax   步骤 1：执行 call puts  代码布局: 地址    内容 0x100   call puts       (E8 xx xx) 0x103   'H'             (48) 0x104   'i'             (69) 0x105   '\\0'            (00) 0x106   mov $1, %ax     (下一指令)  栈: [0x103]  ← 返回地址指向 'H'   步骤 2：xchg %si, %ss:(%esp)  SI = 0x103 (字符串地址) 栈: [原SI值]   步骤 3：push %ax  栈: [原AX值]     [原SI值]   步骤 4-8：打印循环  迭代 1: 读取 'H' (0x103), 打印, SI = 0x104 迭代 2: 读取 'i' (0x104), 打印, SI = 0x105 迭代 3: 读取 '\\0' (0x105), 发现是 0, 跳出循环   步骤 9：pop %ax  AX = 原来的值 栈: [原SI值]   步骤 10：xchg %si, %ss:(%esp)  SI = 原来的值 栈: [0x106]  ← 现在指向 'mov $1, %ax'   步骤 11：ret  跳转到 0x106, 执行 mov $1, %ax     图解执行流程                      调用前                执行 puts 中              返回后                      代码:                ┌─────────────┐      │ call puts   │──────────────────────────────────────────────────┐ ├─────────────┤                                                  │ │ 'H'         │◄──── SI 从这里开始 ──────────────────────────────│ ├─────────────┤                     │                            │ │ 'i'         │                     │ 逐字符读取并打印           │ ├─────────────┤                     │                            │ │ '\\0'        │                     ▼                            │ ├─────────────┤◄──── SI 结束在这里 ─────────────────────────────│ │ mov $1, %ax │──────────────────────────────────────────────────┘ └─────────────┘          ▲                            返回到这里                          │                          └── SI 最终指向这里                               (null 之后)     为什么这样设计？  传统方法的问题  # 方法 1：用寄存器传递地址     mov $msg, %si     call print_string     ... msg: .string \"Hello\"  # 问题： # - 需要额外的 mov 指令 # - 字符串远离调用点，不直观   # 方法 2：用栈传递地址     push $msg     call print_string     add $2, %sp         # 清理栈     ... msg: .string \"Hello\"  # 问题： # - 需要 push 和清理栈 # - 更多字节   Pintos 方法的优势      call puts     .string \"Hello\"     # 自动从这里继续  # 优势： # - 最少的字节数 # - 字符串紧跟调用，直观 # - 不需要清理   节省的空间：                 方法       字节数                       传统方法       5-8 字节                 Pintos 方法       仅 call 的 3 字节             常见问题  Q1: 为什么要保存所有寄存器？  调用者不知道 puts 会修改哪些寄存器。为了安全，puts 保证不破坏任何通用寄存器的值。这样调用者可以放心使用。  Q2: 如果字符串中有 ‘\\0’ 会怎样？  字符串会在第一个 ‘\\0’ 处截断。这是 C 语言的标准行为（null 终止字符串）。  Q3: xchg 指令是原子的吗？  在单处理器系统上，xchg 指令是原子的。在多处理器系统上，xchg 访问内存时会自动加锁。但在引导阶段，只有一个处理器在运行，所以这不是问题。  Q4: 为什么用 %cs:(%si) 而不是 (%si)？  在实模式下，不同的段有不同的用途：    CS：代码段   DS：数据段   SS：栈段   字符串在代码中，所以必须用 CS 段来访问。如果用 DS（默认），可能指向错误的位置。  Q5: 这种技术有名字吗？  这种技术有时被称为 “inline string” 或 “embedded string” 技术。它在早期的汇编程序和引导加载程序中很常见。    类似技术的现代应用  虽然这种技术现在不常见，但类似的思想在其他地方出现：  Position-Independent Code (PIC)  call get_ip get_ip:     pop %ebx        # EBX = 当前指令地址   这种技术用于获取当前代码的地址，用于位置无关代码。  ARM 的 PC-relative 寻址  ARM 处理器有专门的指令从相对 PC 的位置加载数据，类似的思想。    练习思考          如果不使用 xchg，需要多少条指令来实现相同的功能？           为什么 push %ax 在 xchg 之后而不是之前？           如果在字符串中间有 \\0，如 .string \"Hel\\0lo\"，会打印什么？           这种技术在 32 位或 64 位模式下是否还有效？需要什么修改？           如果 puts 函数本身需要调用其他函数，栈的变化会如何？        练习答案   点击查看答案 1       不使用 xchg 实现相同功能需要更多指令：      puts:     # 不用 xchg 的版本     push %si              # 保存原 SI     mov %ss:2(%esp), %si  # 从栈中获取返回地址     push %ax          # ... 循环代码 ...          pop %ax     mov %si, %ss:4(%esp)  # 更新返回地址     pop %si               # 恢复原 SI     ret       对比：            xchg 版本：1 条指令，2-3 字节       非 xchg 版本：至少 4-5 条指令，8+ 字节           xchg 的优势：            同时完成读取和保存       原子操作，更安全       更少的代码空间             点击查看答案 2       push %ax 在 xchg 之后的原因：             栈结构关系：                    xchg %si, %ss:(%esp) 操作的是栈顶（ESP 指向的位置）           这个位置当前是返回地址           如果先 push %ax，返回地址就不在栈顶了                       如果项序稍改：         # 错误版本 puts:     push %ax              # AX 在栈顶     xchg %si, %ss:(%esp)  # 这会交换 SI 和 AX，不是返回地址！               正确项序的栈状态：         进入时：     xchg后：       push ax后： ┌────────┐   ┌────────┐   ┌────────┐ │返回地址│   │原SI值  │   │  AX    │ ← ESP └────────┘   └────────┘   ├────────┤     ↑ESP        ↑ESP     │原SI值  │                         └────────┘                             点击查看答案 3       如果字符串是 .string \"Hel\\0lo\"，只会打印 “Hel”。      原因：            puts 使用 test %al, %al 检查 null 终止符       遇到第一个 \\0 时，循环结束       后面的 “lo” 永远不会被读取           更重要的问题：            返回地址会指向第一个 \\0 之后       也就是 “lo” 的开始位置       CPU 会尝试执行 “lo\\0” 作为机器码！           机器码解释：     'l' = 0x6C 'o' = 0x6F '\\0' = 0x00  字节序列：6C 6F 00 可能被解释为：   insb (%dx), %es:(%edi)  # 6C   outsb                   # 6F...            这会导致未定义行为或崩溃。        点击查看答案 4       这种技术在 32 位或 64 位模式下仍然有效，但需要修改：      32 位模式：     puts32:     xchg %esi, (%esp)     # 32 位寄存器和 32 位返回地址     push %eax      next_char:     mov (%esi), %al       # 从平坦地址空间读取     inc %esi     test %al, %al     jz done     # ... 输出字符 ...     jmp next_char      done:     pop %eax     xchg %esi, (%esp)     ret       64 位模式：     puts64:     xchg %rsi, (%rsp)     # 64 位     push %rax          # ... 类似逻辑 ...       主要变化：            寄存器名称：SI → ESI → RSI       地址宽度：16 位 → 32 位 → 64 位       不需要段前缀：保护模式使用平坦地址空间             点击查看答案 5       puts 调用 putc 时的栈变化：      调用 puts 前： ┌────────────┐ │  返回地址    │ ← ESP │ (指向字符串) │ └────────────┘  xchg 后： ┌────────────┐ │   原 SI 值   │ ← ESP └────────────┘ SI = 字符串地址  push %ax 后： ┌────────────┐ │     AX       │ ← ESP ├────────────┤ │   原 SI 值   │ └────────────┘  call putc 时： ┌────────────┐ │ putc返回地址 │ ← ESP ├────────────┤ │     AX       │ ├────────────┤ │   原 SI 值   │ └────────────┘  putc 内部 pusha 后： ┌────────────┐ │  所有寄存器  │ ← ESP (16 字节) ├────────────┤ │ putc返回地址 │ ├────────────┤ │     AX       │ ├────────────┤ │   原 SI 值   │ └────────────┘           关键点：            每层调用都会添加自己的返回地址和保存的寄存器       原始的 “SI 值” 始终在栈的固定偏移位置       返回时按相反顺序弹出，恢复栈状态              代码复习  完整的 puts 函数，带详细注释：  # 打印 null 终止的字符串 # 字符串紧跟在 call 指令后面 # 保留所有通用寄存器  puts:     xchg %si, %ss:(%esp)    # SI ← 返回地址（字符串）                              # 同时保存原 SI     push %ax                 # 保存 AX  next_char:     mov %cs:(%si), %al       # AL ← 下一个字符     inc %si                  # SI 前进     test %al, %al            # 是否为 null？     jz 1f                    # 是，退出循环     call putc                # 打印字符     jmp next_char            # 继续  1:  pop %ax                  # 恢复 AX     xchg %si, %ss:(%esp)     # 恢复 SI                              # 返回地址 ← SI（字符串之后）     ret                      # 返回到字符串之后     下一部分  puts 函数调用 putc 来打印单个字符。接下来我们分析 putc 函数。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（六）：错误处理",
    "url": "/posts/pintos-loader-06-error-handling/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  在引导过程中，很多事情可能出错：硬盘读取失败、找不到分区、找不到内核等。这部分代码负责处理这些错误情况，向用户显示错误信息，并通知 BIOS 启动失败。    原始代码  read_failed: start: \t# Disk sector read failed. \tcall puts 1:\t.string \"\\rBad read\\r\"  \t# Notify BIOS that boot failed.  See [IntrList]. \tint $0x18   以及前面的：  no_such_drive: no_boot_partition: \t# Didn't find a Pintos kernel partition anywhere, give up. \tcall puts \t.string \"\\rNot found\\r\"  \t# Notify BIOS that boot failed.  See [IntrList]. \tint $0x18     错误类型分析  错误 1：磁盘读取失败（Bad read）  触发条件：    read_sector 函数返回时 CF（进位标志）为 1   可能的原因：            物理硬盘故障       坏扇区       BIOS 驱动问题       扇区号超出范围           发生位置： call read_sector jc read_failed      # 如果 CF=1，跳转到错误处理   错误 2：找不到驱动器（No such drive）  触发条件：    尝试读取不存在的硬盘的 MBR   read_sector 在读取扇区 0 时失败   发生位置： read_mbr:     ...     call read_sector     jc no_such_drive    # 硬盘不存在   错误 3：找不到启动分区（Not found）  触发条件：    扫描完所有硬盘和分区   没有找到类型为 0x20（Pintos）且可启动（0x80）的分区   发生位置： next_drive:     inc %dl     jnc read_mbr        # 继续扫描下一个硬盘                         # 如果溢出，跳到 no_boot_partition  no_such_drive: no_boot_partition:     # 打印 \"Not found\"     逐行详解  错误处理入口点  read_failed: start:   这里有两个标签指向同一位置！  read_failed：磁盘读取失败时跳转到这里 start：用于存储跳转地址（在成功路径中被覆盖）  这是一个巧妙的代码复用：    失败时：执行错误处理代码   成功时：这块内存被跳转地址覆盖     打印错误信息  \tcall puts 1:\t.string \"\\rBad read\\r\"   分析：     call puts：调用字符串打印函数   1:：局部标签（用于内部跳转，不影响其他代码）   .string \"\\rBad read\\r\"：            \\r（回车符）将光标移动到行首       “Bad read” 是错误信息       最后的 \\r 确保光标在行首           为什么用 \\r 而不是 \\n？  回车符 \\r 只移动光标到行首，不换行。这样可以：    覆盖之前的 “Loading…” 输出   不浪费屏幕空间   清晰显示错误发生     通知 BIOS 启动失败  \tint $0x18   INT 18h 是什么？  这是 BIOS 的”启动失败”中断。当引导加载程序无法启动操作系统时，调用此中断。  BIOS 可能的响应：                 BIOS 行为       说明                       尝试下一个启动设备       如果启动顺序中还有其他设备                 显示错误信息       “No bootable device found”                 进入 BIOS 设置       让用户选择其他启动方式                 执行 ROM BASIC       在很老的系统上                 系统挂起       什么都不做           历史背景：  在早期 IBM PC 上，INT 18h 会尝试从 ROM 中启动 BASIC 解释器。现代 BIOS 通常显示错误或尝试其他启动设备。    “Not found” 错误处理  no_such_drive: no_boot_partition: \tcall puts \t.string \"\\rNot found\\r\" \tint $0x18   两种不同的错误使用相同的处理代码：    no_such_drive：硬盘不存在   no_boot_partition：找不到 Pintos 分区   它们共享同一个错误信息 “Not found”，因为对用户来说结果是一样的：无法启动。    代码复用详解  为什么 start 和 read_failed 是同一位置？  这是为了节省空间。让我们详细分析：  需要的空间：    跳转地址存储：4 字节   错误处理代码：约 10+ 字节   复用方案：                  成功路径                    失败路径                     │                           │                     ▼                           ▼ start/read_failed: ┌───┬───┬───┬───┐    ┌───────────────┐                    │ 跳│ 转│ 地│ 址│    │call puts      │                    └───┴───┴───┴───┘    │\"Bad read\"     │                          │               └───────────────┘                          ▼                     ljmp *start                     (使用这4字节跳转)   成功时：    mov %dx, start 覆盖 call 指令的前 2 字节   movw $0x2000, start + 2 覆盖接下来的 2 字节   ljmp *start 从这 4 字节读取跳转地址   失败时：    直接执行 call puts   打印错误信息   调用 INT 18h     错误显示时序  正常启动: Pintos hda1234 Loading.................... (跳转到内核，不再显示)  磁盘读取失败: Pintos hda1 Loading..... Bad read (系统挂起或 BIOS 接管)  找不到分区: Pintos hda1234 hdb1234 Not found (系统挂起或 BIOS 接管)     进位标志（Carry Flag）详解  read_sector 使用进位标志 CF 报告错误：  read_sector:     ...     int $0x13           # BIOS 磁盘服务     ...     ret                 # CF 保持 BIOS 设置的值  # 调用方检查 CF： call read_sector jc error_handler        # Jump if Carry (CF=1)   为什么用 CF 而不是返回值？     效率：不需要额外的寄存器或内存   BIOS 约定：INT 13h 本身就用 CF 报告错误   简单：一条 jc 指令就能检查   CF 的两种状态：                 CF 值       含义                       0       操作成功                 1       操作失败             调试技巧  如何诊断 “Bad read” 错误     检查硬盘镜像     # 验证镜像文件完整性 ls -l os.dsk xxd os.dsk | head           检查 QEMU 参数     # 确保硬盘正确连接 qemu-system-i386 -hda os.dsk ...           查看 BIOS 错误码            INT 13h 在 AH 中返回错误码       常见错误码：                    0x01: 无效命令           0x02: 地址标记未找到           0x04: 扇区未找到           0x10: CRC 错误           0x20: 控制器故障                           如何诊断 “Not found” 错误     检查分区表     # 查看分区信息 fdisk -l os.dsk           验证分区类型     # 分区类型应该是 0x20 xxd -s 446 -l 64 os.dsk           检查启动标志            第一个字节应该是 0x80（可启动）             错误处理流程图                ┌────────────────────────────┐               │      开始引导过程          │               └─────────────┬──────────────┘                             │               ┌─────────────▼──────────────┐               │       读取 MBR             │               └─────────────┬──────────────┘                      │      │                成功  │      │ 失败                      │      └──────────────────┐               ┌──────▼──────┐                  │               │ 检查分区表  │                  │               └──────┬──────┘                  │                      │                         │             ┌────────┴────────┐                │             │找到Pintos分区？ │                │             └────────┬────────┘                │                │     │                         │           是   │     │ 否                      │                │     └─────────────┐           │         ┌──────▼──────┐           │           │         │  加载内核   │           │           │         └──────┬──────┘           │           │           │    │                  │           │      成功 │    │ 失败             │           │           │    │                  │           │           │    └────────┐         │           │           │             │         │           │    ┌──────▼──────┐  ┌───▼─────────▼───────────▼───┐    │ 跳转到内核  │  │        错误处理              │    │  (成功!)   │  │  - 打印 \"Bad read\" 或        │    └─────────────┘  │    \"Not found\"              │                     │  - INT 18h                  │                     │  - BIOS 接管                │                     └─────────────────────────────┘     代码安全性分析  潜在风险     INT 18h 可能返回            代码假设 INT 18h 不会返回       如果返回，行为未定义           代码复用的脆弱性            start 标签的位置很关键       如果代码结构改变，可能破坏复用           没有无限循环保护            错误处理后，如果 BIOS 返回，代码可能继续执行       可能执行到随机数据           改进建议（如果空间允许）  error_loop:     call puts     .string \"\\rError\\r\"     cli                     # 禁用中断     hlt                     # 停止 CPU     jmp error_loop          # 以防万一   这样确保系统在错误后完全停止。    常见问题  Q1: 为什么两种错误用同一个消息？  空间限制！每个字符串占用宝贵的字节。用户通常不需要区分具体是哪种 “未找到” 错误。  Q2: INT 18h 之后会发生什么？  取决于 BIOS 设置：    可能尝试从 CD-ROM、USB 等启动   可能显示 “No bootable device”   可能进入 BIOS 设置界面   Q3: 如果 INT 18h 返回会怎样？  代码没有处理 INT 18h 返回的情况。如果 BIOS 返回：    执行会继续到 int $0x18 之后的代码   可能是 puts 函数或其他代码   结果未定义，可能崩溃   为什么不处理？    大多数 BIOS 不会返回   没有合理的恢复操作   节省代码空间   Q4: 能否显示更详细的错误信息？  可以，但会增加代码大小。例如： # 更详细的版本（伪代码） cmp $0x80, %ah      # 检查 BIOS 错误码 je timeout_error cmp $0x20, %ah je controller_error ...   这会占用太多空间，不适合 512 字节限制。    练习思考          如果要区分 “Bad read” 和 “Not found” 显示不同颜色，需要如何修改代码？           为什么 int $0x18 之后没有 hlt 指令？           如果在模拟器（如 QEMU）中遇到 “Not found” 错误，应该如何排查？           能否在不增加代码大小的情况下提供更多错误信息？（提示：考虑用不同数量的字符表示不同错误）        练习答案   点击查看答案 1       在 VGA 文本模式下显示不同颜色，需要使用 INT 10h 的扩展功能：      read_failed:     mov $0x04, %bl      # 红色前景     call colored_puts     .string \"\\rBad read\\r\"     jmp error_done  no_boot_partition:     mov $0x06, %bl      # 棕色/黄色前景     call colored_puts     .string \"\\rNot found\\r\"  error_done:     int $0x18  colored_puts:     # 类似 puts，但使用 BL 中的颜色     # INT 10h, AH=0Eh 的 BL 参数指定颜色     ...       颜色代码（前景色）：            0x00: 黑色       0x01: 蓝色       0x02: 绿色       0x04: 红色       0x07: 白色       0x0C: 亮红色       0x0E: 黄色           挑战：这需要额外的代码空间，可能超出 512 字节限制。        点击查看答案 2       int $0x18 之后没有 hlt 指令的原因：             假设 INT 18h 不返回：                    大多数 BIOS 会接管系统           尝试其他启动设备或显示错误           不会返回到调用者                       节省代码空间：                    hlt 指令需要 1 字节           如果真的需要无限循环，需要更多字节：             hang:   cli     # 1 字节   hlt     # 1 字节   jmp hang # 2 字节                       总共 4 字节                       即使返回也不危险：                    如果 INT 18h 返回，执行会继续到下一条指令           下一条可能是 puts 函数或其他代码           最坏情况是执行一些无害的代码然后崩溃           不会造成数据损坏                       实际风险：                    现代 BIOS 几乎都会接管           只有非常老的系统可能返回           那种情况下，系统本来就无法正常工作                             点击查看答案 3       在 QEMU 中排查 “Not found” 错误的步骤：             检查磁盘镜像是否正确创建：         ls -la *.dsk file pintos.dsk                       查看分区表：         fdisk -l pintos.dsk # 或 parted pintos.dsk print                       验证分区类型：         # 查看 MBR 的分区表区域 xxd -s 446 -l 64 pintos.dsk # 检查偏移 4（分区类型）是否为 0x20                       验证启动标志：         # 第一个字节应该是 0x80 xxd -s 446 -l 1 pintos.dsk                       验证 MBR 签名：         xxd -s 510 -l 2 pintos.dsk # 应该显示 55 aa                       检查 QEMU 命令行：         # 确保正确指定硬盘 qemu-system-i386 -hda pintos.dsk ...                       使用 QEMU 监视器调试：         (qemu) info block (qemu) x /16xb 0x7dbe                             点击查看答案 4       不增加代码大小提供更多错误信息的方法：             使用不同数量的字符：         # 1 个 'E' = 读取错误 read_failed:     call putc     mov $'E', %al     jmp error_done  # 2 个 'E' = 找不到分区 no_boot_partition:     mov $'E', %al     call putc     call putc  error_done:     int $0x18               使用不同字符：                    ‘R’ = Read error           ‘N’ = Not found           ‘D’ = Drive error                       使用蜂鸣器：         # 不同次数的蜂鸣表示不同错误 mov $0x0e07, %ax    # 蜂鸣字符 int $0x10               使用数字代码：         # 打印 \"E1\", \"E2\", \"E3\" 等 call puts .string \"E\" mov $'1', %al       # 或 '2', '3' call putc               利用现有输出：                    观察打印了多少硬盘/分区名称           “hda1234 hdb” 意味着在 hdb 的第一个分区出错           这已经提供了一定的错误定位信息                              下一部分  接下来我们分析 puts 辅助函数——一个非常巧妙的字符串打印实现。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（五）：跳转到内核",
    "url": "/posts/pintos-loader-05-jump-to-kernel/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  内核已经加载到内存中，现在是引导加载程序的最后一步：将控制权交给内核。这涉及到从 ELF 头读取入口地址，并执行跳转。    原始代码  #### Transfer control to the kernel that we loaded.  We read the start #### address out of the ELF header (see [ELF1]) and convert it from a #### 32-bit linear address into a 16:16 segment:offset address for #### real mode, then jump to the converted address.  The 80x86 doesn't #### have an instruction to jump to an absolute segment:offset kept in #### registers, so in fact we store the address in a temporary memory #### location, then jump indirectly through that location.  To save 4 #### bytes in the loader, we reuse 4 bytes of the loader's code for #### this temporary pointer.  \tmov $0x2000, %ax \tmov %ax, %es \tmov %es:0x18, %dx \tmov %dx, start \tmovw $0x2000, start + 2 \tljmp *start     前置知识  ELF 头部结构  ELF 文件的开头是一个固定格式的头部：  偏移    大小    字段名           说明 ──────────────────────────────────────────── 0x00    4      e_ident[0-3]     魔数 \"\\x7FELF\" 0x04    1      e_ident[4]       类别（32位/64位） 0x05    1      e_ident[5]       字节序（小端/大端） 0x06    1      e_ident[6]       ELF 版本 0x07    9      e_ident[7-15]    填充 0x10    2      e_type           文件类型 0x12    2      e_machine        目标架构 0x14    4      e_version        ELF 版本 0x18    4      e_entry          入口点地址 ← 我们要读这个！ 0x1C    4      e_phoff          程序头表偏移 0x20    4      e_shoff          节头表偏移 ...   入口点地址（e_entry）位于偏移 0x18，是一个 32 位地址，告诉系统从哪里开始执行程序。  远跳转（Far Jump）  在 x86 实模式中，有两种跳转：     近跳转（Near Jump）：只改变 IP，在当前代码段内跳转   远跳转（Far Jump）：同时改变 CS 和 IP，可以跳转到任何地址   近跳转：            远跳转： jmp label          ljmp segment:offset 只修改 IP          修改 CS 和 IP   间接跳转  x86 的 ljmp（远跳转）指令不能直接从寄存器获取地址，必须通过内存：  # 错误：不能这样做 ljmp %ax:%dx        # 语法错误！  # 正确：通过内存间接跳转 ljmp *memory_address   内存中的格式：  memory_address:     [偏移低字节] [偏移高字节] [段低字节] [段高字节]                     ←─── 偏移（2字节）────→ ←── 段（2字节）──→     逐行详解  第 1-2 行：设置 ES 指向内核  \tmov $0x2000, %ax \tmov %ax, %es   将 ES 设置为 0x2000，这样 ES:0x18 就指向内核 ELF 头的入口地址字段。  地址计算：    ES = 0x2000   物理地址 = 0x2000 × 16 + 0x18 = 0x20018     第 3 行：读取入口地址  \tmov %es:0x18, %dx   从 ELF 头偏移 0x18 处读取入口地址的低 16 位到 DX。  为什么只读低 16 位？  Pintos 内核的入口地址在实模式下可以用 16:16 的段:偏移表示。入口地址的低 16 位就是偏移部分。  Pintos 内核的入口地址：  内核加载到 0x20000，入口地址通常在这附近。假设入口地址是 0x20000：    段 = 0x2000   偏移 = 0x0000     第 4 行：存储偏移部分  \tmov %dx, start   将 DX（偏移）存储到 start 标签处。  start 在哪里？  read_failed: start: \t# Disk sector read failed. \tcall puts 1:\t.string \"\\rBad read\\r\"   start 和 read_failed 是同一个位置！这是一个巧妙的代码复用：    如果读取失败，会执行这里的错误处理代码   如果读取成功，这里的代码会被跳转地址覆盖     第 5 行：存储段部分  \tmovw $0x2000, start + 2   将段地址 0x2000 存储到 start + 2 处（偏移之后的 2 个字节）。  内存布局：  start:      [偏移低] [偏移高] [段低] [段高]             └── DX ──┘     └─0x2000─┘     第 6 行：远跳转到内核  \tljmp *start   执行间接远跳转，从 start 处读取 4 字节的段:偏移地址，然后跳转。  执行过程：     从 start 读取 4 字节   低 2 字节 → IP（指令指针）   高 2 字节 → CS（代码段）   跳转到 CS:IP     地址转换详解  32 位线性地址到 16:16 段:偏移  假设 ELF 入口地址是 0x00020000：  32位线性地址: 0x00020000  转换为 16:16 格式: 段地址 = 0x2000 偏移   = 0x0000  验证: 0x2000 × 16 + 0x0000 = 0x20000 ✓   但代码中只读了低 16 位？  对于 Pintos，段地址总是 0x2000（内核加载地址除以 16），偏移是入口地址减去 0x20000 后的值。  由于内核入口通常在文件开头附近，偏移值很小，16 位足够。  更复杂的例子  如果入口地址是 0x00020100：  线性地址: 0x00020100  转换: - 基址: 0x20000（段 0x2000） - 偏移: 0x00020100 - 0x00020000 = 0x0100  段:偏移 = 0x2000:0x0100     代码复用技巧详解  这段代码的一个亮点是代码复用：  read_failed: start: \tcall puts 1:\t.string \"\\rBad read\\r\"   如果读取失败：    跳转到 read_failed   执行 call puts 打印错误信息   如果读取成功：    mov %dx, start 覆盖了 call puts 的操作码   movw $0x2000, start + 2 覆盖了更多字节   ljmp *start 从被覆盖的位置读取跳转地址   内存变化：  原始代码（read_failed）: start:   E8 xx xx    (call puts 的机器码) start+3: ...         (字符串地址)  覆盖后: start:   [偏移低] [偏移高] [段低] [段高]          被解释为跳转地址   这样节省了 4 字节的存储空间——在 512 字节限制下非常宝贵！    跳转后的状态  执行 ljmp *start 后：                 寄存器/内存       值       说明                       CS       0x2000       代码段指向内核                 IP       入口偏移       从 ELF 头读取                 DS       0x0000       数据段（未改变）                 SS       0x0000       栈段（未改变）                 ESP       ~0xF000       栈指针（基本未变）                 DL       启动硬盘号       内核可以使用                 0x20000+       内核代码       已加载的内核           内核（start.S）从这里接管！    跳转目标：start.S  Loader 跳转后，控制权交给 start.S，它的任务是：     设置保护模式的 GDT   切换到 32 位保护模式   设置 32 位栈   跳转到 C 语言的 main() 函数   这是下一阶段的引导过程，超出了 loader.S 的范围。    为什么需要这么复杂？  问题 1：x86 没有直接的远跳转指令  # 我们想做的： ljmp $0x2000, %dx       # 错误！语法不支持  # 我们必须做的： mov %dx, memory         # 存储偏移 movw $0x2000, memory+2  # 存储段 ljmp *memory            # 间接跳转   问题 2：空间限制  引导扇区只有 512 字节，必须节省空间：    不能单独分配 4 字节存储跳转地址   复用 read_failed 代码的位置     执行流程图  flowchart TD     A[\"内核已加载到 0x20000\"] --&gt; B[\"ES = 0x2000&lt;br/&gt;指向内核 ELF 头\"]     B --&gt; C[\"DX = ES:0x18&lt;br/&gt;读取入口地址偏移\"]     C --&gt; D[\"存储到 start:&lt;br/&gt;[偏移] [0x2000]\"]     D --&gt; E[\"ljmp *start&lt;br/&gt;跳转到 0x2000:偏移\"]     E --&gt; F[\"现在执行内核代码&lt;br/&gt;(start.S)\"]     常见问题  Q1: 为什么段地址是 0x2000 而不是从 ELF 头读取？  简化！Pintos loader 假设：    内核总是加载到 0x20000   入口地址在 0x20000 附近   段地址固定为 0x2000，只需读取偏移   Q2: 如果入口地址不在 0x20000-0x2FFFF 范围内会怎样？  会出错！但 Pintos 的构建系统保证内核入口在这个范围内。  Q3: 为什么要用 16:16 段:偏移而不是直接用 32 位地址？  因为 CPU 还在实模式！实模式只能用段:偏移寻址。切换到保护模式后才能用 32 位线性地址。  Q4: 跳转后 loader 的代码还在内存中吗？  是的，但已经不再执行。内存 0x7C00-0x7DFF 的内容仍然存在，直到被覆盖。    机器码分析  让我们看看 ljmp *start 的机器码：  操作码: FF 2E xx xx         │  │  └──┴── start 的地址（2 字节）         │  └─────── ModR/M 字节（/5 = 间接远跳转）         └────────── 操作码前缀   这条指令告诉 CPU：    从指定内存地址读取 4 字节   低 2 字节作为新 IP   高 2 字节作为新 CS   跳转到 CS:IP     练习思考          如果 ELF 入口地址是 0x00030000（超出 0x2000 段的范围），会发生什么？           为什么不直接 jmp $0x20000 跳转到内核开头？（提示：ELF 文件的开头是什么？）           如果要支持入口地址在任意位置，需要如何修改代码？           代码复用技巧有什么潜在风险？        练习答案   点击查看答案 1       如果 ELF 入口地址是 0x00030000，代码会出错：             当前代码的计算：         mov %es:0x18, %dx     # DX = 入口地址低 16 位 = 0x0000 movw $0x2000, start+2 # 段 = 0x2000                     最终跳转到 0x2000:0x0000 = 0x20000           错误！应该跳转到 0x30000                       问题原因：                    代码假设段地址固定为 0x2000           只读取偏移部分（低 16 位）           0x30000 需要段 0x3000，但代码使用 0x2000                       正确做法：         # 完整的地址转换 mov %es:0x18, %eax    # 读取完整 32 位入口地址 shr $4, %eax          # 除以 16 得到段 mov %ax, start+2      # 存储段 mov %es:0x18, %ax     # 读取低 16 位 and $0xF, %ax         # 取低 4 位作为偏移 mov %ax, start        # 存储偏移               Pintos 的假设：                    内核入口总在 0x20000 附近           构建系统保证这一点                             点击查看答案 2       不能直接跳转到 0x20000 的原因是 ELF 文件的开头不是可执行代码！             ELF 文件开头的内容：         偏移 0x00-0x03: 魔数 \"\\x7FELF\" 偏移 0x04-0x0F: ELF 头标识信息 偏移 0x10-0x17: 文件类型、架构等 偏移 0x18-0x1B: 入口点地址 (e_entry) ...                       如果直接 jmp 0x20000：                    CPU 会尝试执行 7F 45 4C 46（”\\x7FELF” 的字节）           这不是有效的指令           会导致崩溃或未定义行为                       必须读取入口地址：                    ELF 头的 e_entry 字段（偏移 0x18）告诉我们从哪里开始执行           入口地址指向 .text 段的 _start 或 start 函数           这才是真正的可执行代码                       类比：                    就像打开一本书，不能从封面开始读正文           需要先看目录（ELF 头）找到第一章的位置                             点击查看答案 3       支持任意入口地址需要完整的地址转换：      # 假设 ES:0x18 包含 32 位入口地址 mov $0x2000, %ax mov %ax, %es  # 读取完整的 32 位地址 mov %es:0x18, %eax  # 转换为 段:偏移 格式 # 段 = 地址 / 16 # 偏移 = 地址 % 16 mov %eax, %ebx and $0xF, %ebx        # EBX = 偏移 (低 4 位) shr $4, %eax          # EAX = 段 (右移 4 位)  # 存储跳转地址 mov %bx, start        # 偏移 mov %ax, start+2      # 段  ljmp *start       注意事项：            这需要更多代码空间       仍然受限于实模式的 1MB 地址空间       超过 1MB 需要 A20 门和/或切换到保护模式             点击查看答案 4       代码复用技巧（将跳转地址写入错误处理代码位置）的潜在风险：             维护困难：                    代码功能不明显           新开发者可能不理解为什么 start 和 read_failed 是同一位置           修改时容易引入 bug                       脆弱性：                    如果错误处理代码的大小改变，可能破坏跳转           如果 call puts 的机器码长度改变，覆盖位置可能错误           依赖于特定的代码布局                       调试困难：                    单步执行时，跳转地址可能显示为错误处理代码的地址           反汇编器可能无法正确解析                       不可扩展：                    如果需要更多存储空间（比如 6 字节），技巧可能失效           依赖于当前正好需要 4 字节                       安全性：                    在现代系统中，自修改代码可能触发安全保护           好在引导加载程序运行在没有保护的环境中                           权衡：在 512 字节限制下，这种技巧是合理的；在空间充裕的情况下，应该使用更清晰的代码。         下一部分  接下来我们分析错误处理代码。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（四）：加载内核",
    "url": "/posts/pintos-loader-04-load-kernel/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  找到 Pintos 内核分区后，这部分代码负责将内核从磁盘读取到内存中。这是引导加载程序最重要的工作之一。    原始代码  #### We found a kernel.  The kernel's drive is in DL.  The partition #### table entry for the kernel's partition is at ES:SI.  Our job now #### is to read the kernel from disk and jump to its start address.  load_kernel: \tcall puts \t.string \"\\rLoading\"  \t# Figure out number of sectors to read.  A Pintos kernel is \t# just an ELF format object, which doesn't have an \t# easy-to-read field to identify its own size (see [ELF1]). \t# But we limit Pintos kernels to 512 kB for other reasons, so \t# it's easy enough to just read the entire contents of the \t# partition or 512 kB from disk, whichever is smaller. \tmov %es:12(%si), %ecx\t\t# EBP = number of sectors \tcmp $1024, %ecx\t\t\t# Cap size at 512 kB \tjbe 1f \tmov $1024, %cx 1:  \tmov %es:8(%si), %ebx\t\t# EBX = first sector \tmov $0x2000, %ax\t\t# Start load address: 0x20000  next_sector: \t# Read one sector into memory. \tmov %ax, %es\t\t\t# ES:0000 -&gt; load address \tcall read_sector \tjc read_failed  \t# Print '.' as progress indicator once every 16 sectors == 8 kB. \ttest $15, %bl \tjnz 1f \tcall puts \t.string \".\" 1:  \t# Advance memory pointer and disk sector. \tadd $0x20, %ax \tinc %bx \tloop next_sector  \tcall puts \t.string \"\\r\"     前置知识  什么是 ELF 格式？  ELF（Executable and Linkable Format）是 Linux/Unix 系统上最常用的可执行文件格式。Pintos 内核就是一个 ELF 文件。  ELF 文件的基本结构：  ┌─────────────────────────┐ │      ELF 头部           │ ← 包含入口地址、程序头表位置等 ├─────────────────────────┤ │     程序头表            │ ← 描述各段如何加载到内存 ├─────────────────────────┤ │                         │ │     代码段 (.text)      │ ← 可执行指令 │                         │ ├─────────────────────────┤ │                         │ │     数据段 (.data)      │ ← 初始化的全局变量 │                         │ ├─────────────────────────┤ │     其他段...           │ └─────────────────────────┘   为什么限制内核大小为 512KB？     实模式内存限制：在实模式下，只能访问 1MB 内存   加载地址：内核加载到 0x20000（128KB），到 640KB（0xA0000）有约 512KB 空间   简化代码：限制大小可以避免复杂的内存管理   内存布局  地址              内容 ─────────────────────────────────── 0x00000          中断向量表、BIOS 数据 ... 0x07C00          Loader 代码 0x07E00          Loader 结束 ... 0x20000  ←────── 内核加载起始地址 ... 0xA0000  ←────── 内核加载结束地址（最大） ... 0xA0000-0xFFFFF  显存和 BIOS ROM     逐行详解  阶段 1：打印加载信息  load_kernel: \tcall puts \t.string \"\\rLoading\"   打印 “Loading”，告诉用户内核正在加载。  \\r（回车符）将光标移动到行首，覆盖之前的 “Pintos hdaX” 输出。    阶段 2：计算要读取的扇区数  \tmov %es:12(%si), %ecx\t\t# ECX = number of sectors \tcmp $1024, %ecx\t\t\t# Cap size at 512 kB \tjbe 1f \tmov $1024, %cx 1:   逐行解释：     mov %es:12(%si), %ecx：            从分区表项偏移 12 处读取 4 字节（扇区数）       存入 ECX 寄存器           回顾分区表项结构：     偏移 0:  启动标志 偏移 4:  分区类型 偏移 8:  起始 LBA（4 字节） 偏移 12: 扇区总数（4 字节）← 我们读取这里           cmp $1024, %ecx：            比较 ECX 和 1024       1024 扇区 × 512 字节/扇区 = 512KB           jbe 1f：            jbe = Jump if Below or Equal（无符号小于等于则跳转）       1f = 向前（forward）找标签 1:       如果扇区数 ≤ 1024，跳过下一条指令           mov $1024, %cx：            如果扇区数 &gt; 1024，将其限制为 1024       注意这里只修改 CX（16 位），高 16 位被清零，但没关系因为 1024 足够用 16 位表示           为什么要限制大小？     保护内存：防止覆盖 640KB 以上的系统区域   简化循环：loop 指令使用 CX，16 位足够     阶段 3：获取起始扇区号  \tmov %es:8(%si), %ebx\t\t# EBX = first sector \tmov $0x2000, %ax\t\t# Start load address: 0x20000      mov %es:8(%si), %ebx：            从分区表项偏移 8 处读取起始 LBA       这是内核在磁盘上的第一个扇区           mov $0x2000, %ax：            设置加载地址的段部分       段地址 0x2000 × 16 = 线性地址 0x20000             阶段 4：读取扇区循环  next_sector: \t# Read one sector into memory. \tmov %ax, %es\t\t\t# ES:0000 -&gt; load address \tcall read_sector \tjc read_failed   循环开始：     mov %ax, %es：设置 ES 段寄存器为当前加载地址   call read_sector：读取一个扇区到 ES:0000            DL = 硬盘号（在整个过程中保持不变）       EBX = 扇区号       ES:0 = 目标内存地址           jc read_failed：如果读取失败（CF=1），跳转到错误处理     阶段 5：显示进度  \t# Print '.' as progress indicator once every 16 sectors == 8 kB. \ttest $15, %bl \tjnz 1f \tcall puts \t.string \".\" 1:   每 16 个扇区打印一个点。     test $15, %bl：            测试 BL 的低 4 位是否为 0       test 指令执行 AND 运算，只设置标志位，不保存结果       15 = 0b1111 = 0xF           jnz 1f：            jnz = Jump if Not Zero（如果结果不为零则跳转）       如果 BL &amp; 0xF ≠ 0，跳过打印           为什么是 16 扇区？     16 扇区 × 512 字节 = 8KB   512KB 内核 / 8KB = 64 个点   这样可以显示合理的进度，不会太快也不会太慢   test 指令详解：                 BL 值       BL &amp; 15       结果                       0       0 &amp; 15 = 0       打印                 1       1 &amp; 15 = 1       不打印                 15       15 &amp; 15 = 15       不打印                 16       16 &amp; 15 = 0       打印                 32       32 &amp; 15 = 0       打印             阶段 6：前进到下一个扇区  \t# Advance memory pointer and disk sector. \tadd $0x20, %ax \tinc %bx \tloop next_sector      add $0x20, %ax：            内存地址增加 0x20 个段单位       0x20 × 16 = 512 字节 = 1 个扇区           inc %bx：            扇区号加 1           loop next_sector：            CX 减 1       如果 CX ≠ 0，跳转到 next_sector 继续循环       如果 CX = 0，循环结束           loop 指令的等效代码：  loop next_sector # 等价于： dec %cx jnz next_sector     阶段 7：完成加载  \tcall puts \t.string \"\\r\"   打印回车符，准备下一行输出。    内存变化示意图  加载过程中内存的变化：  初始状态：                     0x20000  0x20200  0x20400  ...                     ┌────────┬────────┬────────┬─── 内存:               │  空    │  空    │  空    │                     └────────┴────────┴────────┴───  读取扇区 0 后：                     ┌────────┬────────┬────────┬─── 内存:               │扇区 0  │  空    │  空    │                     └────────┴────────┴────────┴───                     ES=0x2000  读取扇区 1 后：                     ┌────────┬────────┬────────┬─── 内存:               │扇区 0  │扇区 1  │  空    │                     └────────┴────────┴────────┴───                              ES=0x2020  读取扇区 2 后：                     ┌────────┬────────┬────────┬─── 内存:               │扇区 0  │扇区 1  │扇区 2  │                     └────────┴────────┴────────┴───                                       ES=0x2040  ... 继续直到读完所有扇区 ...     加载地址计算示例  假设内核占 100 个扇区（约 50KB）：                 循环次数       CX       EBX (扇区)       AX (段)       ES:0 (线性地址)                       1       100       N       0x2000       0x20000                 2       99       N+1       0x2020       0x20200                 3       98       N+2       0x2040       0x20400                 …       …       …       …       …                 100       1       N+99       0x3260       0x32600                 结束       0       -       -       -           其中 N 是分区的起始扇区号。    实际输出示例  Loading..............................................................      “Loading” 后面跟着很多点   每个点代表 8KB 已加载   如果内核是 256KB，会有 32 个点     常见问题  Q1: 如果分区比 512KB 小会怎样？  代码只读取分区实际包含的扇区数。假设分区只有 100 扇区（50KB），就只读取 100 扇区。  Q2: 为什么段地址每次增加 0x20？  在实模式下：    物理地址 = 段地址 × 16 + 偏移   一个扇区 = 512 字节   段地址增加 0x20 意味着物理地址增加 0x20 × 16 = 512 字节   Q3: 为什么使用 16 位的 BX 而不是 32 位的 EBX？  实际上代码用 inc %bx 只增加 BX 的低 16 位。对于小于 32MB 的分区（64K 扇区），这足够了。Pintos 的设计假设不会有这么大的分区。  Q4: 读取失败的原因有哪些？     硬盘物理故障   扇区号超出范围   BIOS 驱动问题   模拟器配置错误   Q5: 为什么注释说 ECX = EBP？  这是代码中的一个注释错误。应该是 “ECX = number of sectors”，不是 EBP。代码本身是正确的。    性能考虑  每次只读一个扇区是否低效？  是的，但有几个原因：     简单性：代码更简单，更可靠   512 字节限制：引导扇区空间有限   兼容性：某些老 BIOS 每次只能读有限扇区   现代引导加载程序（如 GRUB）会使用更高效的多扇区读取。  加载时间估算  假设：    硬盘读取速度：50MB/s   内核大小：512KB   加载时间 ≈ 512KB / 50MB/s ≈ 10ms  实际上大部分时间花在 BIOS 中断调用的开销上，但对于启动过程来说仍然很快。    练习思考          如果要支持大于 512KB 的内核，需要修改哪些地方？           为什么进度显示选择每 16 扇区一个点，而不是每 8 扇区或每 32 扇区？           如果内核恰好是 0 字节（空分区），这段代码会发生什么？           loop 指令只检查 CX（16 位），如果需要读取超过 65535 个扇区怎么办？        练习答案   点击查看答案 1       支持大于 512KB 的内核需要修改以下地方：             修改大小限制：         cmp $1024, %ecx      # 原来：512KB = 1024 扇区 # 改为： cmp $2048, %ecx      # 1MB = 2048 扇区               考虑内存布局问题：                    0x20000 到 0xA0000（640KB 边界）只有约 512KB           要加载更大的内核，需要：                            使用高端内存（需要 A20 门控）               或切换到保护模式后再加载               或分段加载（先加载一部分，跳转后再加载剩余）                                               可能需要启用 A20 门：         # A20 门控代码（允许访问 1MB 以上内存） in $0x92, %al or $2, %al out %al, $0x92               代码空间限制：                    这些修改可能超出 512 字节限制           可能需要两阶段引导                             点击查看答案 2       选择每 16 扇区（8KB）一个点的原因：             视觉效果：                    512KB 内核 ÷ 8KB = 64 个点           64 个点在一行内显示效果好（80 列屏幕）           不会太少（看不到进度）也不会太多（刷屏）                       如果每 8 扇区（4KB）一个点：                    512KB ÷ 4KB = 128 个点           超过一行，需要换行或滚屏           视觉上太密集                       如果每 32 扇区（16KB）一个点：                    512KB ÷ 16KB = 32 个点           可能太稀疏，进度感不强           但也是可行的选择                       代码简洁性：                    test $15, %bl 检查低 4 位是否为 0           15 = 0xF = 0b1111           恰好对应 16 的倍数           非常简洁的位操作                             点击查看答案 3       如果内核是 0 字节（ECX = 0），代码行为如下：             loop 指令的行为：                    loop 先将 CX 减 1           如果 CX = 0，减 1 后变成 0xFFFF（下溢）           CX ≠ 0，所以会继续循环！                       结果：                    会读取 65535 个扇区（约 32MB）           这会覆盖大量内存           可能读取超出磁盘的扇区，导致错误                       这是一个潜在的 bug：                    应该在循环前检查 CX 是否为 0           可以添加：             test %cx, %cx jz load_done      # CX = 0，跳过循环                                   实际情况：                    Pintos 的分区创建工具不会创建空分区           所以这种情况在实践中不会发生           但从代码健壮性角度，应该处理                             点击查看答案 4       如果需要读取超过 65535 个扇区（约 32MB），需要修改循环逻辑：             问题分析：                    loop 指令只使用 CX（16 位）           最多循环 65535 次           65535 × 512B ≈ 32MB                       解决方案 1：使用 32 位计数器         next_sector:     # ... 读取扇区 ...     dec %ecx            # 32 位递减     jnz next_sector     # 不用 loop，用 jnz               解决方案 2：嵌套循环         # 假设 ECX 中有扇区总数 mov %ecx, %edx      # 保存高 16 位 shr $16, %edx outer_loop:     mov $0xFFFF, %cx inner_loop:     # ... 读取扇区 ...     loop inner_loop     dec %dx     jnz outer_loop               实际考虑：                    在实模式下很难访问超过 1MB 内存           需要切换到保护模式或使用 Unreal Mode           Pintos 限制内核为 512KB，不需要这个优化                              下一部分  内核加载到内存后，下一步是跳转到内核入口点执行。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（三）：扫描硬盘分区",
    "url": "/posts/pintos-loader-03-scan-partitions/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  这是引导加载程序中最复杂的部分。它的任务是扫描系统中所有硬盘的分区表，找到包含 Pintos 内核的可启动分区。    原始代码  #### Read the partition table on each system hard disk and scan for a #### partition of type 0x20, which is the type that we use for a #### Pintos kernel.  \tmov $0x80, %dl\t\t\t# Hard disk 0. read_mbr: \tsub %ebx, %ebx\t\t\t# Sector 0. \tmov $0x2000, %ax\t\t# Use 0x20000 for buffer. \tmov %ax, %es \tcall read_sector \tjc no_such_drive  \t# Print hd[a-z]. \tcall puts \t.string \" hd\" \tmov %dl, %al \tadd $'a' - 0x80, %al \tcall putc  \t# Check for MBR signature--if not present, it's not a \t# partitioned hard disk. \tcmpw $0xaa55, %es:510 \tjne next_drive  \tmov $446, %si\t\t\t# Offset of partition table entry 1. \tmov $'1', %al check_partition: \t# Is it an unused partition? \tcmpl $0, %es:(%si) \tje next_partition  \t# Print [1-4]. \tcall putc  \t# Is it a Pintos kernel partition? \tcmpb $0x20, %es:4(%si) \tjne next_partition  \t# Is it a bootable partition? \tcmpb $0x80, %es:(%si) \tje load_kernel  next_partition: \t# No match for this partition, go on to the next one. \tadd $16, %si\t\t\t# Offset to next partition table entry. \tinc %al \tcmp $510, %si \tjb check_partition  next_drive: \t# No match on this drive, go on to the next one. \tinc %dl \tjnc read_mbr  no_such_drive: no_boot_partition: \t# Didn't find a Pintos kernel partition anywhere, give up. \tcall puts \t.string \"\\rNot found\\r\"  \t# Notify BIOS that boot failed.  See [IntrList]. \tint $0x18     前置知识  硬盘的基本结构  硬盘由多个扇区（Sector）组成，每个扇区通常是 512 字节。  硬盘结构： ┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐ │ 扇区 0  │ 扇区 1  │ 扇区 2  │ 扇区 3  │   ...   │ 扇区 N  │ │  (MBR)  │         │         │         │         │         │ └─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘   什么是 MBR（主引导记录）？  MBR 是硬盘的第一个扇区（扇区 0），大小 512 字节，包含：  MBR 结构（512 字节）： ┌───────────────────────────────────────┐ 偏移 0 │                                       │ │          引导代码区                    │ │        （446 字节）                    │ │                                       │ ├───────────────────────────────────────┤ 偏移 446 │          分区表项 1（16 字节）         │ ├───────────────────────────────────────┤ 偏移 462 │          分区表项 2（16 字节）         │ ├───────────────────────────────────────┤ 偏移 478 │          分区表项 3（16 字节）         │ ├───────────────────────────────────────┤ 偏移 494 │          分区表项 4（16 字节）         │ ├───────────────────────────────────────┤ 偏移 510 │       启动签名 0xAA55（2 字节）        │ └───────────────────────────────────────┘ 偏移 512   分区表项结构  每个分区表项 16 字节：                 偏移       大小       内容       说明                       0       1       启动标志       0x80=可启动, 0x00=不可启动                 1       1       起始磁头       CHS 寻址（已过时）                 2       2       起始扇区/柱面       CHS 寻址（已过时）                 4       1       分区类型       标识分区内容类型                 5       1       结束磁头       CHS 寻址（已过时）                 6       2       结束扇区/柱面       CHS 寻址（已过时）                 8       4       起始 LBA       分区起始扇区号                 12       4       扇区总数       分区包含的扇区数           常见分区类型                 类型码       含义                       0x00       空/未使用                 0x01       FAT12                 0x04       FAT16 (&lt; 32MB)                 0x05       扩展分区                 0x06       FAT16 (&gt; 32MB)                 0x07       NTFS / exFAT                 0x0B       FAT32 (CHS)                 0x0C       FAT32 (LBA)                 0x0F       扩展分区 (LBA)                 0x20       Pintos 内核                 0x82       Linux swap                 0x83       Linux 文件系统           BIOS 硬盘编号                 编号       设备                       0x00-0x7F       软盘（0x00=A:, 0x01=B:）                 0x80       第一个硬盘                 0x81       第二个硬盘                 …       更多硬盘             逐行详解  阶段 1：开始扫描第一个硬盘  mov $0x80, %dl\t\t\t# Hard disk 0.   将 DL 设置为 0x80，表示第一个硬盘。    阶段 2：读取 MBR  read_mbr: \tsub %ebx, %ebx\t\t\t# Sector 0. \tmov $0x2000, %ax\t\t# Use 0x20000 for buffer. \tmov %ax, %es \tcall read_sector \tjc no_such_drive   逐行解释：          sub %ebx, %ebx：EBX = 0，表示要读取扇区 0（MBR）      mov $0x2000, %ax 和 mov %ax, %es：            设置 ES = 0x2000       实际缓冲区地址 = ES × 16 + 0 = 0x2000 × 16 = 0x20000           call read_sector：调用扇区读取函数（稍后详解）            DL = 硬盘号       EBX = 扇区号       ES:0 = 缓冲区地址           jc no_such_drive：            jc = Jump if Carry（如果进位标志为 1 则跳转）       read_sector 在出错时设置进位标志       如果读取失败（比如硬盘不存在），跳转到错误处理             阶段 3：打印硬盘标识  \t# Print hd[a-z]. \tcall puts \t.string \" hd\" \tmov %dl, %al \tadd $'a' - 0x80, %al \tcall putc   这段代码打印类似 “ hda”、” hdb” 的硬盘名称。  计算过程：  DL = 0x80（第一个硬盘） AL = DL = 0x80 AL = AL + ('a' - 0x80) AL = 0x80 + (0x61 - 0x80) AL = 0x80 + (-0x1F) AL = 0x61 = 'a'   所以：    0x80 → ‘a’（hda）   0x81 → ‘b’（hdb）   0x82 → ‘c’（hdc）   …     阶段 4：验证 MBR 签名  \t# Check for MBR signature--if not present, it's not a \t# partitioned hard disk. \tcmpw $0xaa55, %es:510 \tjne next_drive   这是什么？  检查 MBR 最后两个字节是否为 0xAA55。  cmpw $0xaa55, %es:510 解释：     cmpw：比较字（16 位 / 2 字节）   $0xaa55：立即数 0xAA55   %es:510：ES 段偏移 510 处的内存（即 0x20000 + 510）   为什么是 0xAA55？  这是 BIOS 定义的”有效引导扇区”签名。如果没有这个签名，说明这不是一个有效的分区表。  字节顺序（小端序）：  内存地址:  510    511 内容:      0x55   0xAA  作为 16 位字读取: 0xAA55（低字节在前）     阶段 5：遍历分区表  \tmov $446, %si\t\t\t# Offset of partition table entry 1. \tmov $'1', %al      SI = 446，指向第一个分区表项   AL = ‘1’，用于打印分区号     阶段 6：检查每个分区  check_partition: \t# Is it an unused partition? \tcmpl $0, %es:(%si) \tje next_partition   检查分区表项的第一个双字（4 字节）是否为 0。如果是 0，说明这个分区未使用。  \t# Print [1-4]. \tcall putc   打印当前分区号（’1’、’2’、’3’ 或 ‘4’）。  \t# Is it a Pintos kernel partition? \tcmpb $0x20, %es:4(%si) \tjne next_partition   检查偏移 4 处的分区类型是否为 0x20（Pintos 内核）。     cmpb：比较字节（8 位）   %es:4(%si)：ES 段 + SI + 4 处的字节   \t# Is it a bootable partition? \tcmpb $0x80, %es:(%si) \tje load_kernel   检查启动标志是否为 0x80（可启动）。如果是，跳转到加载内核的代码。  分区表项内存布局：  %es:(%si)     → 启动标志（0x80 = 可启动） %es:1(%si)    → 起始 CHS %es:4(%si)    → 分区类型（0x20 = Pintos） %es:8(%si)    → 起始 LBA（4 字节） %es:12(%si)   → 扇区数（4 字节）     阶段 7：移动到下一个分区  next_partition: \t# No match for this partition, go on to the next one. \tadd $16, %si\t\t\t# Offset to next partition table entry. \tinc %al \tcmp $510, %si \tjb check_partition      add $16, %si：每个分区表项 16 字节，移动到下一个   inc %al：分区号加 1（’1’ → ‘2’ → ‘3’ → ‘4’）   cmp $510, %si：检查是否超过分区表范围            分区表：446 到 509（共 64 字节 = 4 × 16）       510 是签名位置           jb：Jump if Below（无符号小于则跳转）     阶段 8：移动到下一个硬盘  next_drive: \t# No match on this drive, go on to the next one. \tinc %dl \tjnc read_mbr      inc %dl：硬盘号加 1（0x80 → 0x81 → …）   jnc：Jump if No Carry（如果没有进位则跳转）            当 DL 从 0xFF 变成 0x00 时会产生进位       这意味着我们已经检查完所有可能的硬盘号             阶段 9：错误处理  no_such_drive: no_boot_partition: \t# Didn't find a Pintos kernel partition anywhere, give up. \tcall puts \t.string \"\\rNot found\\r\"  \t# Notify BIOS that boot failed.  See [IntrList]. \tint $0x18   如果找不到 Pintos 内核分区：    打印错误信息 “Not found”   调用 INT 18h 通知 BIOS 启动失败   INT 18h 的作用：  告诉 BIOS 当前设备启动失败，BIOS 可能会：    尝试从下一个启动设备启动   进入 BIOS 设置   显示 “No bootable device” 错误   \\r 的作用：  \\r 是回车符（Carriage Return），将光标移动到行首。这样 “Not found” 会覆盖之前打印的 “Pintos hdaX” 等信息。    执行流程图  flowchart TD     A[\"DL = 0x80&lt;br/&gt;(第一个硬盘)\"] --&gt; B[\"读取扇区 0 (MBR)\"]     B --&gt; C{读取成功?}     C --&gt;|失败| D[下一硬盘]     C --&gt;|成功| E[\"打印 'hdX'\"]     E --&gt; F{签名是 0xAA55?}     F --&gt;|否| D     F --&gt;|是| G[\"SI = 446&lt;br/&gt;(第一个分区表项)\"]     G --&gt; H{分区有效?&lt;br/&gt;第一字节 ≠ 0}     H --&gt;|否| L[SI += 16&lt;br/&gt;下一分区]     H --&gt;|是| I[打印分区号]     I --&gt; J{类型是 0x20?&lt;br/&gt;Pintos}     J --&gt;|否| L     J --&gt;|是| K{可启动 0x80?}     K --&gt;|否| L     K --&gt;|是| M[/\"找到了!&lt;br/&gt;加载内核\"/]     L --&gt; N{SI &lt; 510?}     N --&gt;|是| H     N --&gt;|否| D     D --&gt; O[\"DL += 1\"]     O --&gt; P{还有硬盘?}     P --&gt;|是| B     P --&gt;|否| Q[\"'Not found'&lt;br/&gt;INT 18h\"]     实际输出示例  成功找到内核  Pintos hda1234 Loading...   表示：    检查了 hda（第一个硬盘）   检查了分区 1、2、3、4   在某个分区找到了内核并开始加载   内核在第二个硬盘  Pintos hda1234 hdb12 Loading...   表示：    hda 的 4 个分区都不是 Pintos 内核   在 hdb 的分区 2 找到了内核   未找到内核  Pintos hda1234 hdb1234 Not found   表示：    检查了所有硬盘和分区   没有找到 Pintos 内核分区     常见问题  Q1: 为什么只支持 4 个分区？  MBR 分区表只有 64 字节空间，每个分区表项 16 字节，所以最多只能有 4 个主分区。  如果需要更多分区，可以使用扩展分区，但 Pintos 的引导加载程序不支持。  Q2: 为什么使用 0x20 作为 Pintos 分区类型？  0x20 是一个未被主流操作系统使用的分区类型码。Pintos 选择它来标识自己的内核分区，避免与其他系统冲突。  Q3: 如果有多个 Pintos 分区会怎样？  代码会使用找到的第一个可启动的 Pintos 分区（启动标志为 0x80）。  Q4: CHS 和 LBA 有什么区别？                 寻址方式       全称       说明                       CHS       Cylinder-Head-Sector       旧式寻址，限制约 8GB                 LBA       Logical Block Addressing       现代寻址，支持大硬盘           Pintos 使用 LBA 寻址，通过 BIOS 扩展读取功能（INT 13h, AH=42h）。    调试技巧  查看 MBR 内容  在 Linux 中可以用以下命令查看硬盘的 MBR：  sudo xxd -l 512 /dev/sda   查看分区表  sudo fdisk -l /dev/sda     练习思考          如果启动标志检查被删除（不检查 0x80），会有什么影响？           为什么要先检查分区是否有效（第一字节不为 0），再检查分区类型？           如果要支持超过 4 个主分区，需要如何修改代码？        练习答案   点击查看答案 1       如果删除启动标志检查（不检查 0x80），会有以下影响：             加载第一个找到的 Pintos 分区：                    无论该分区是否被标记为可启动           可能加载一个不想启动的备份分区                       失去选择能力：                    如果有多个 Pintos 分区，无法通过启动标志选择           管理员不能通过 fdisk 等工具控制启动哪个分区                       可能更方便：                    对于只有一个 Pintos 分区的情况，不需要设置启动标志           简化分区配置                           实际代码的检查：     cmpb $0x80, %es:(%si)    # 检查启动标志 je load_kernel           # 只有 0x80 才加载       如果删除这两行，会加载第一个类型为 0x20 的分区。        点击查看答案 2       先检查分区是否有效（第一字节不为 0）的原因：             效率优化：                    空分区（第一字节为 0）根本不需要进一步检查           跳过空分区可以加快扫描速度                       避免误判：                    空分区表项可能包含随机数据           类型字段可能恰好是 0x20（巧合）           先检查有效性避免加载无效分区                       逻辑正确性：                    分区表项格式：第一字节是启动标志（0x00 或 0x80）           如果整个表项为空（从 0x00 开始），说明未使用           有效分区的启动标志要么是 0x00（不可启动）要么是 0x80（可启动）                           实际代码：     cmpl $0, %es:(%si)       # 检查前 4 字节是否全为 0 je next_partition        # 空分区，跳过 # ... 后续检查分区类型         点击查看答案 3       支持超过 4 个主分区需要实现扩展分区支持：             理解扩展分区结构：                    扩展分区（类型 0x05 或 0x0F）包含扩展引导记录（EBR）链           每个 EBR 包含一个逻辑分区和指向下一个 EBR 的指针                       代码修改思路：         check_partition:     # ... 原有检查 ...     cmpb $0x05, %es:4(%si)  # 是扩展分区？     je scan_extended     cmpb $0x0f, %es:4(%si)  # 是 LBA 扩展分区？     je scan_extended     # ... 继续原有逻辑 ...  scan_extended:     # 读取扩展分区的第一个 EBR     mov %es:8(%si), %ebx    # 扩展分区起始 LBA     # 保存扩展分区起始位置     # 循环读取 EBR 链...               挑战：                    需要更多代码空间（512 字节可能不够）           EBR 链是递归结构，需要循环处理           需要保存状态（当前 EBR 位置、扩展分区起始等）                       实际解决方案：                    使用两阶段引导：第一阶段加载更大的第二阶段           或者使用 GRUB 等功能更强的引导加载程序                              下一部分  找到 Pintos 内核分区后，接下来要将内核加载到内存。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（二）：配置串口",
    "url": "/posts/pintos-loader-02-serial-port/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  这部分代码配置计算机的串行端口（Serial Port），使得我们可以通过串口输出调试信息。这在没有显示器的环境下（如模拟器、服务器）非常有用。    原始代码  # Configure serial port so we can report progress without connected VGA. # See [IntrList] for details. \tsub %dx, %dx\t\t\t# Serial port 0. \tmov $0xe3, %al\t\t\t# 9600 bps, N-8-1. \t\t\t\t\t# AH is already 0 (Initialize Port). \tint $0x14\t\t\t# Destroys AX.  \tcall puts \t.string \"Pintos\"     前置知识  什么是串口（Serial Port）？  串口是一种古老但非常可靠的通信接口。它按照串行方式传输数据——一次传输一个比特（bit）。      计算机 A                    计算机 B    ┌────────┐                 ┌────────┐    │        │  TX ──────► RX  │        │    │  串口  │                 │  串口  │    │        │  RX ◄────── TX  │        │    └────────┘                 └────────┘            GND ◄───────► GND      TX (Transmit)：发送线   RX (Receive)：接收线   GND (Ground)：地线   为什么在引导时使用串口？     VGA 可能不可用：在模拟器或服务器环境中，可能没有显示器   远程调试：可以通过串口连接到另一台电脑查看输出   日志记录：串口输出可以被重定向到文件   简单可靠：串口协议非常简单，不需要复杂的驱动   BIOS 串口服务（INT 14h）  BIOS 提供了串口操作的中断服务，通过 int $0x14 调用：                 AH 值       功能                       0x00       初始化串口                 0x01       发送字符                 0x02       接收字符                 0x03       获取串口状态             逐行详解  第 1 行：选择串口  sub %dx, %dx\t\t\t# Serial port 0.   这是什么？  将 DX 寄存器清零，选择串口 0（COM1）。  串口编号：                 DX 值       串口名称       I/O 地址                       0       COM1       0x3F8                 1       COM2       0x2F8                 2       COM3       0x3E8                 3       COM4       0x2E8           为什么用 sub %dx, %dx？  和前面一样，这比 mov $0, %dx 节省 1 字节。    第 2 行：设置串口参数  mov $0xe3, %al\t\t\t# 9600 bps, N-8-1.   这是什么？  将 0xE3 放入 AL 寄存器，这是串口初始化的参数。  0xE3 的含义（二进制：11100011）：    位 7-5: 波特率   ┌───┬───┬───┐   │ 1 │ 1 │ 1 │ = 111 = 9600 bps   └───┴───┴───┘      位 4-3: 奇偶校验   ┌───┬───┐   │ 0 │ 0 │ = 00 = None（无校验）   └───┴───┘      位 2: 停止位   ┌───┐   │ 0 │ = 1 个停止位   └───┘      位 1-0: 数据位   ┌───┬───┐   │ 1 │ 1 │ = 11 = 8 位数据   └───┴───┘   参数详解：                 参数       值       含义                       波特率       9600 bps       每秒传输 9600 比特                 奇偶校验       None       不进行校验                 数据位       8 位       每个字符 8 比特                 停止位       1 位       每帧结束用 1 个停止位           这种配置通常简写为 “9600 N-8-1” 或 “9600 8N1”。  串口通信帧格式：      ┌─────┬───────────────┬──────┬──────┐     │起始位│   8 位数据    │校验位│停止位│     │  0  │ D0 D1 ... D7  │ (无) │  1  │     └─────┴───────────────┴──────┴──────┘          时间 →   波特率选项表：                 位 7-5       波特率                       000       110                 001       150                 010       300                 011       600                 100       1200                 101       2400                 110       4800                 111       9600             第 3 行：注释说明  \t\t\t\t# AH is already 0 (Initialize Port).   这是什么？  这是一条注释，解释为什么没有显式设置 AH。  为什么 AH 已经是 0？  回顾前面的代码：  sub %ax, %ax    # 这行将整个 AX（包括 AH 和 AL）清零   AX 寄存器由两部分组成：      AX (16位) ┌───────┬───────┐ │  AH   │  AL   │ │ 高8位 │ 低8位 │ └───────┴───────┘   我们用 sub %ax, %ax 清零了整个 AX，所以 AH = 0。 然后 mov $0xe3, %al 只修改了 AL，AH 仍然是 0。  AH = 0 的意义：  对于 INT 14h，AH = 0 表示”初始化串口”功能。    第 4 行：调用 BIOS 中断  int $0x14\t\t\t# Destroys AX.   这是什么？  调用 BIOS 中断 0x14（串口服务）。  int 指令的作用：     将标志寄存器 FLAGS 压栈   将 CS（代码段）压栈   将 IP（指令指针）压栈   跳转到中断向量表中对应的处理程序   INT 14h, AH=00h（初始化串口）的参数：                 寄存器       作用                       AH       0x00 = 初始化功能                 AL       参数（波特率、数据位等）                 DX       串口号（0-3）           返回值：                 寄存器       内容                       AH       串口状态                 AL       Modem 状态           “Destroys AX” 注释的含义：  BIOS 中断会修改 AX 寄存器的值。调用后，我们不能假设 AX 还保持原来的值。如果需要 AX 的原值，必须在调用前保存。    第 5-6 行：打印启动信息  call puts .string \"Pintos\"   这是什么？  调用 puts 函数打印字符串 “Pintos”。  特殊的调用约定：  这里使用了一种巧妙的技术——字符串直接跟在 call 指令后面。puts 函数会：     从返回地址处读取字符串   打印字符串   返回到字符串之后继续执行   我们将在后面的文档中详细解释 puts 函数。  执行效果：  在 VGA 显示器和串口上都输出： Pintos   这让用户知道引导加载程序已经开始运行。    串口通信原理图解  数据发送过程           CPU                    串口控制器                  串口线     ┌──────────┐             ┌──────────────┐           ┌────────┐     │ 发送字符 │  写入数据   │              │  串行输出 │        │     │  'P'     │ ─────────► │ 发送缓冲区   │ ────────► │ TX ──► │     │          │            │              │           │        │     └──────────┘             └──────────────┘           └────────┘          字符 'P' = 0x50 = 01010000          传输波形：     ─┐ ┌─┐   ┌─┐   ┌─────┐      └─┘ └───┘ └───┘     └─       0 0 0 0 1 0 1 0 停止       │ └──┬──┘ └─┬─┘       │    │     │     起始  数据   数据   为什么是 9600 波特率？     9600 bps 意味着每秒传输 9600 个比特   每个字符需要 10 比特（1 起始 + 8 数据 + 1 停止）   所以每秒最多传输 960 个字符   对于引导阶段的调试输出来说足够了     在模拟器中的应用  QEMU  Pintos 通常在 QEMU 模拟器中运行。QEMU 可以将串口输出重定向：  # 串口输出到终端 qemu-system-i386 -serial stdio ...  # 串口输出到文件 qemu-system-i386 -serial file:serial.log ...   Bochs  在 Bochs 模拟器中，可以配置：  com1: enabled=1, mode=file, dev=serial.log     常见问题  Q1: 如果没有串口会怎样？  如果物理硬件上没有串口，BIOS 可能会忽略这些操作，或者返回错误状态。但这不会导致引导失败——我们还有 VGA 输出作为后备。  Q2: 为什么选择 9600 波特率？  9600 是一个常见的、广泛支持的波特率。更高的波特率（如 115200）可能在某些旧 BIOS 上不支持。  Q3: 什么是 “N-8-1”？     N：No parity（无奇偶校验）   8：8 个数据位   1：1 个停止位   这是最常见的串口配置。  Q4: 为什么同时输出到 VGA 和串口？  冗余输出确保在各种环境下都能看到调试信息：    有显示器时看 VGA   无显示器时看串口   调试时两者都看     实践示例  手动计算初始化参数  假设你想配置：2400 bps, 奇校验, 7 数据位, 2 停止位     波特率 2400 → 位 7-5 = 101   奇校验 → 位 4-3 = 01   2 停止位 → 位 2 = 1   7 数据位 → 位 1-0 = 10   结果：10101110 = 0xAE  mov $0xae, %al    # 2400 bps, Odd-7-2     练习思考          如果要使用 COM2（串口 1）而不是 COM1，应该如何修改代码？           计算参数值：19200 bps 是否被 BIOS INT 14h 支持？（提示：查看波特率选项表）           为什么在嵌入式系统开发中串口调试仍然很流行？        练习答案   点击查看答案 1       只需将 DX 设置为 1 而不是 0：      mov $1, %dx          # Serial port 1 (COM2) mov $0xe3, %al       # 9600 bps, N-8-1 int $0x14       或者使用节省空间的方式：     sub %dx, %dx inc %dx              # DX = 1, Serial port 1       串口编号对应关系：            DX = 0 → COM1 (0x3F8)       DX = 1 → COM2 (0x2F8)       DX = 2 → COM3 (0x3E8)       DX = 3 → COM4 (0x2E8)             点击查看答案 2       不支持。 BIOS INT 14h 的波特率选项表只到 9600 bps：                                 位 7-5           波特率                                           000           110                             001           150                             010           300                             011           600                             100           1200                             101           2400                             110           4800                             111           9600                           19200 bps 不在列表中。要使用更高波特率，需要：            直接编程串口控制器（写 I/O 端口 0x3F8 等）       设置除数锁存器来配置自定义波特率       这会增加代码复杂度，不适合 512 字节限制             点击查看答案 3       串口调试在嵌入式系统开发中仍然流行的原因：             简单可靠：                    协议简单，几乎不需要驱动           硬件实现成熟稳定           不依赖复杂的软件栈                       早期可用：                    在系统启动的最早阶段就可以工作           不需要操作系统支持           可以调试引导过程                       低资源消耗：                    不需要显卡、显示器           只需要 2-3 根线（TX、RX、GND）           适合资源受限的嵌入式设备                       远程访问：                    可以通过串口服务器远程调试           不需要物理接触设备           适合机房、工厂等环境                       历史兼容性：                    大量现有工具支持           开发人员熟悉           文档丰富                              下一部分  串口配置完成后，接下来我们要扫描硬盘，寻找 Pintos 内核分区。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（一）：初始化",
    "url": "/posts/pintos-loader-01-initialization/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  这是 Pintos 引导加载程序的第一部分，负责在 CPU 启动后建立最基本的运行环境。这部分代码非常短，但每一行都至关重要。    原始代码  # Runs in real mode, which is a 16-bit segment. \t.code16  # Set up segment registers. # Set stack to grow downward from 60 kB (after boot, the kernel # continues to use this stack for its initial thread).  \tsub %ax, %ax \tmov %ax, %ds \tmov %ax, %ss \tmov $0xf000, %esp     前置知识  计算机启动过程  当你按下电源按钮时，会发生以下事情：  flowchart LR     A[\"CPU 上电复位\"] --&gt; B[\"BIOS 启动\"]     B --&gt; C[\"BIOS 自检\"]     C --&gt; D[\"加载引导扇区&lt;br/&gt;到 0x7C00\"]     D --&gt; E[\"跳转执行&lt;br/&gt;Loader 代码\"]      CPU 上电复位：CPU 被初始化到一个已知状态   BIOS 启动：CPU 从固定地址（通常是 0xFFFF0）开始执行 BIOS 代码   BIOS 自检：检测内存、硬盘等硬件   加载引导扇区：BIOS 将硬盘第一个扇区（512 字节）加载到内存地址 0x7C00   跳转执行：BIOS 跳转到 0x7C00，开始执行我们的 loader 代码   什么是实模式（Real Mode）？  x86 处理器有多种运行模式：                 模式       位宽       最大内存       特点                       实模式       16位       1MB       CPU 启动时的默认模式                 保护模式       32位       4GB       现代操作系统使用                 长模式       64位       16EB       64位操作系统使用           CPU 启动时总是处于 16 位实模式，这是为了向后兼容最早的 8086 处理器（1978年）。  实模式的内存寻址  在实模式下，地址由两部分组成：段地址 和 偏移地址  物理地址 = 段地址 × 16 + 偏移地址   例如：    段地址 = 0x0000，偏移 = 0x7C00   物理地址 = 0x0000 × 16 + 0x7C00 = 0x7C00   这种设计允许 16 位寄存器访问 20 位地址空间（最大 1MB）。  段寄存器  x86 有 4 个主要的段寄存器：                 寄存器       名称       用途                       CS       Code Segment       代码段，指令从这里取                 DS       Data Segment       数据段，默认数据访问使用                 SS       Stack Segment       栈段，push/pop 使用                 ES       Extra Segment       附加段，字符串操作等使用             逐行详解  第 1 行：.code16  .code16   这是什么？  这是一个汇编器指令（Assembler Directive），不是 CPU 指令。它告诉汇编器（如 GAS）：     “接下来的代码应该生成 16 位的机器码”   为什么需要？  因为 CPU 启动时处于 16 位模式，我们必须使用 16 位指令。如果汇编器默认生成 32 位代码，CPU 会错误地解释这些指令。  对比示例：                 指令       16位机器码       32位机器码                       mov $0, %ax       B8 00 00       66 B8 00 00 00 00           可以看到，同一条指令在不同模式下编码完全不同。    第 2 行：sub %ax, %ax  sub %ax, %ax   这是什么？  这条指令将 AX 寄存器的值减去自身，结果存回 AX。  AX = AX - AX = 0   为什么不直接用 mov $0, %ax？  让我们比较两种方式：                 指令       机器码       字节数                       sub %ax, %ax       29 C0       2 字节                 mov $0, %ax       B8 00 00       3 字节           sub %ax, %ax 节省了 1 个字节！  在引导扇区中，我们只有 512 字节的空间，其中还包括数据结构。每一个字节都很宝贵，所以程序员使用这种技巧来节省空间。  其他等效的清零技巧：  sub %ax, %ax    # 2 字节，常用 xor %ax, %ax    # 2 字节，同样常用 and $0, %ax     # 3 字节，较少用 mov $0, %ax     # 3 字节，最直观     第 3-4 行：设置段寄存器  mov %ax, %ds mov %ax, %ss   这是什么？  将 AX 的值（现在是 0）复制到 DS 和 SS 寄存器。  为什么需要？  BIOS 跳转到我们的代码时，段寄存器的值是不确定的。不同的 BIOS 可能设置不同的值。为了确保代码正确运行，我们必须自己初始化它们。  为什么设置为 0？  设置 DS = SS = 0 意味着：     数据访问的物理地址 = 0 × 16 + 偏移 = 偏移   栈操作的物理地址 = 0 × 16 + 偏移 = 偏移   这样，偏移地址就等于物理地址，简化了地址计算。  为什么不设置 CS？  CS（代码段）不能直接用 mov 指令修改。它只能通过跳转指令（如 jmp、call、ret）间接改变。  BIOS 跳转到 0x7C00 时，通常设置 CS:IP = 0x0000:0x7C00，所以 CS 已经是 0。  为什么不设置 ES？  ES 会在后面使用前设置。这里先不管它。    第 5 行：设置栈指针  mov $0xf000, %esp   这是什么？  将栈指针 ESP 设置为 0xF000（十进制 61440，约 60KB）。  栈是什么？  栈是一块用于临时存储的内存区域，遵循”后进先出”（LIFO）原则：           高地址     ┌─────────────┐     │             │     │  （空闲）    │     │             │     ├─────────────┤ ← ESP 指向这里（栈顶）     │   数据 3    │     ├─────────────┤     │   数据 2    │     ├─────────────┤     │   数据 1    │     └─────────────┘          低地址   栈的用途：     保存函数返回地址   传递函数参数   存储局部变量   临时保存寄存器值   为什么选择 0xF000？  让我们看看内存布局：  地址              内容 ───────────────────────────────── 0x00000-0x003FF  中断向量表（BIOS 使用） 0x00400-0x004FF  BIOS 数据区 0x00500-0x07BFF  可用内存 0x07C00-0x07DFF  我们的 Loader（512 字节） 0x07E00-0x0FFFF  可用内存（约 33KB） 0x10000-...      后面会用来加载内核   0xF000 位于可用区域内，向下增长时不会覆盖 Loader 代码或 BIOS 数据。  为什么是 ESP 而不是 SP？  ESP 是 32 位寄存器，SP 是其低 16 位。在实模式下，只有低 16 位有效（0xF000），但使用 ESP 可以确保高位清零，避免潜在问题。  栈向下增长是什么意思？  当你执行 push 时：    ESP 先减小（例如从 0xF000 变成 0xEFFE）   然后数据写入新地址   当你执行 pop 时：    先读取 ESP 指向的数据   ESP 再增大   PUSH 操作：           POP 操作： ESP ↓ 减小           ESP ↑ 增大     栈向低地址增长     内存状态图  初始化完成后，内存状态如下：            物理地址     ┌─────────────────┐ 0x100000 (1MB)     │                 │     │   BIOS ROM 等   │     │                 │     ├─────────────────┤ 0xA0000 (640KB)     │                 │     │    可用内存      │     │   (用于内核)     │     │                 │     ├─────────────────┤ 0x10000 (64KB)     │                 │     │   栈空间 ↓       │ ← SS = 0     │                 │     ├─────────────────┤ 0x0F000 (60KB) ← ESP     │                 │     │   可用内存       │     │                 │     ├─────────────────┤ 0x07E00     │   Loader 代码   │     ├─────────────────┤ 0x07C00 ← DS = 0, 代码从这里开始     │   可用内存       │     ├─────────────────┤ 0x00500     │   BIOS 数据区   │     ├─────────────────┤ 0x00400     │   中断向量表     │     └─────────────────┘ 0x00000     常见问题  Q1: 为什么 BIOS 选择 0x7C00 这个地址？  这是历史原因。IBM PC 的最初设计者选择了这个地址：     0x7C00 = 0x7FFF - 512 + 1 = 32KB - 512 + 1   当时 IBM PC 最小内存是 32KB   引导扇区放在 32KB 末尾，为操作系统预留前面的空间   Q2: 初始化时 AX 的值是什么？  不确定！BIOS 可能在 AX 中放了任何值。这就是为什么我们要用 sub %ax, %ax 显式清零。  Q3: 如果不初始化段寄存器会怎样？  程序可能在某些 BIOS 上正常工作，在其他 BIOS 上崩溃。这是一个很难调试的问题，因为它依赖于具体的硬件。  Q4: 栈空间会不会太小？  0xF000 - 0x7E00 ≈ 29KB 的栈空间对于引导加载程序来说绰绰有余。我们只需要保存少量的返回地址和寄存器。    练习思考          如果将 sub %ax, %ax 改为 xor %ax, %ax，效果相同吗？为什么？           如果我们把栈设置在 0x7000 会有什么问题？           为什么不能用 mov $0, %cs 来设置代码段寄存器？        练习答案   点击查看答案 1       效果完全相同。 两条指令都将 AX 清零，且机器码都是 2 字节：                                 指令           机器码                                           sub %ax, %ax           29 C0                             xor %ax, %ax           31 C0                           两者的区别：            sub 会设置 CF（进位标志），而 xor 总是清除 CF       在这个场景下，这个区别无关紧要       两种写法在实际代码中都很常见             点击查看答案 2       如果把栈设置在 0x7000，可能会覆盖 Loader 代码！             Loader 代码位于 0x7C00-0x7DFF       栈向下增长       如果 ESP = 0x7000，当栈增长超过约 3KB 时（0x7000 → 0x6400），栈还是安全的       但如果函数调用层次很深或局部变量很多，栈向上增长到 0x7C00 以上就会覆盖代码           实际上 0x7000 的位置是相对安全的，因为栈向下增长不会到达代码区。但为了留出更多空间并避免与任何可能的数据冲突，选择 0xF000 更加保守和安全。        点击查看答案 3       CS 是代码段寄存器，出于安全和架构设计考虑，x86 不允许直接用 mov 指令修改它。      原因：            执行安全：如果可以随意修改 CS，程序可能跳转到任意代码执行，造成安全漏洞       原子性：修改 CS 必须同时修改 IP（指令指针），否则 CPU 会从错误位置取指令       设计决定：Intel 设计 x86 时决定 CS 只能通过以下方式改变：                    远跳转：ljmp segment:offset           远调用：lcall segment:offset           中断返回：iret           远返回：lret                           这些指令都会同时设置 CS 和 IP，保证执行的连续性。         下一部分  初始化完成后，下一步是配置串口，用于调试输出。请参阅下一篇文章。"
  },
  
  {
    "title": "Pintos Loader.S 详解（零）：系列概述",
    "url": "/posts/pintos-loader-00-overview/",
    "categories": "技术, Pintos",
    "tags": "OS, Pintos, 汇编, 引导加载程序",
    "date": "2026-01-21 00:00:00 +0800",
    "content": "概述  这是一个针对 Pintos 操作系统引导加载程序 loader.S 的详细分析文档系列，力求用简单易懂的方式解释每一个概念和代码片段。    文档列表                 序号       主题       简介                       1       初始化       段寄存器和栈的设置                 2       串口配置       配置串口用于调试输出                 3       扫描分区       扫描硬盘寻找 Pintos 内核分区                 4       加载内核       将内核从磁盘读取到内存                 5       跳转到内核       从 ELF 头读取入口地址并跳转                 6       错误处理       处理各种启动失败情况                 7       puts 函数       巧妙的字符串打印实现                 8       putc 函数       字符输出和自修改代码                 9       read_sector 函数       使用 BIOS 扩展读取磁盘                 10       数据结构       引导扇区末尾的数据定义             阅读顺序  建议按照文档编号顺序阅读，因为：    文档按代码执行顺序组织   后面的文档可能引用前面介绍的概念   辅助函数的文档放在最后，因为它们被多处调用     每个文档的结构  每个文档都包含以下部分：     概述：本部分代码的作用   原始代码：完整的汇编代码   前置知识：理解代码所需的背景知识   逐行详解：每一行代码的详细解释   图解/流程图：可视化的执行过程   常见问题：FAQ 解答常见疑惑   练习思考：帮助加深理解的思考题     先决知识  阅读这些文档前，最好了解：  基本编程概念    变量、函数、循环、条件判断   十六进制数表示   计算机基础    内存的概念   CPU 执行指令的基本原理   二进制和十六进制   可选但有帮助    任意一种汇编语言的基础   C 语言基础     术语表                 术语       解释                       BIOS       基本输入输出系统，提供底层硬件服务                 MBR       主引导记录，硬盘第一个扇区                 实模式       x86 CPU 启动时的 16 位模式                 保护模式       x86 CPU 的 32 位模式                 段寄存器       用于内存分段的特殊寄存器                 LBA       逻辑块寻址，现代磁盘寻址方式                 ELF       可执行文件格式                 中断       CPU 响应外部事件或软件请求的机制             相关文件     src/threads/loader.S - 引导加载程序源代码   src/threads/loader.h - 相关常量定义   src/threads/start.S - 内核入口点（loader 跳转的目标）     学习建议     边读边画：画出内存布局和执行流程图   动手实验：用调试器单步执行代码   修改代码：尝试做小修改看看效果   提出问题：不懂就问，记下疑惑     参考资料     Intel x86 手册   OSDev Wiki   Pintos 官方文档   BIOS 中断列表     祝学习愉快！"
  },
  
  {
    "title": "Git底层原理详解",
    "url": "/posts/git-underlying-principles/",
    "categories": "技术, 工具",
    "tags": "Git, 版本控制",
    "date": "2025-05-09 00:00:00 +0800",
    "content": "一. 前言 在一开始接触Git与Github时，我对Git的一些操作十分疑惑。作为一名学生，我常用的操作无非以下几种： # 创建仓库 git init   # 克隆仓库 git clone [repository url] # 将修改内容保存到暂存区 git add [file path] # 提交到本地仓库 git commit -m \"commit message\" # 推送到远端仓库 git push [remote branch name] [local branch name]   在创建仓库阶段，git init会创建一个.git文件夹。那我就很疑惑了，.git文件夹是用来干什么的？里面保存了些什么？这值得我们探究 在提交修改阶段，新手的我只会照葫芦画瓢，用最简单的方法： # 将所有修改内容写入暂存区 git add . # 提交到本地仓库 git commit -m \"commit message\" # 推送到远端仓库 git push origin main  It looks like magic! 在终端上打上几行，到Github上看,wow,真的把修改保存并推送上去了。🙌😭🙌 Amazing!  对于一般人来讲，了解这些也许就够用。但我想，这对学计算机的人来说远远不够。毕竟，“计算机中没有魔法”。所以，就让我们详细探究一下git的底层原理，理解这个堪称伟大的版本控制系统。 二. 初探 让我们先来看看这个神秘的.git文件夹中保存着什么： 1. 准备 首先，我们先新建一个git仓库,并切换到该文件夹 // Terminal 1 ╭─ ~ ────────────────────────────────────────────────────────────── 10:37:50 ─╮ ╰─❯ git init git-demo                                                        ─╯ 已初始化空的 Git 仓库于 /Users/apple/git-demo/.git/  ╭─ ~ ────────────────────────────────────────────────────────────── 17:02:24 ─╮ ╰─❯ cd git-demo  此时里面并没有任何东西，除了一个隐藏文件夹git(对于Mac系统来说)。我们可以用git status命令来查看当前git文件夹的状态 // Terminal 1 ╭─ ~/git-demo main ──────────────────────────────────────────────── 17:03:46 ─╮ ╰─❯ ls                                                                       ─╯  ╭─ ~/git-demo main ──────────────────────────────────────────────── 17:05:01 ─╮ ╰─❯ git status                                                               ─╯ 位于分支 main  尚无提交  无文件要提交（创建/拷贝文件并使用 \"git add\" 建立跟踪）  现在我们开一个新的终端并切换到git-demo目录，通过watch和tree工具来查看.git文件夹下保存了哪些内容。 我们需要安装tree和watch工具，tree用于用树状结构展现文件夹的内容，watch用于监视git内容的变化。 brew install tree brew install watch  然后，运行 // Terminal 2 # 0.5秒刷新一次 watch -n .5 tree .git  会显示这样的界面 // Terminal 2 Every 0.5s: tree. git                                                                                                                    .git ├── HEAD ├── config ├── description ├── hooks │   ├── applypatch-msg.sample │   ├── commit-msg.sample │   ├── fsmonitor-watchman.sample │   ├── post-update.sample │   ├── pre-applypatch.sample │   ├── pre-commit.sample │   ├── pre-merge-commit.sample │   ├── pre-push.sample │   ├── pre-rebase.sample │   ├── pre-receive.sample │   ├── prepare-commit-msg.sample │   ├── push-to-checkout.sample │   ├── sendemail-validate.sample │   └── update.sample ├── info │   └── exclude ├── objects │   ├── info │   └── pack └── refs     ├── heads     └── tags  9 directories, 18 files  （该操作后，Terminal 2 用于显示信息，Terminal 1 用于输入操作） 我们可以看到.git文件夹下有很多部分组成。目前我们先关注objects部分。为了方便观察与说明，我们先去掉hooks： rm -r .git/hooks  显示为 .git ├── HEAD ├── config ├── description ├── info │   └── exclude ├── objects │   ├── info │   └── pack └── refs     ├── heads     └── tags  2. 加入文件 现在我们往仓库中加入文件。 ╭─ ~/git-demo main ──────────────────────────────────────────────── 22:07:21 ─╮ ╰─❯ vim 1.txt  并在1.txt中写入hello world。我们发现.git文件夹并没有发生任何的改变。这也是合理的，我们只是在项目中加入了一个文件，还没有执行git的任何命令。现在，让我们把1.txt加入暂存区，正如我们经常做的那样： ╭─ ~/git-demo main ?1 ───────────────────────────────────────── 28s 22:14:54 ─╮ ╰─❯ git add 1.txt                                                            ─╯ 警告：在 '1.txt' 的工作拷贝中，下次 Git 接触时 LF 将被 CRLF 替换  .git文件夹变成了这样： .git ├── HEAD ├── config ├── description ├── index ├── info │   └── exclude ├── objects │   ├── 3b │   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad │   ├── info │   └── pack └── refs     ├── heads     └── tags  我们可以看到.git/objects文件夹下多了一个内容。那这一长串又是什么？这就涉及到git的底层设计哲学了。 在文件保存到.git文件夹中前，git会对你的文件的所有数据进行哈希处理，生成一个SHA-1的哈希值，这个哈希值就是你此次提交数据的唯一标识符。在我们的例子中，git根据1.txt的内容hello world生成了一个哈希值2e3c1c7a3faf540c6490fab43ac83bdfa17400eb用于标识该文件。我们还可以通过git hash-object命令来查看该文件的哈希值： ╭─ ~/git-demo main +1 ───────────────────────────────────────────── 22:19:58 ─╮ ╰─❯ git hash-object -w 1.txt                                                 ─╯ 警告：在 '1.txt' 的工作拷贝中，下次 Git 接触时 LF 将被 CRLF 替换 3b18e512dba79e4c8300dd08aeb37f8e728b8dad  可以看到，显示的哈希值与我们在.git/objects中看到的哈希值是一样的。 根据内容生成标识符有什么好处呢？首先，也是最重要的一点，它能时刻保证数据的完整性。当文件内容发生任何变化，无论该变化有多微小，哈希值都会发生非常大的改变，也就是说，git能时刻监控文件的变化。当文件在传输时变得不完整，数据损毁、缺失，git也能通过哈希值来检测到。其次，相同的文件内容会生成相同的哈希值，这就意味着git能通过哈希值来判断文件是否重复，也可以节省存储空间。比如我们在git中加入了一个文件2.txt，内容与1.txt完全相同： vim 2.txt git add 2.txt  我们发现git并没有任何变化。说明git并没有重复存储相同的文件。而当我们加入一个文件3.txt，内容为hello world!时， vim 3.txt git add 3.txt  显示为 .git ├── HEAD ├── config ├── description ├── index ├── info │   └── exclude ├── objects │   ├── 3b │   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad │   ├── a0 │   │   └── 423896973644771497bdc03eb99d5281615b51 │   ├── info │   └── pack └── refs     ├── heads     └── tags  我们可以看到，git又生成了一个新的哈希值a0423896973644771497bdc03eb99d5281615b51。 通过哈希值这个唯一标识符，我们也可以访问到对应的文件内容。我们可以通过git cat-file命令来查看: ╭─ ~/git-demo main +2 ───────────────────────────────────────────── 22:57:02 ─╮ ╰─❯ git cat-file -p 3b18                                                     ─╯ hello world  ╭─ ~/git-demo main +3 ───────────────────────────────────────────── 23:11:13 ─╮ ╰─❯ git cat-file -p a042                                                     ─╯ hello world!  在git中，文件的内容是以blob的形式存储的。blob是git中最基本的对象类型之一，表示一个二进制大对象（Binary Large Object）。它可以存储任何类型的数据，包括文本、图片、音频等。每个哈希值对应一个git对象，我们也可以通过git cat-file命令来查看该对象的类型： ╭─ ~/git-demo main ────────────────────────────────────────────────── 19:28:04 ─╮ ╰─❯ git cat-file -t 3b18                                                       ─╯ blob  在之后我们会遇到git的其他对象类型。 3. 提交 现在让我们试着提交一个文件。来看看.git文件夹会发生什么变化。 ╭─ ~/git-demo main +3 ─────────────────────────────────────────────── 23:12:45 ─╮ ╰─❯ git commit -m \"first commit\"                                               ─╯ [main（根提交） 757ba86] first commit  3 files changed, 3 insertions(+)  create mode 100644 1.txt  create mode 100644 2.txt  create mode 100644 3.txt  显示为 .git ├── COMMIT_EDITMSG ├── HEAD ├── config ├── description ├── index ├── info │   └── exclude ├── logs │   ├── HEAD │   └── refs │       └── heads │           └── main ├── objects │   ├── 1e │   │   └── f3e0cbf75b1f9063d5bf22a027cd35c3b34ae7 │   ├── 3b │   │   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad │   ├── 75 │   │   └── 7ba86751bfdf19169210b0bc8c9fa7ca208f07 │   ├── a0 │   │   └── 423896973644771497bdc03eb99d5281615b51 │   ├── info │   └── pack └── refs     ├── heads     │   └── main     └── tags  可以看到，.git文件夹下多了一个COMMIT_EDITMSG文件和一个logs文件夹。同时，objects文件夹下多了两个内容。 让我们使用git cat-file命令来查看一下多出来的两条哈希值。 ╭─ ~/git-demo main ────────────────────────────────────────────────── 19:23:44 ─╮ ╰─❯ git cat-file -p 1ef3                                                       ─╯ 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\t1.txt 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\t2.txt 100644 blob a0423896973644771497bdc03eb99d5281615b51\t3.txt  ╭─ ~/git-demo main ────────────────────────────────────────────────── 19:33:47 ─╮ ╰─❯ git cat-file -t 1ef3                                                       ─╯ tree  可以看到，1ef3是一个tree对象。在里面保存了三个blob对象，分别对应1.txt、2.txt和3.txt,也就是我们这次提交的三个文件。 我们再来看看757ba8这个哈希值： ╭─ ~/git-demo main ────────────────────────────────────────────────── 19:35:22 ─╮ ╰─❯ git cat-file -p 757b                                                       ─╯ tree 1ef3e0cbf75b1f9063d5bf22a027cd35c3b34ae7 author zxsheather &lt;zxsheather@sjtu.edu.cn&gt; 1746876224 +0800 committer zxsheather &lt;zxsheather@sjtu.edu.cn&gt; 1746876224 +0800  first commit  ╭─ ~/git-demo main ────────────────────────────────────────────────── 19:38:43 ─╮ ╰─❯ git cat-file -t 757b                                                       ─╯ commit  可以看到，757b是一个commit对象。它包含了一个指向tree对象的指针，指向了我们刚才提交的文件。它还包含了作者的姓名，邮件等，都是配置git时填好的。所谓的1746876224是一个Unix时间戳,表示自1970年1月1日以来的秒数。+0800表示时区偏移量，这里是中国的标准时区，东八区。"
  },
  
  {
    "title": "栈模拟递归的通用解法",
    "url": "/posts/stack_simulate_recursion/",
    "categories": "技术, 算法",
    "tags": "数据结构, 递归, 栈",
    "date": "2025-03-19 00:00:00 +0800",
    "content": "我们知道，递归的过程可以用栈来模拟。但对于一些困难的问题，我们好像很难用栈去写。比如说汉诺塔问题。再比如说: int f(int i){     return i &lt;= 1 ? 1 : f(i-1) + g(i-2); } int g(int i){     return i &lt;= 1 ? 1 : f(i+1) + g(i-1); }  在这些例子中，我们该怎么知道什么时候该入队，什么时候该出队呢？比如在第二个例子里，我们调用了f(i),我们并不能把f(i)立刻出队。即使f(i-1)计算完成，我们还需要等到g(i-2)计算完成后才能出队。 此时我们需要持有一种对计算机、程序的一种相当本质的看法：状态机。程序运行本质上都是一些状态的转换。我们在运行的过程中保存当前的状态pc，然后根据当前不同的状态执行不同的任务。 比如对于第二个例子，我们可以定义此时f或g所处于的状态为以下四个状态： enum State {     CALL,        // 初始调用      CALC_FIRST,  // 计算第一个子表达式     CALC_SECOND, // 计算第二个子表达式     RETURN       // 返回结果 };  我们在栈帧中保存以下几个值： struct StackFrame {     FuncType func; // 当前执行的函数类型     int i;         // 输入参数     State state;   // 当前执行状态     int result;    // 中间结果存储 };  取出栈顶的元素top，根据不同的状态，执行以下不同的任务： switch (top.state) {     case CALL:         // 处理基本情况         if (top.i &lt;= 1) {             top.result = 1;             top.state = RETURN;         } else {             // 设置为计算第一个子表达式的状态             top.state = CALC_FIRST;             if (top.func == FUNC_F) {                 // f 函数需要计算 f(i-1)                 callStack.push({FUNC_F, top.i - 1, CALL, 0});             } else {                 // g 函数需要计算 f(i+1)                 callStack.push({FUNC_F, top.i + 1, CALL, 0});             }         }         break;              case CALC_FIRST:         // 保存第一个子表达式结果         top.result = finalResult;         // 设置为计算第二个子表达式的状态         top.state = CALC_SECOND;         if (top.func == FUNC_F) {             // f 函数需要计算 g(i-2)             callStack.push({FUNC_G, top.i - 2, CALL, 0});         } else {             // g 函数需要计算 g(i-1)             callStack.push({FUNC_G, top.i - 1, CALL, 0});         }         break;              case CALC_SECOND:         // 计算最终结果 = 第一个子表达式结果 + 第二个子表达式结果         top.result += finalResult;         top.state = RETURN;         break;              case RETURN:         // 保存当前函数的计算结果         finalResult = top.result;         // 完成计算，弹出栈帧         callStack.pop();         break; }  在其中我们用finalResult变量来传递上一个弹出的栈帧所返回的值，将该值传递给调用它的函数.通过保存状态，我们就知道何时该函数该做什么事情。 以下是完整的代码： #include &lt;iostream&gt; #include &lt;stack&gt;  // 定义函数类型 enum FuncType {     FUNC_F, // f函数     FUNC_G  // g函数 };  // 定义计算状态 enum State {     CALL,        // 初始调用     CALC_FIRST,  // 计算第一个子表达式     CALC_SECOND, // 计算第二个子表达式     RETURN       // 返回结果 };  // 栈帧结构，存储每个调用的状态 struct StackFrame {     FuncType func; // 当前执行的函数类型     int i;         // 输入参数     State state;   // 当前执行状态     int result;    // 中间结果存储 };  // 统一的非递归计算函数 int calculate(FuncType initial_func, int initial_i) {     std::stack&lt;StackFrame&gt; callStack;          // 将初始调用推入栈中     callStack.push({initial_func, initial_i, CALL, 0});          int finalResult = 0;          while (!callStack.empty()) {         // 引用栈顶元素以便修改         StackFrame&amp; top = callStack.top();                  switch (top.state) {             case CALL:                 // 处理基本情况                 if (top.i &lt;= 1) {                     top.result = 1;                     top.state = RETURN;                 } else {                     // 设置为计算第一个子表达式的状态                     top.state = CALC_FIRST;                     if (top.func == FUNC_F) {                         // f 函数需要计算 f(i-1)                         callStack.push({FUNC_F, top.i - 1, CALL, 0});                     } else {                         // g 函数需要计算 f(i+1)                         callStack.push({FUNC_F, top.i + 1, CALL, 0});                     }                 }                 break;                              case CALC_FIRST:                 // 保存第一个子表达式结果                 top.result = finalResult;                 // 设置为计算第二个子表达式的状态                 top.state = CALC_SECOND;                 if (top.func == FUNC_F) {                     // f 函数需要计算 g(i-2)                     callStack.push({FUNC_G, top.i - 2, CALL, 0});                 } else {                     // g 函数需要计算 g(i-1)                     callStack.push({FUNC_G, top.i - 1, CALL, 0});                 }                 break;                              case CALC_SECOND:                 // 计算最终结果 = 第一个子表达式结果 + 第二个子表达式结果                 top.result += finalResult;                 top.state = RETURN;                 break;                              case RETURN:                 // 保存当前函数的计算结果                 finalResult = top.result;                 // 完成计算，弹出栈帧                 callStack.pop();                 break;         }     }          return finalResult; }  // f 函数的非递归实现 int f_non_recursive(int i) {     return calculate(FUNC_F, i); }  // g 函数的非递归实现 int g_non_recursive(int i) {     return calculate(FUNC_G, i); }  int main() {     int n = 5;     std::cout &lt;&lt; \"f(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; f_non_recursive(n) &lt;&lt; std::endl;     std::cout &lt;&lt; \"g(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; g_non_recursive(n) &lt;&lt; std::endl;     return 0; }  汉诺塔问题其实也类似。 这是汉诺塔问题的递归写法: #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std;  // 定义操作状态枚举，用于模拟递归过程中的不同阶段 enum Operation{     MOVE_N_1_TO_AUX,  // 将n-1个盘子从源柱移动到辅助柱     MOVE_N_TO_TAR,    // 将第n个盘子（最大的）从源柱移动到目标柱     MOVE_AUX_TO_TAR,  // 将n-1个盘子从辅助柱移动到目标柱     RETURN           // 当前操作完成，返回结果 };  // 定义栈帧结构体，存储每次\"函数调用\"的状态和参数 struct StackFrame{     int n;           // 当前要移动的盘子数量     char source;     // 源柱子     char auxiliary;  // 辅助柱子     char target;     // 目标柱子     Operation state; // 当前执行状态     int result;      // 存储移动次数结果 };  // 非递归实现汉诺塔问题，返回值为移动次数 int Hanoi(int n, char source, char auxiliary, char target){     // 创建调用栈，用于模拟递归过程     stack&lt;StackFrame&gt; callStack;          // 将初始调用推入栈中，初始状态为移动n-1个盘子到辅助柱     callStack.push({n, source, auxiliary, target, MOVE_N_1_TO_AUX, 0});          // 存储最终结果（总移动次数）     int finalResult = 0;          // 当栈不为空时，继续处理     while(!callStack.empty()){         // 引用栈顶元素以便修改         StackFrame &amp;top = callStack.top();                  // 根据当前状态执行相应操作         switch (top.state){             case MOVE_N_1_TO_AUX:{                 // 基本情况：只有一个盘子时，直接移动到目标柱                 if(top.n == 1){                     cout &lt;&lt; top.source &lt;&lt; \"-&gt;\" &lt;&lt; top.target &lt;&lt; endl;                     top.result = 1;  // 记录移动一次                     top.state = RETURN;  // 设置状态为返回                 }else{                     // 将n-1个盘子从源柱移到辅助柱（先记录下一步操作）                     top.state = MOVE_N_TO_TAR;  // 更新当前栈帧的下一状态                                          // 创建新的栈帧处理子问题：将n-1个盘子从source移到auxiliary，以target为辅助                     callStack.push({top.n - 1, top.source, top.target, top.auxiliary, MOVE_N_1_TO_AUX, 0});                 }                 break;             }             case MOVE_N_TO_TAR:{                 // 将第一子问题的结果加到当前结果中                 top.result += finalResult;                                  // 更新状态为移动辅助柱上的盘子到目标柱                 top.state = MOVE_AUX_TO_TAR;                                  // 移动最大的盘子从源柱到目标柱                 cout &lt;&lt; top.source &lt;&lt; \"-&gt;\" &lt;&lt; top.target &lt;&lt; endl;                 top.result++;  // 记录这次移动                                  // 创建新的栈帧处理第二子问题：将n-1个盘子从auxiliary移到source，以target为辅助                 callStack.push({top.n - 1, top.auxiliary, top.source, top.target, MOVE_N_1_TO_AUX, 0});                 break;             }             case MOVE_AUX_TO_TAR:{                 // 将第二子问题的结果加到当前结果中                 top.result += finalResult;                                  // 所有操作完成，设置状态为返回                 top.state = RETURN;                 break;             }             case RETURN:{                 // 保存当前栈帧的结果                 finalResult = top.result;                                  // 弹出已完成的栈帧                 callStack.pop();             }         }     }          // 返回汉诺塔问题的总移动次数     return finalResult; }  int main(){     // 设置盘子数量     int n = 3;          // 调用Hanoi函数，设定三根柱子为A、B、C     int result = Hanoi(n, 'A', 'B', 'C');          // 输出移动总次数     cout &lt;&lt; \"count:\" &lt;&lt; result;     return 0; }"
  },
  
  {
    "title": "欢迎来到我的网站",
    "url": "/posts/welcome_to_my_site/",
    "categories": "随笔",
    "tags": "个人介绍",
    "date": "2025-03-17 00:00:00 +0800",
    "content": "Writing is a solitary art. —— Susan Sontag    I write to make time pass more meaningfully. —— Jorge Luis Borges   个人的时光之河  Why I create this site?    我一直希望拥有一个独属于自己个人的一片小的天地。我感觉自己是一个很矛盾的人（不过也许每个人都是矛盾的），愿意分享，却不喜欢太热闹（所以我不常发朋友圈）；喜欢和别的人交流，却有时讨厌在太多的羁绊中花费太多精力；喜欢独处，却有时也感到孤独。而个人网站便是一个清净的空间，可以供我写下自己的思考与感悟，分享我个人的，一些小小的感受。正如苏珊·桑塔格所说：“写作是独处的艺术”。     我们通常认为博客是用来分享技术的手段。事实确然。我们在论坛中碰撞思维的火花，传播自己的知识秘笈,汲取别人的真知灼见。但若仅仅是技术的分享，在目前的时代，个人的博客，尤其是一个学生的博客似乎已然意义了了。一方面，介绍各种技术的博客琳琅满目，更不要提当今AI迅猛发展，生成式AI可以在眨眼之间生成质量颇高的内容。很多时候我也非常沮丧，自己用心写出的代码，耗时费力写完的项目，AI只用了几秒钟时间就能产出完成，甚至结构更加精良，细节更加完善。另一方面，知识的迭代速度越来越快，现在主流的观点与思想，在几年后也许已经变成一堆破铜烂铁，无人问津。但我想这个时代也有好处：它逼迫着我们转换看待写作或者写博客的角度。     写博客是知识的再整理。我们再试图教会别人的过程中也使一个知识点在我们脑海中愈发清晰。为了让别人理解一样技能，一种思考，我们自己首先需要有一个完整的良好的理解。而且，我们在给别人讲解的过程中，我们会将自己的思路展开。此时我们往往能在其中发现之前未曾注意到的漏洞，或者自己理解不深入的地方。我们也可以就此完善自己的思考。这在学习中是十分有益的。     写博客也是一种对抗时间的方式。时光不断流逝，却没留下任何足迹。飞鸿踏雪，杳无音讯。而博客，在我看来，更是时光的注脚。光阴似箭，日月如梭，而写作，就像一张快照，将我的思考，我的感悟定格在一个静止的时间。一篇篇博客，就像一个又一个纪念碑，标立在时间之河的两岸，记录着我的来路，描绘着我思考的成长历程，或许，也标示着我的未来。  当未来的我看这条由博客标立的时光之河，也许我也会颇有感慨吧。   时光之河"
  }
  
]

